<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Lua 4.0.1 source code - lcode.c</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../lua.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../source.css">
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
</HEAD>

<BODY>

<H1>
<A HREF="../../home.html"><IMG SRC="../../images/logo.gif" ALT="Lua"></A>
lcode.c
<SPAN CLASS="note">(4.0.1)</SPAN>
</H1>

<DIV CLASS="menubar">
<A HREF="./">module index</A>
&middot;
<A HREF="idx.html">name index</A>
&middot;
<A HREF="../">other versions</A>
</DIV>

<PRE>
/*
** $Id: lcode.c,v 1.51 2000/09/29 12:42:13 roberto Exp $
** Code generator for Lua
** See Copyright Notice in lua.h
*/


#include "stdlib.h"

#include "<A HREF="lua.h.html">lua.h</A>"

#include "<A HREF="lcode.h.html">lcode.h</A>"
#include "<A HREF="ldo.h.html">ldo.h</A>"
#include "<A HREF="llex.h.html">llex.h</A>"
#include "<A HREF="lmem.h.html">lmem.h</A>"
#include "<A HREF="lobject.h.html">lobject.h</A>"
#include "<A HREF="lopcodes.h.html">lopcodes.h</A>"
#include "<A HREF="lparser.h.html">lparser.h</A>"


void <A NAME="luaK_error"><SPAN CLASS="definition">luaK_error</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, const char *msg) {
  <A HREF="llex.c.html#luaX_error">luaX_error</A>(ls, msg, ls-&gt;t.token);
}


/*
** Returns the the previous instruction, for optimizations.
** If there is a jump target between this and the current instruction,
** returns a dummy instruction to avoid wrong optimizations.
*/
static <A HREF="llimits.h.html#Instruction">Instruction</A> <A NAME="previous_instruction"><SPAN CLASS="definition">previous_instruction</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs) {
  if (fs-&gt;pc &gt; fs-&gt;lasttarget)  /* no jumps to current position? */
    return fs-&gt;f-&gt;code[fs-&gt;pc-1];  /* returns previous instruction */
  else
    return <A HREF="lopcodes.h.html#CREATE_0">CREATE_0</A>(<A HREF="lopcodes.h.html#OP_END">OP_END</A>);  /* no optimizations after an `END' */
}


int <A NAME="luaK_jump"><SPAN CLASS="definition">luaK_jump</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs) {
  int j = <A HREF="lcode.c.html#luaK_code1">luaK_code1</A>(fs, <A HREF="lopcodes.h.html#OP_JMP">OP_JMP</A>, <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>);
  if (j == fs-&gt;lasttarget) {  /* possible jumps to this jump? */
    <A HREF="lcode.c.html#luaK_concat">luaK_concat</A>(fs, &amp;j, fs-&gt;jlt);  /* keep them on hold */
    fs-&gt;jlt = <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;
  }
  return j;
}


static void <A NAME="luaK_fixjump"><SPAN CLASS="definition">luaK_fixjump</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int pc, int dest) {
  <A HREF="llimits.h.html#Instruction">Instruction</A> *jmp = &amp;fs-&gt;f-&gt;code[pc];
  if (dest == <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>)
    <A HREF="lopcodes.h.html#SETARG_S">SETARG_S</A>(*jmp, <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>);  /* point to itself to represent end of list */
  else {  /* jump is relative to position following jump instruction */
    int offset = dest-(pc+1);
    if (abs(offset) &gt; <A HREF="llimits.h.html#MAXARG_S">MAXARG_S</A>)
      <A HREF="lcode.c.html#luaK_error">luaK_error</A>(fs-&gt;ls, "control structure too long");
    <A HREF="lopcodes.h.html#SETARG_S">SETARG_S</A>(*jmp, offset);
  }
}


static int <A NAME="luaK_getjump"><SPAN CLASS="definition">luaK_getjump</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int pc) {
  int offset = <A HREF="lopcodes.h.html#GETARG_S">GETARG_S</A>(fs-&gt;f-&gt;code[pc]);
  if (offset == <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>)  /* point to itself represents end of list */
    return <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;  /* end of list */
  else
    return (pc+1)+offset;  /* turn offset into absolute position */
}


/*
** returns current `pc' and marks it as a jump target (to avoid wrong
** optimizations with consecutive instructions not in the same basic block).
** <A HREF="lcode.c.html#discharge">discharge</A> list of jumps to last target.
*/
int <A NAME="luaK_getlabel"><SPAN CLASS="definition">luaK_getlabel</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs) {
  if (fs-&gt;pc != fs-&gt;lasttarget) {
    int lasttarget = fs-&gt;lasttarget;
    fs-&gt;lasttarget = fs-&gt;pc;
    <A HREF="lcode.c.html#luaK_patchlist">luaK_patchlist</A>(fs, fs-&gt;jlt, lasttarget);  /* <A HREF="lcode.c.html#discharge">discharge</A> old list `jlt' */
    fs-&gt;jlt = <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;  /* nobody jumps to this new label (yet) */
  }
  return fs-&gt;pc;
}


void <A NAME="luaK_deltastack"><SPAN CLASS="definition">luaK_deltastack</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int delta) {
  fs-&gt;stacklevel += delta;
  if (fs-&gt;stacklevel &gt; fs-&gt;f-&gt;maxstacksize) {
    if (fs-&gt;stacklevel &gt; <A HREF="llimits.h.html#MAXSTACK">MAXSTACK</A>)
      <A HREF="lcode.c.html#luaK_error">luaK_error</A>(fs-&gt;ls, "function or expression too complex");
    fs-&gt;f-&gt;maxstacksize = fs-&gt;stacklevel;
  }
}


void <A NAME="luaK_kstr"><SPAN CLASS="definition">luaK_kstr</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, int c) {
  <A HREF="lcode.c.html#luaK_code1">luaK_code1</A>(ls-&gt;fs, <A HREF="lopcodes.h.html#OP_PUSHSTRING">OP_PUSHSTRING</A>, c);
}


static int <A NAME="number_constant"><SPAN CLASS="definition">number_constant</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="llimits.h.html#Number">Number</A> r) {
  /* check whether `r' has appeared within the last <A HREF="llimits.h.html#LOOKBACKNUMS">LOOKBACKNUMS</A> entries */
  <A HREF="lobject.h.html#Proto">Proto</A> *f = fs-&gt;f;
  int c = f-&gt;nknum;
  int lim = c &lt; <A HREF="llimits.h.html#LOOKBACKNUMS">LOOKBACKNUMS</A> ? 0 : c-<A HREF="llimits.h.html#LOOKBACKNUMS">LOOKBACKNUMS</A>;
  while (--c &gt;= lim)
    if (f-&gt;knum[c] == r) return c;
  /* not found; create a new entry */
  <A HREF="lmem.h.html#luaM_growvector">luaM_growvector</A>(fs-&gt;L, f-&gt;knum, f-&gt;nknum, 1, <A HREF="llimits.h.html#Number">Number</A>,
                  "constant table overflow", <A HREF="llimits.h.html#MAXARG_U">MAXARG_U</A>);
  c = f-&gt;nknum++;
  f-&gt;knum[c] = r;
  return c;
}


void <A NAME="luaK_number"><SPAN CLASS="definition">luaK_number</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="llimits.h.html#Number">Number</A> f) {
  if (f &lt;= (<A HREF="llimits.h.html#Number">Number</A>)<A HREF="llimits.h.html#MAXARG_S">MAXARG_S</A> &amp;&amp; (<A HREF="llimits.h.html#Number">Number</A>)(int)f == f)
    <A HREF="lcode.c.html#luaK_code1">luaK_code1</A>(fs, <A HREF="lopcodes.h.html#OP_PUSHINT">OP_PUSHINT</A>, (int)f);  /* f has a short integer value */
  else
    <A HREF="lcode.c.html#luaK_code1">luaK_code1</A>(fs, <A HREF="lopcodes.h.html#OP_PUSHNUM">OP_PUSHNUM</A>, <A HREF="lcode.c.html#number_constant">number_constant</A>(fs, f));
}


void <A NAME="luaK_adjuststack"><SPAN CLASS="definition">luaK_adjuststack</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int n) {
  if (n &gt; 0)
    <A HREF="lcode.c.html#luaK_code1">luaK_code1</A>(fs, <A HREF="lopcodes.h.html#OP_POP">OP_POP</A>, n);
  else
    <A HREF="lcode.c.html#luaK_code1">luaK_code1</A>(fs, <A HREF="lopcodes.h.html#OP_PUSHNIL">OP_PUSHNIL</A>, -n);
}


int <A NAME="luaK_lastisopen"><SPAN CLASS="definition">luaK_lastisopen</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs) {
  /* check whether last instruction is an open function call */
  <A HREF="llimits.h.html#Instruction">Instruction</A> i = <A HREF="lcode.c.html#previous_instruction">previous_instruction</A>(fs);
  if (<A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(i) == <A HREF="lopcodes.h.html#OP_CALL">OP_CALL</A> &amp;&amp; <A HREF="lopcodes.h.html#GETARG_B">GETARG_B</A>(i) == <A HREF="lopcodes.h.html#MULT_RET">MULT_RET</A>)
    return 1;
  else return 0;
}


void <A NAME="luaK_setcallreturns"><SPAN CLASS="definition">luaK_setcallreturns</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int nresults) {
  if (<A HREF="lcode.c.html#luaK_lastisopen">luaK_lastisopen</A>(fs)) {  /* expression is an open function call? */
    <A HREF="lopcodes.h.html#SETARG_B">SETARG_B</A>(fs-&gt;f-&gt;code[fs-&gt;pc-1], nresults);  /* set number of results */
    <A HREF="lcode.c.html#luaK_deltastack">luaK_deltastack</A>(fs, nresults);  /* push results */
  }
}


static int <A NAME="discharge"><SPAN CLASS="definition">discharge</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lparser.h.html#expdesc">expdesc</A> *var) {
  switch (var-&gt;k) {
    case <A HREF="lparser.h.html#VLOCAL">VLOCAL</A>:
      <A HREF="lcode.c.html#luaK_code1">luaK_code1</A>(fs, <A HREF="lopcodes.h.html#OP_GETLOCAL">OP_GETLOCAL</A>, var-&gt;u.index);
      break;
    case <A HREF="lparser.h.html#VGLOBAL">VGLOBAL</A>:
      <A HREF="lcode.c.html#luaK_code1">luaK_code1</A>(fs, <A HREF="lopcodes.h.html#OP_GETGLOBAL">OP_GETGLOBAL</A>, var-&gt;u.index);
      break;
    case <A HREF="lparser.h.html#VINDEXED">VINDEXED</A>:
      <A HREF="lcode.c.html#luaK_code0">luaK_code0</A>(fs, <A HREF="lopcodes.h.html#OP_GETTABLE">OP_GETTABLE</A>);
      break;
    case <A HREF="lparser.h.html#VEXP">VEXP</A>:
      return 0;  /* nothing to do */
  }
  var-&gt;k = <A HREF="lparser.h.html#VEXP">VEXP</A>;
  var-&gt;u.l.t = var-&gt;u.l.f = <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;
  return 1;
}


static void <A NAME="discharge1"><SPAN CLASS="definition">discharge1</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lparser.h.html#expdesc">expdesc</A> *var) {
  <A HREF="lcode.c.html#discharge">discharge</A>(fs, var);
 /* if it has jumps then it is already discharged */
  if (var-&gt;u.l.t == <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A> &amp;&amp; var-&gt;u.l.f  == <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>)
    <A HREF="lcode.c.html#luaK_setcallreturns">luaK_setcallreturns</A>(fs, 1);  /* call must return 1 value */
}


void <A NAME="luaK_storevar"><SPAN CLASS="definition">luaK_storevar</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, const <A HREF="lparser.h.html#expdesc">expdesc</A> *var) {
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  switch (var-&gt;k) {
    case <A HREF="lparser.h.html#VLOCAL">VLOCAL</A>:
      <A HREF="lcode.c.html#luaK_code1">luaK_code1</A>(fs, <A HREF="lopcodes.h.html#OP_SETLOCAL">OP_SETLOCAL</A>, var-&gt;u.index);
      break;
    case <A HREF="lparser.h.html#VGLOBAL">VGLOBAL</A>:
      <A HREF="lcode.c.html#luaK_code1">luaK_code1</A>(fs, <A HREF="lopcodes.h.html#OP_SETGLOBAL">OP_SETGLOBAL</A>, var-&gt;u.index);
      break;
    case <A HREF="lparser.h.html#VINDEXED">VINDEXED</A>:  /* table is at top-3; pop 3 elements after operation */
      <A HREF="lcode.c.html#luaK_code2">luaK_code2</A>(fs, <A HREF="lopcodes.h.html#OP_SETTABLE">OP_SETTABLE</A>, 3, 3);
      break;
    default:
      <A HREF="lobject.h.html#LUA_INTERNALERROR">LUA_INTERNALERROR</A>("invalid var kind to store");
  }
}


static <A HREF="lopcodes.h.html#OpCode">OpCode</A> <A NAME="invertjump"><SPAN CLASS="definition">invertjump</SPAN></A> (<A HREF="lopcodes.h.html#OpCode">OpCode</A> op) {
  switch (op) {
    case <A HREF="lopcodes.h.html#OP_JMPNE">OP_JMPNE</A>: return <A HREF="lopcodes.h.html#OP_JMPEQ">OP_JMPEQ</A>;
    case <A HREF="lopcodes.h.html#OP_JMPEQ">OP_JMPEQ</A>: return <A HREF="lopcodes.h.html#OP_JMPNE">OP_JMPNE</A>;
    case <A HREF="lopcodes.h.html#OP_JMPLT">OP_JMPLT</A>: return <A HREF="lopcodes.h.html#OP_JMPGE">OP_JMPGE</A>;
    case <A HREF="lopcodes.h.html#OP_JMPLE">OP_JMPLE</A>: return <A HREF="lopcodes.h.html#OP_JMPGT">OP_JMPGT</A>;
    case <A HREF="lopcodes.h.html#OP_JMPGT">OP_JMPGT</A>: return <A HREF="lopcodes.h.html#OP_JMPLE">OP_JMPLE</A>;
    case <A HREF="lopcodes.h.html#OP_JMPGE">OP_JMPGE</A>: return <A HREF="lopcodes.h.html#OP_JMPLT">OP_JMPLT</A>;
    case <A HREF="lopcodes.h.html#OP_JMPT">OP_JMPT</A>: case <A HREF="lopcodes.h.html#OP_JMPONT">OP_JMPONT</A>:  return <A HREF="lopcodes.h.html#OP_JMPF">OP_JMPF</A>;
    case <A HREF="lopcodes.h.html#OP_JMPF">OP_JMPF</A>: case <A HREF="lopcodes.h.html#OP_JMPONF">OP_JMPONF</A>:  return <A HREF="lopcodes.h.html#OP_JMPT">OP_JMPT</A>;
    default:
      <A HREF="lobject.h.html#LUA_INTERNALERROR">LUA_INTERNALERROR</A>("invalid jump instruction");
      return <A HREF="lopcodes.h.html#OP_END">OP_END</A>;  /* to avoid warnings */
  }
}


static void <A NAME="luaK_patchlistaux"><SPAN CLASS="definition">luaK_patchlistaux</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int list, int target,
                               <A HREF="lopcodes.h.html#OpCode">OpCode</A> special, int special_target) {
  <A HREF="llimits.h.html#Instruction">Instruction</A> *code = fs-&gt;f-&gt;code;
  while (list != <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>) {
    int next = <A HREF="lcode.c.html#luaK_getjump">luaK_getjump</A>(fs, list);
    <A HREF="llimits.h.html#Instruction">Instruction</A> *i = &amp;code[list];
    <A HREF="lopcodes.h.html#OpCode">OpCode</A> op = <A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(*i);
    if (op == special)  /* this `op' already has a value */
      <A HREF="lcode.c.html#luaK_fixjump">luaK_fixjump</A>(fs, list, special_target);
    else {
      <A HREF="lcode.c.html#luaK_fixjump">luaK_fixjump</A>(fs, list, target);  /* do the patch */
      if (op == <A HREF="lopcodes.h.html#OP_JMPONT">OP_JMPONT</A>)  /* remove eventual values */
        <A HREF="lopcodes.h.html#SET_OPCODE">SET_OPCODE</A>(*i, <A HREF="lopcodes.h.html#OP_JMPT">OP_JMPT</A>);
      else if (op == <A HREF="lopcodes.h.html#OP_JMPONF">OP_JMPONF</A>)
        <A HREF="lopcodes.h.html#SET_OPCODE">SET_OPCODE</A>(*i, <A HREF="lopcodes.h.html#OP_JMPF">OP_JMPF</A>);
    }
    list = next;
  }
}


void <A NAME="luaK_patchlist"><SPAN CLASS="definition">luaK_patchlist</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int list, int target) {
  if (target == fs-&gt;lasttarget)  /* same target that list `jlt'? */
    <A HREF="lcode.c.html#luaK_concat">luaK_concat</A>(fs, &amp;fs-&gt;jlt, list);  /* delay fixing */
  else
    <A HREF="lcode.c.html#luaK_patchlistaux">luaK_patchlistaux</A>(fs, list, target, <A HREF="lopcodes.h.html#OP_END">OP_END</A>, 0);
}


static int <A NAME="need_value"><SPAN CLASS="definition">need_value</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int list, <A HREF="lopcodes.h.html#OpCode">OpCode</A> hasvalue) {
  /* check whether list has a jump without a value */
  for (; list != <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>; list = <A HREF="lcode.c.html#luaK_getjump">luaK_getjump</A>(fs, list))
    if (<A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(fs-&gt;f-&gt;code[list]) != hasvalue) return 1;
  return 0;  /* not found */
}


void <A NAME="luaK_concat"><SPAN CLASS="definition">luaK_concat</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int *l1, int l2) {
  if (*l1 == <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>)
    *l1 = l2;
  else {
    int list = *l1;
    for (;;) {  /* traverse `l1' */
      int next = <A HREF="lcode.c.html#luaK_getjump">luaK_getjump</A>(fs, list);
      if (next == <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>) {  /* end of list? */
        <A HREF="lcode.c.html#luaK_fixjump">luaK_fixjump</A>(fs, list, l2);
        return;
      }
      list = next;
    }
  }
}


static void <A NAME="luaK_testgo"><SPAN CLASS="definition">luaK_testgo</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lparser.h.html#expdesc">expdesc</A> *v, int invert, <A HREF="lopcodes.h.html#OpCode">OpCode</A> jump) {
  int prevpos;  /* position of last instruction */
  <A HREF="llimits.h.html#Instruction">Instruction</A> *previous;
  int *golist, *exitlist;
  if (!invert) {
    golist = &amp;v-&gt;u.l.f;    /* go if false */
    exitlist = &amp;v-&gt;u.l.t;  /* exit if true */
  }
  else {
    golist = &amp;v-&gt;u.l.t;    /* go if true */
    exitlist = &amp;v-&gt;u.l.f;  /* exit if false */
  }
  <A HREF="lcode.c.html#discharge1">discharge1</A>(fs, v);
  prevpos = fs-&gt;pc-1;
  previous = &amp;fs-&gt;f-&gt;code[prevpos];
  <A HREF="lobject.h.html#LUA_ASSERT">LUA_ASSERT</A>(*previous==<A HREF="lcode.c.html#previous_instruction">previous_instruction</A>(fs), "no jump allowed here");
  if (!<A HREF="lopcodes.h.html#ISJUMP">ISJUMP</A>(<A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(*previous)))
    prevpos = <A HREF="lcode.c.html#luaK_code1">luaK_code1</A>(fs, jump, <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>);
  else {  /* last instruction is already a jump */
    if (invert)
      <A HREF="lopcodes.h.html#SET_OPCODE">SET_OPCODE</A>(*previous, <A HREF="lcode.c.html#invertjump">invertjump</A>(<A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(*previous)));
  }
  <A HREF="lcode.c.html#luaK_concat">luaK_concat</A>(fs, exitlist, prevpos);  /* insert last jump in `exitlist' */
  <A HREF="lcode.c.html#luaK_patchlist">luaK_patchlist</A>(fs, *golist, <A HREF="lcode.c.html#luaK_getlabel">luaK_getlabel</A>(fs));
  *golist = <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;
}


void <A NAME="luaK_goiftrue"><SPAN CLASS="definition">luaK_goiftrue</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lparser.h.html#expdesc">expdesc</A> *v, int keepvalue) {
  <A HREF="lcode.c.html#luaK_testgo">luaK_testgo</A>(fs, v, 1, keepvalue ? <A HREF="lopcodes.h.html#OP_JMPONF">OP_JMPONF</A> : <A HREF="lopcodes.h.html#OP_JMPF">OP_JMPF</A>);
}


static void <A NAME="luaK_goiffalse"><SPAN CLASS="definition">luaK_goiffalse</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lparser.h.html#expdesc">expdesc</A> *v, int keepvalue) {
  <A HREF="lcode.c.html#luaK_testgo">luaK_testgo</A>(fs, v, 0, keepvalue ? <A HREF="lopcodes.h.html#OP_JMPONT">OP_JMPONT</A> : <A HREF="lopcodes.h.html#OP_JMPT">OP_JMPT</A>);
}


static int <A NAME="code_label"><SPAN CLASS="definition">code_label</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lopcodes.h.html#OpCode">OpCode</A> op, int arg) {
  <A HREF="lcode.c.html#luaK_getlabel">luaK_getlabel</A>(fs);  /* those instructions may be jump targets */
  return <A HREF="lcode.c.html#luaK_code1">luaK_code1</A>(fs, op, arg);
}


void <A NAME="luaK_tostack"><SPAN CLASS="definition">luaK_tostack</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, <A HREF="lparser.h.html#expdesc">expdesc</A> *v, int onlyone) {
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  if (!<A HREF="lcode.c.html#discharge">discharge</A>(fs, v)) {  /* `v' is an expression? */
    <A HREF="lopcodes.h.html#OpCode">OpCode</A> previous = <A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(fs-&gt;f-&gt;code[fs-&gt;pc-1]);
    if (!<A HREF="lopcodes.h.html#ISJUMP">ISJUMP</A>(previous) &amp;&amp; v-&gt;u.l.f == <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A> &amp;&amp; v-&gt;u.l.t == <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>) {
      /* expression has no jumps */
      if (onlyone)
        <A HREF="lcode.c.html#luaK_setcallreturns">luaK_setcallreturns</A>(fs, 1);  /* call must return 1 value */
    }
    else {  /* expression has jumps */
      int final;  /* position after whole expression */
      int j = <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;  /*  eventual  jump over values */
      int p_nil = <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;  /* position of an eventual PUSHNIL */
      int p_1 = <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;  /* position of an eventual PUSHINT */
      if (<A HREF="lopcodes.h.html#ISJUMP">ISJUMP</A>(previous) || <A HREF="lcode.c.html#need_value">need_value</A>(fs, v-&gt;u.l.f, <A HREF="lopcodes.h.html#OP_JMPONF">OP_JMPONF</A>)
                           || <A HREF="lcode.c.html#need_value">need_value</A>(fs, v-&gt;u.l.t, <A HREF="lopcodes.h.html#OP_JMPONT">OP_JMPONT</A>)) {
        /* expression needs values */
        if (<A HREF="lopcodes.h.html#ISJUMP">ISJUMP</A>(previous))
          <A HREF="lcode.c.html#luaK_concat">luaK_concat</A>(fs, &amp;v-&gt;u.l.t, fs-&gt;pc-1);  /* put `previous' in t. list */
        else {
          j = <A HREF="lcode.c.html#code_label">code_label</A>(fs, <A HREF="lopcodes.h.html#OP_JMP">OP_JMP</A>, <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>);  /* to jump over both pushes */
          /* correct stack for compiler and symbolic execution */
          <A HREF="lcode.c.html#luaK_adjuststack">luaK_adjuststack</A>(fs, 1);
        }
        p_nil = <A HREF="lcode.c.html#code_label">code_label</A>(fs, <A HREF="lopcodes.h.html#OP_PUSHNILJMP">OP_PUSHNILJMP</A>, 0);
        p_1 = <A HREF="lcode.c.html#code_label">code_label</A>(fs, <A HREF="lopcodes.h.html#OP_PUSHINT">OP_PUSHINT</A>, 1);
        <A HREF="lcode.c.html#luaK_patchlist">luaK_patchlist</A>(fs, j, <A HREF="lcode.c.html#luaK_getlabel">luaK_getlabel</A>(fs));
      }
      final = <A HREF="lcode.c.html#luaK_getlabel">luaK_getlabel</A>(fs);
      <A HREF="lcode.c.html#luaK_patchlistaux">luaK_patchlistaux</A>(fs, v-&gt;u.l.f, p_nil, <A HREF="lopcodes.h.html#OP_JMPONF">OP_JMPONF</A>, final);
      <A HREF="lcode.c.html#luaK_patchlistaux">luaK_patchlistaux</A>(fs, v-&gt;u.l.t, p_1, <A HREF="lopcodes.h.html#OP_JMPONT">OP_JMPONT</A>, final);
      v-&gt;u.l.f = v-&gt;u.l.t = <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;
    }
  }
}


void <A NAME="luaK_prefix"><SPAN CLASS="definition">luaK_prefix</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, <A HREF="lcode.h.html#UnOpr">UnOpr</A> op, <A HREF="lparser.h.html#expdesc">expdesc</A> *v) {
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  if (op == <A HREF="lcode.h.html#OPR_MINUS">OPR_MINUS</A>) {
    <A HREF="lcode.c.html#luaK_tostack">luaK_tostack</A>(ls, v, 1);
    <A HREF="lcode.c.html#luaK_code0">luaK_code0</A>(fs, <A HREF="lopcodes.h.html#OP_MINUS">OP_MINUS</A>);
  }
  else {  /* op == NOT */
    <A HREF="llimits.h.html#Instruction">Instruction</A> *previous;
    <A HREF="lcode.c.html#discharge1">discharge1</A>(fs, v);
    previous = &amp;fs-&gt;f-&gt;code[fs-&gt;pc-1];
    if (<A HREF="lopcodes.h.html#ISJUMP">ISJUMP</A>(<A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(*previous)))
      <A HREF="lopcodes.h.html#SET_OPCODE">SET_OPCODE</A>(*previous, <A HREF="lcode.c.html#invertjump">invertjump</A>(<A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(*previous)));
    else
      <A HREF="lcode.c.html#luaK_code0">luaK_code0</A>(fs, <A HREF="lopcodes.h.html#OP_NOT">OP_NOT</A>);
    /* interchange true and false lists */
    { int temp = v-&gt;u.l.f; v-&gt;u.l.f = v-&gt;u.l.t; v-&gt;u.l.t = temp; }
  }
}


void <A NAME="luaK_infix"><SPAN CLASS="definition">luaK_infix</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, <A HREF="lcode.h.html#BinOpr">BinOpr</A> op, <A HREF="lparser.h.html#expdesc">expdesc</A> *v) {
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  switch (op) {
    case <A HREF="lcode.h.html#OPR_AND">OPR_AND</A>:
      <A HREF="lcode.c.html#luaK_goiftrue">luaK_goiftrue</A>(fs, v, 1);
      break;
    case <A HREF="lcode.h.html#OPR_OR">OPR_OR</A>:
      <A HREF="lcode.c.html#luaK_goiffalse">luaK_goiffalse</A>(fs, v, 1);
      break;
    default:
      <A HREF="lcode.c.html#luaK_tostack">luaK_tostack</A>(ls, v, 1);  /* all other binary operators need a value */
  }
}



static const struct {
  <A HREF="lopcodes.h.html#OpCode">OpCode</A> opcode;  /* opcode for each binary operator */
  int arg;        /* default argument for the opcode */
} <A NAME="codes"><SPAN CLASS="definition">codes</SPAN></A>[] = {  /* ORDER OPR */
      {<A HREF="lopcodes.h.html#OP_ADD">OP_ADD</A>, 0}, {<A HREF="lopcodes.h.html#OP_SUB">OP_SUB</A>, 0}, {<A HREF="lopcodes.h.html#OP_MULT">OP_MULT</A>, 0}, {<A HREF="lopcodes.h.html#OP_DIV">OP_DIV</A>, 0},
      {<A HREF="lopcodes.h.html#OP_POW">OP_POW</A>, 0}, {<A HREF="lopcodes.h.html#OP_CONCAT">OP_CONCAT</A>, 2},
      {<A HREF="lopcodes.h.html#OP_JMPNE">OP_JMPNE</A>, <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>}, {<A HREF="lopcodes.h.html#OP_JMPEQ">OP_JMPEQ</A>, <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>},
      {<A HREF="lopcodes.h.html#OP_JMPLT">OP_JMPLT</A>, <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>}, {<A HREF="lopcodes.h.html#OP_JMPLE">OP_JMPLE</A>, <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>},
      {<A HREF="lopcodes.h.html#OP_JMPGT">OP_JMPGT</A>, <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>}, {<A HREF="lopcodes.h.html#OP_JMPGE">OP_JMPGE</A>, <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>}
};


void <A NAME="luaK_posfix"><SPAN CLASS="definition">luaK_posfix</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, <A HREF="lcode.h.html#BinOpr">BinOpr</A> op, <A HREF="lparser.h.html#expdesc">expdesc</A> *v1, <A HREF="lparser.h.html#expdesc">expdesc</A> *v2) {
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  switch (op) {
    case <A HREF="lcode.h.html#OPR_AND">OPR_AND</A>: {
      <A HREF="lobject.h.html#LUA_ASSERT">LUA_ASSERT</A>(v1-&gt;u.l.t == <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>, "list must be closed");
      <A HREF="lcode.c.html#discharge1">discharge1</A>(fs, v2);
      v1-&gt;u.l.t = v2-&gt;u.l.t;
      <A HREF="lcode.c.html#luaK_concat">luaK_concat</A>(fs, &amp;v1-&gt;u.l.f, v2-&gt;u.l.f);
      break;
    }
    case <A HREF="lcode.h.html#OPR_OR">OPR_OR</A>: {
      <A HREF="lobject.h.html#LUA_ASSERT">LUA_ASSERT</A>(v1-&gt;u.l.f == <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>, "list must be closed");
      <A HREF="lcode.c.html#discharge1">discharge1</A>(fs, v2);
      v1-&gt;u.l.f = v2-&gt;u.l.f;
      <A HREF="lcode.c.html#luaK_concat">luaK_concat</A>(fs, &amp;v1-&gt;u.l.t, v2-&gt;u.l.t);
      break;
    }
    default: {
      <A HREF="lcode.c.html#luaK_tostack">luaK_tostack</A>(ls, v2, 1);  /* `v2' must be a value */
      <A HREF="lcode.c.html#luaK_code1">luaK_code1</A>(fs, <A HREF="lcode.c.html#codes">codes</A>[op].opcode, <A HREF="lcode.c.html#codes">codes</A>[op].arg);
    }
  }
}


static void <A NAME="codelineinfo"><SPAN CLASS="definition">codelineinfo</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs) {
  <A HREF="lobject.h.html#Proto">Proto</A> *f = fs-&gt;f;
  <A HREF="llex.h.html#LexState">LexState</A> *ls = fs-&gt;ls;
  if (ls-&gt;lastline &gt; fs-&gt;lastline) {
    <A HREF="lmem.h.html#luaM_growvector">luaM_growvector</A>(fs-&gt;L, f-&gt;lineinfo, f-&gt;nlineinfo, 2, int,
                    "line info overflow", <A HREF="llimits.h.html#MAX_INT">MAX_INT</A>);
    if (ls-&gt;lastline &gt; fs-&gt;lastline+1)
      f-&gt;lineinfo[f-&gt;nlineinfo++] = -(ls-&gt;lastline - (fs-&gt;lastline+1));
    f-&gt;lineinfo[f-&gt;nlineinfo++] = fs-&gt;pc;
    fs-&gt;lastline = ls-&gt;lastline;
  }
}


int <A NAME="luaK_code0"><SPAN CLASS="definition">luaK_code0</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lopcodes.h.html#OpCode">OpCode</A> o) {
  return <A HREF="lcode.c.html#luaK_code2">luaK_code2</A>(fs, o, 0, 0);
}


int <A NAME="luaK_code1"><SPAN CLASS="definition">luaK_code1</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lopcodes.h.html#OpCode">OpCode</A> o, int arg1) {
  return <A HREF="lcode.c.html#luaK_code2">luaK_code2</A>(fs, o, arg1, 0);
}


int <A NAME="luaK_code2"><SPAN CLASS="definition">luaK_code2</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lopcodes.h.html#OpCode">OpCode</A> o, int arg1, int arg2) {
  <A HREF="llimits.h.html#Instruction">Instruction</A> i = <A HREF="lcode.c.html#previous_instruction">previous_instruction</A>(fs);
  int delta = <A HREF="lcode.c.html#luaK_opproperties">luaK_opproperties</A>[o].push - <A HREF="lcode.c.html#luaK_opproperties">luaK_opproperties</A>[o].pop;
  int optm = 0;  /* 1 when there is an optimization */
  switch (o) {
    case <A HREF="lopcodes.h.html#OP_CLOSURE">OP_CLOSURE</A>: {
      delta = -arg2+1;
      break;
    }
    case <A HREF="lopcodes.h.html#OP_SETTABLE">OP_SETTABLE</A>: {
      delta = -arg2;
      break;
    }
    case <A HREF="lopcodes.h.html#OP_SETLIST">OP_SETLIST</A>: {
      if (arg2 == 0) return <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;  /* nothing to do */
      delta = -arg2;
      break;
    }
    case <A HREF="lopcodes.h.html#OP_SETMAP">OP_SETMAP</A>: {
      if (arg1 == 0) return <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;  /* nothing to do */
      delta = -2*arg1;
      break;
    }
    case <A HREF="lopcodes.h.html#OP_RETURN">OP_RETURN</A>: {
      if (<A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(i) == <A HREF="lopcodes.h.html#OP_CALL">OP_CALL</A> &amp;&amp; <A HREF="lopcodes.h.html#GETARG_B">GETARG_B</A>(i) == <A HREF="lopcodes.h.html#MULT_RET">MULT_RET</A>) {
        <A HREF="lopcodes.h.html#SET_OPCODE">SET_OPCODE</A>(i, <A HREF="lopcodes.h.html#OP_TAILCALL">OP_TAILCALL</A>);
        <A HREF="lopcodes.h.html#SETARG_B">SETARG_B</A>(i, arg1);
        optm = 1;
      }
      break;
    }
    case <A HREF="lopcodes.h.html#OP_PUSHNIL">OP_PUSHNIL</A>: {
      if (arg1 == 0) return <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;  /* nothing to do */
      delta = arg1;
      switch(<A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(i)) {
        case <A HREF="lopcodes.h.html#OP_PUSHNIL">OP_PUSHNIL</A>: <A HREF="lopcodes.h.html#SETARG_U">SETARG_U</A>(i, <A HREF="lopcodes.h.html#GETARG_U">GETARG_U</A>(i)+arg1); optm = 1; break;
        default: break;
      }
      break;
    }
    case <A HREF="lopcodes.h.html#OP_POP">OP_POP</A>: {
      if (arg1 == 0) return <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;  /* nothing to do */
      delta = -arg1;
      switch(<A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(i)) {
        case <A HREF="lopcodes.h.html#OP_SETTABLE">OP_SETTABLE</A>: <A HREF="lopcodes.h.html#SETARG_B">SETARG_B</A>(i, <A HREF="lopcodes.h.html#GETARG_B">GETARG_B</A>(i)+arg1); optm = 1; break;
        default: break;
      }
      break;
    }
    case <A HREF="lopcodes.h.html#OP_GETTABLE">OP_GETTABLE</A>: {
      switch(<A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(i)) {
        case <A HREF="lopcodes.h.html#OP_PUSHSTRING">OP_PUSHSTRING</A>:  /* `t.x' */
          <A HREF="lopcodes.h.html#SET_OPCODE">SET_OPCODE</A>(i, <A HREF="lopcodes.h.html#OP_GETDOTTED">OP_GETDOTTED</A>);
          optm = 1;
          break;
        case <A HREF="lopcodes.h.html#OP_GETLOCAL">OP_GETLOCAL</A>:  /* `t[i]' */
          <A HREF="lopcodes.h.html#SET_OPCODE">SET_OPCODE</A>(i, <A HREF="lopcodes.h.html#OP_GETINDEXED">OP_GETINDEXED</A>);
          optm = 1;
          break;
        default: break;
      }
      break;
    }
    case <A HREF="lopcodes.h.html#OP_ADD">OP_ADD</A>: {
      switch(<A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(i)) {
        case <A HREF="lopcodes.h.html#OP_PUSHINT">OP_PUSHINT</A>: <A HREF="lopcodes.h.html#SET_OPCODE">SET_OPCODE</A>(i, <A HREF="lopcodes.h.html#OP_ADDI">OP_ADDI</A>); optm = 1; break;  /* `a+k' */
        default: break;
      }
      break;
    }
    case <A HREF="lopcodes.h.html#OP_SUB">OP_SUB</A>: {
      switch(<A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(i)) {
        case <A HREF="lopcodes.h.html#OP_PUSHINT">OP_PUSHINT</A>:  /* `a-k' */
          i = <A HREF="lopcodes.h.html#CREATE_S">CREATE_S</A>(<A HREF="lopcodes.h.html#OP_ADDI">OP_ADDI</A>, -<A HREF="lopcodes.h.html#GETARG_S">GETARG_S</A>(i));
          optm = 1;
          break;
        default: break;
      }
      break;
    }
    case <A HREF="lopcodes.h.html#OP_CONCAT">OP_CONCAT</A>: {
      delta = -arg1+1;
      switch(<A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(i)) {
        case <A HREF="lopcodes.h.html#OP_CONCAT">OP_CONCAT</A>:  /* `a..b..c' */
          <A HREF="lopcodes.h.html#SETARG_U">SETARG_U</A>(i, <A HREF="lopcodes.h.html#GETARG_U">GETARG_U</A>(i)+1);
          optm = 1;
          break;
        default: break;
      }
      break;
    }
    case <A HREF="lopcodes.h.html#OP_MINUS">OP_MINUS</A>: {
      switch(<A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(i)) {
        case <A HREF="lopcodes.h.html#OP_PUSHINT">OP_PUSHINT</A>:  /* `-k' */
          <A HREF="lopcodes.h.html#SETARG_S">SETARG_S</A>(i, -<A HREF="lopcodes.h.html#GETARG_S">GETARG_S</A>(i));
          optm = 1;
          break;
        case <A HREF="lopcodes.h.html#OP_PUSHNUM">OP_PUSHNUM</A>:  /* `-k' */
          <A HREF="lopcodes.h.html#SET_OPCODE">SET_OPCODE</A>(i, <A HREF="lopcodes.h.html#OP_PUSHNEGNUM">OP_PUSHNEGNUM</A>);
          optm = 1;
          break;
        default: break;
      }
      break;
    }
    case <A HREF="lopcodes.h.html#OP_JMPNE">OP_JMPNE</A>: {
      if (i == <A HREF="lopcodes.h.html#CREATE_U">CREATE_U</A>(<A HREF="lopcodes.h.html#OP_PUSHNIL">OP_PUSHNIL</A>, 1)) {  /* `a~=nil' */
        i = <A HREF="lopcodes.h.html#CREATE_S">CREATE_S</A>(<A HREF="lopcodes.h.html#OP_JMPT">OP_JMPT</A>, <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>);
        optm = 1;
      }
      break;
    }
    case <A HREF="lopcodes.h.html#OP_JMPEQ">OP_JMPEQ</A>: {
      if (i == <A HREF="lopcodes.h.html#CREATE_U">CREATE_U</A>(<A HREF="lopcodes.h.html#OP_PUSHNIL">OP_PUSHNIL</A>, 1)) {  /* `a==nil' */
        i = <A HREF="lopcodes.h.html#CREATE_0">CREATE_0</A>(<A HREF="lopcodes.h.html#OP_NOT">OP_NOT</A>);
        delta = -1;  /* just undo effect of previous PUSHNIL */
        optm = 1;
      }
      break;
    }
    case <A HREF="lopcodes.h.html#OP_JMPT">OP_JMPT</A>:
    case <A HREF="lopcodes.h.html#OP_JMPONT">OP_JMPONT</A>: {
      switch (<A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(i)) {
        case <A HREF="lopcodes.h.html#OP_NOT">OP_NOT</A>: {
          i = <A HREF="lopcodes.h.html#CREATE_S">CREATE_S</A>(<A HREF="lopcodes.h.html#OP_JMPF">OP_JMPF</A>, <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>);
          optm = 1;
          break;
        }
        case <A HREF="lopcodes.h.html#OP_PUSHINT">OP_PUSHINT</A>: {
          if (o == <A HREF="lopcodes.h.html#OP_JMPT">OP_JMPT</A>) {  /* JMPONT must keep original integer value */
            i = <A HREF="lopcodes.h.html#CREATE_S">CREATE_S</A>(<A HREF="lopcodes.h.html#OP_JMP">OP_JMP</A>, <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>);
            optm = 1;
          }
          break;
        }
        case <A HREF="lopcodes.h.html#OP_PUSHNIL">OP_PUSHNIL</A>: {
          if (<A HREF="lopcodes.h.html#GETARG_U">GETARG_U</A>(i) == 1) {
            fs-&gt;pc--;  /* erase previous instruction */
            <A HREF="lcode.c.html#luaK_deltastack">luaK_deltastack</A>(fs, -1);  /* correct stack */
            return <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>; 
          }
          break;
        }
        default: break;
      }
      break;
    }
    case <A HREF="lopcodes.h.html#OP_JMPF">OP_JMPF</A>:
    case <A HREF="lopcodes.h.html#OP_JMPONF">OP_JMPONF</A>: {
      switch (<A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(i)) {
        case <A HREF="lopcodes.h.html#OP_NOT">OP_NOT</A>: {
          i = <A HREF="lopcodes.h.html#CREATE_S">CREATE_S</A>(<A HREF="lopcodes.h.html#OP_JMPT">OP_JMPT</A>, <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>);
          optm = 1;
          break;
        }
        case <A HREF="lopcodes.h.html#OP_PUSHINT">OP_PUSHINT</A>: {  /* `while 1 do ...' */
          fs-&gt;pc--;  /* erase previous instruction */
          <A HREF="lcode.c.html#luaK_deltastack">luaK_deltastack</A>(fs, -1);  /* correct stack */
          return <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>; 
        }
        case <A HREF="lopcodes.h.html#OP_PUSHNIL">OP_PUSHNIL</A>: {  /* `repeat ... until nil' */
          if (<A HREF="lopcodes.h.html#GETARG_U">GETARG_U</A>(i) == 1) {
            i = <A HREF="lopcodes.h.html#CREATE_S">CREATE_S</A>(<A HREF="lopcodes.h.html#OP_JMP">OP_JMP</A>, <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>);
            optm = 1;
          }
          break;
        }
        default: break;
      }
      break;
    }
    case <A HREF="lopcodes.h.html#OP_GETDOTTED">OP_GETDOTTED</A>:
    case <A HREF="lopcodes.h.html#OP_GETINDEXED">OP_GETINDEXED</A>:
    case <A HREF="lopcodes.h.html#OP_TAILCALL">OP_TAILCALL</A>:
    case <A HREF="lopcodes.h.html#OP_ADDI">OP_ADDI</A>: {
      <A HREF="lobject.h.html#LUA_INTERNALERROR">LUA_INTERNALERROR</A>("instruction used only for optimizations");
      break;
    }
    default: {
      <A HREF="lobject.h.html#LUA_ASSERT">LUA_ASSERT</A>(delta != <A HREF="lcode.h.html#VD">VD</A>, "invalid delta");
      break;
    }
  }
  <A HREF="lcode.c.html#luaK_deltastack">luaK_deltastack</A>(fs, delta);
  if (optm) {  /* optimize: put instruction in place of last one */
      fs-&gt;f-&gt;code[fs-&gt;pc-1] = i;  /* change previous instruction */
      return fs-&gt;pc-1;  /* do not generate new instruction */
  }
  /* else build new instruction */
  switch ((enum <A HREF="lcode.h.html#Mode">Mode</A>)<A HREF="lcode.c.html#luaK_opproperties">luaK_opproperties</A>[o].mode) {
    case <A HREF="lcode.h.html#iO">iO</A>: i = <A HREF="lopcodes.h.html#CREATE_0">CREATE_0</A>(o); break;
    case <A HREF="lcode.h.html#iU">iU</A>: i = <A HREF="lopcodes.h.html#CREATE_U">CREATE_U</A>(o, arg1); break;
    case <A HREF="lcode.h.html#iS">iS</A>: i = <A HREF="lopcodes.h.html#CREATE_S">CREATE_S</A>(o, arg1); break;
    case <A HREF="lcode.h.html#iAB">iAB</A>: i = <A HREF="lopcodes.h.html#CREATE_AB">CREATE_AB</A>(o, arg1, arg2); break;
  }
  <A HREF="lcode.c.html#codelineinfo">codelineinfo</A>(fs);
  /* put new instruction in code array */
  <A HREF="lmem.h.html#luaM_growvector">luaM_growvector</A>(fs-&gt;L, fs-&gt;f-&gt;code, fs-&gt;pc, 1, <A HREF="llimits.h.html#Instruction">Instruction</A>,
                  "code size overflow", <A HREF="llimits.h.html#MAX_INT">MAX_INT</A>);
  fs-&gt;f-&gt;code[fs-&gt;pc] = i;
  return fs-&gt;pc++;
}


const struct <A HREF="lcode.h.html#OpProperties">OpProperties</A> <A NAME="luaK_opproperties"><SPAN CLASS="definition">luaK_opproperties</SPAN></A>[<A HREF="lopcodes.h.html#NUM_OPCODES">NUM_OPCODES</A>] = {
  {<A HREF="lcode.h.html#iO">iO</A>, 0, 0},   /* <A HREF="lopcodes.h.html#OP_END">OP_END</A> */
  {<A HREF="lcode.h.html#iU">iU</A>, 0, 0},   /* <A HREF="lopcodes.h.html#OP_RETURN">OP_RETURN</A> */
  {<A HREF="lcode.h.html#iAB">iAB</A>, 0, 0},  /* <A HREF="lopcodes.h.html#OP_CALL">OP_CALL</A> */
  {<A HREF="lcode.h.html#iAB">iAB</A>, 0, 0},  /* <A HREF="lopcodes.h.html#OP_TAILCALL">OP_TAILCALL</A> */
  {<A HREF="lcode.h.html#iU">iU</A>, <A HREF="lcode.h.html#VD">VD</A>, 0},  /* <A HREF="lopcodes.h.html#OP_PUSHNIL">OP_PUSHNIL</A> */
  {<A HREF="lcode.h.html#iU">iU</A>, <A HREF="lcode.h.html#VD">VD</A>, 0},  /* <A HREF="lopcodes.h.html#OP_POP">OP_POP</A> */
  {<A HREF="lcode.h.html#iS">iS</A>, 1, 0},   /* <A HREF="lopcodes.h.html#OP_PUSHINT">OP_PUSHINT</A> */
  {<A HREF="lcode.h.html#iU">iU</A>, 1, 0},   /* <A HREF="lopcodes.h.html#OP_PUSHSTRING">OP_PUSHSTRING</A> */
  {<A HREF="lcode.h.html#iU">iU</A>, 1, 0},   /* <A HREF="lopcodes.h.html#OP_PUSHNUM">OP_PUSHNUM</A> */
  {<A HREF="lcode.h.html#iU">iU</A>, 1, 0},   /* <A HREF="lopcodes.h.html#OP_PUSHNEGNUM">OP_PUSHNEGNUM</A> */
  {<A HREF="lcode.h.html#iU">iU</A>, 1, 0},   /* <A HREF="lopcodes.h.html#OP_PUSHUPVALUE">OP_PUSHUPVALUE</A> */
  {<A HREF="lcode.h.html#iU">iU</A>, 1, 0},   /* <A HREF="lopcodes.h.html#OP_GETLOCAL">OP_GETLOCAL</A> */
  {<A HREF="lcode.h.html#iU">iU</A>, 1, 0},   /* <A HREF="lopcodes.h.html#OP_GETGLOBAL">OP_GETGLOBAL</A> */
  {<A HREF="lcode.h.html#iO">iO</A>, 1, 2},   /* <A HREF="lopcodes.h.html#OP_GETTABLE">OP_GETTABLE</A> */
  {<A HREF="lcode.h.html#iU">iU</A>, 1, 1},   /* <A HREF="lopcodes.h.html#OP_GETDOTTED">OP_GETDOTTED</A> */
  {<A HREF="lcode.h.html#iU">iU</A>, 1, 1},   /* <A HREF="lopcodes.h.html#OP_GETINDEXED">OP_GETINDEXED</A> */
  {<A HREF="lcode.h.html#iU">iU</A>, 2, 1},   /* <A HREF="lopcodes.h.html#OP_PUSHSELF">OP_PUSHSELF</A> */
  {<A HREF="lcode.h.html#iU">iU</A>, 1, 0},   /* <A HREF="lopcodes.h.html#OP_CREATETABLE">OP_CREATETABLE</A> */
  {<A HREF="lcode.h.html#iU">iU</A>, 0, 1},   /* <A HREF="lopcodes.h.html#OP_SETLOCAL">OP_SETLOCAL</A> */
  {<A HREF="lcode.h.html#iU">iU</A>, 0, 1},   /* <A HREF="lopcodes.h.html#OP_SETGLOBAL">OP_SETGLOBAL</A> */
  {<A HREF="lcode.h.html#iAB">iAB</A>, <A HREF="lcode.h.html#VD">VD</A>, 0}, /* <A HREF="lopcodes.h.html#OP_SETTABLE">OP_SETTABLE</A> */
  {<A HREF="lcode.h.html#iAB">iAB</A>, <A HREF="lcode.h.html#VD">VD</A>, 0}, /* <A HREF="lopcodes.h.html#OP_SETLIST">OP_SETLIST</A> */
  {<A HREF="lcode.h.html#iU">iU</A>, <A HREF="lcode.h.html#VD">VD</A>, 0},  /* <A HREF="lopcodes.h.html#OP_SETMAP">OP_SETMAP</A> */
  {<A HREF="lcode.h.html#iO">iO</A>, 1, 2},   /* <A HREF="lopcodes.h.html#OP_ADD">OP_ADD</A> */
  {<A HREF="lcode.h.html#iS">iS</A>, 1, 1},   /* <A HREF="lopcodes.h.html#OP_ADDI">OP_ADDI</A> */
  {<A HREF="lcode.h.html#iO">iO</A>, 1, 2},   /* <A HREF="lopcodes.h.html#OP_SUB">OP_SUB</A> */
  {<A HREF="lcode.h.html#iO">iO</A>, 1, 2},   /* <A HREF="lopcodes.h.html#OP_MULT">OP_MULT</A> */
  {<A HREF="lcode.h.html#iO">iO</A>, 1, 2},   /* <A HREF="lopcodes.h.html#OP_DIV">OP_DIV</A> */
  {<A HREF="lcode.h.html#iO">iO</A>, 1, 2},   /* <A HREF="lopcodes.h.html#OP_POW">OP_POW</A> */
  {<A HREF="lcode.h.html#iU">iU</A>, <A HREF="lcode.h.html#VD">VD</A>, 0},  /* <A HREF="lopcodes.h.html#OP_CONCAT">OP_CONCAT</A> */
  {<A HREF="lcode.h.html#iO">iO</A>, 1, 1},   /* <A HREF="lopcodes.h.html#OP_MINUS">OP_MINUS</A> */
  {<A HREF="lcode.h.html#iO">iO</A>, 1, 1},   /* <A HREF="lopcodes.h.html#OP_NOT">OP_NOT</A> */
  {<A HREF="lcode.h.html#iS">iS</A>, 0, 2},   /* <A HREF="lopcodes.h.html#OP_JMPNE">OP_JMPNE</A> */
  {<A HREF="lcode.h.html#iS">iS</A>, 0, 2},   /* <A HREF="lopcodes.h.html#OP_JMPEQ">OP_JMPEQ</A> */
  {<A HREF="lcode.h.html#iS">iS</A>, 0, 2},   /* <A HREF="lopcodes.h.html#OP_JMPLT">OP_JMPLT</A> */
  {<A HREF="lcode.h.html#iS">iS</A>, 0, 2},   /* <A HREF="lopcodes.h.html#OP_JMPLE">OP_JMPLE</A> */
  {<A HREF="lcode.h.html#iS">iS</A>, 0, 2},   /* <A HREF="lopcodes.h.html#OP_JMPGT">OP_JMPGT</A> */
  {<A HREF="lcode.h.html#iS">iS</A>, 0, 2},   /* <A HREF="lopcodes.h.html#OP_JMPGE">OP_JMPGE</A> */
  {<A HREF="lcode.h.html#iS">iS</A>, 0, 1},   /* <A HREF="lopcodes.h.html#OP_JMPT">OP_JMPT</A> */
  {<A HREF="lcode.h.html#iS">iS</A>, 0, 1},   /* <A HREF="lopcodes.h.html#OP_JMPF">OP_JMPF</A> */
  {<A HREF="lcode.h.html#iS">iS</A>, 0, 1},   /* <A HREF="lopcodes.h.html#OP_JMPONT">OP_JMPONT</A> */
  {<A HREF="lcode.h.html#iS">iS</A>, 0, 1},   /* <A HREF="lopcodes.h.html#OP_JMPONF">OP_JMPONF</A> */
  {<A HREF="lcode.h.html#iS">iS</A>, 0, 0},   /* <A HREF="lopcodes.h.html#OP_JMP">OP_JMP</A> */
  {<A HREF="lcode.h.html#iO">iO</A>, 0, 0},   /* <A HREF="lopcodes.h.html#OP_PUSHNILJMP">OP_PUSHNILJMP</A> */
  {<A HREF="lcode.h.html#iS">iS</A>, 0, 0},   /* <A HREF="lopcodes.h.html#OP_FORPREP">OP_FORPREP</A> */
  {<A HREF="lcode.h.html#iS">iS</A>, 0, 3},   /* <A HREF="lopcodes.h.html#OP_FORLOOP">OP_FORLOOP</A> */
  {<A HREF="lcode.h.html#iS">iS</A>, 2, 0},   /* <A HREF="lopcodes.h.html#OP_LFORPREP">OP_LFORPREP</A> */
  {<A HREF="lcode.h.html#iS">iS</A>, 0, 3},   /* <A HREF="lopcodes.h.html#OP_LFORLOOP">OP_LFORLOOP</A> */
  {<A HREF="lcode.h.html#iAB">iAB</A>, <A HREF="lcode.h.html#VD">VD</A>, 0}  /* <A HREF="lopcodes.h.html#OP_CLOSURE">OP_CLOSURE</A> */
};

</PRE>

<P CLASS="footer">
Last update:
Sat Mar  5 09:29:30 2016
</P>

</BODY>
</HTML>
