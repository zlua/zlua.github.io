<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Lua 5.3.2 source code - lstrlib.c</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../lua.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../source.css">
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
</HEAD>

<BODY>

<H1>
<A HREF="../../home.html"><IMG SRC="../../images/logo.gif" ALT="Lua"></A>
lstrlib.c
<SPAN CLASS="note">(5.3.2)</SPAN>
</H1>

<DIV CLASS="menubar">
<A HREF="./">module index</A>
&middot;
<A HREF="idx.html">name index</A>
&middot;
<A HREF="../">other versions</A>
</DIV>

<PRE>
/*
** $Id: lstrlib.c,v 1.239 2015/11/25 16:28:17 roberto Exp $
** Standard library for string operations and pattern-matching
** See Copyright Notice in lua.h
*/

#define <A NAME="lstrlib_c"><SPAN CLASS="definition">lstrlib_c</SPAN></A>
#define <A NAME="LUA_LIB"><SPAN CLASS="definition">LUA_LIB</SPAN></A>

#include "<A HREF="lprefix.h.html">lprefix.h</A>"


#include &lt;ctype.h&gt;
#include &lt;float.h&gt;
#include &lt;limits.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include "<A HREF="lua.h.html">lua.h</A>"

#include "<A HREF="lauxlib.h.html">lauxlib.h</A>"
#include "<A HREF="lualib.h.html">lualib.h</A>"


/*
** maximum number of captures that a pattern can do during
** pattern-matching. This limit is arbitrary.
*/
#if !defined(<A HREF="lstrlib.c.html#LUA_MAXCAPTURES">LUA_MAXCAPTURES</A>)
#define <A NAME="LUA_MAXCAPTURES"><SPAN CLASS="definition">LUA_MAXCAPTURES</SPAN></A>         32
#endif


/* macro to 'unsign' a character */
#define <A NAME="uchar"><SPAN CLASS="definition">uchar</SPAN></A>(c)        ((unsigned char)(c))


/*
** Some sizes are better limited to fit in 'int', but must also fit in
** 'size_t'. (We assume that '<A HREF="lua.h.html#lua_Integer">lua_Integer</A>' cannot be smaller than 'int'.)
*/
#define <A NAME="MAX_SIZET"><SPAN CLASS="definition">MAX_SIZET</SPAN></A>       ((size_t)(~(size_t)0))

#define <A NAME="MAXSIZE"><SPAN CLASS="definition">MAXSIZE</SPAN></A>  \
        (sizeof(size_t) &lt; sizeof(int) ? <A HREF="lstrlib.c.html#MAX_SIZET">MAX_SIZET</A> : (size_t)(INT_MAX))




static int <A NAME="str_len"><SPAN CLASS="definition">str_len</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  size_t l;
  <A HREF="lauxlib.c.html#luaL_checklstring">luaL_checklstring</A>(L, 1, &amp;l);
  <A HREF="lapi.c.html#lua_pushinteger">lua_pushinteger</A>(L, (<A HREF="lua.h.html#lua_Integer">lua_Integer</A>)l);
  return 1;
}


/* translate a relative string position: negative means back from end */
static <A HREF="lua.h.html#lua_Integer">lua_Integer</A> <A NAME="posrelat"><SPAN CLASS="definition">posrelat</SPAN></A> (<A HREF="lua.h.html#lua_Integer">lua_Integer</A> pos, size_t len) {
  if (pos &gt;= 0) return pos;
  else if (0u - (size_t)pos &gt; len) return 0;
  else return (<A HREF="lua.h.html#lua_Integer">lua_Integer</A>)len + pos + 1;
}


static int <A NAME="str_sub"><SPAN CLASS="definition">str_sub</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  size_t l;
  const char *s = <A HREF="lauxlib.c.html#luaL_checklstring">luaL_checklstring</A>(L, 1, &amp;l);
  <A HREF="lua.h.html#lua_Integer">lua_Integer</A> start = <A HREF="lstrlib.c.html#posrelat">posrelat</A>(<A HREF="lauxlib.c.html#luaL_checkinteger">luaL_checkinteger</A>(L, 2), l);
  <A HREF="lua.h.html#lua_Integer">lua_Integer</A> end = <A HREF="lstrlib.c.html#posrelat">posrelat</A>(<A HREF="lauxlib.c.html#luaL_optinteger">luaL_optinteger</A>(L, 3, -1), l);
  if (start &lt; 1) start = 1;
  if (end &gt; (<A HREF="lua.h.html#lua_Integer">lua_Integer</A>)l) end = l;
  if (start &lt;= end)
    <A HREF="lapi.c.html#lua_pushlstring">lua_pushlstring</A>(L, s + start - 1, (size_t)(end - start) + 1);
  else <A HREF="lua.h.html#lua_pushliteral">lua_pushliteral</A>(L, "");
  return 1;
}


static int <A NAME="str_reverse"><SPAN CLASS="definition">str_reverse</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  size_t l, i;
  <A HREF="lauxlib.h.html#luaL_Buffer">luaL_Buffer</A> b;
  const char *s = <A HREF="lauxlib.c.html#luaL_checklstring">luaL_checklstring</A>(L, 1, &amp;l);
  char *p = <A HREF="lauxlib.c.html#luaL_buffinitsize">luaL_buffinitsize</A>(L, &amp;b, l);
  for (i = 0; i &lt; l; i++)
    p[i] = s[l - i - 1];
  <A HREF="lauxlib.c.html#luaL_pushresultsize">luaL_pushresultsize</A>(&amp;b, l);
  return 1;
}


static int <A NAME="str_lower"><SPAN CLASS="definition">str_lower</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  size_t l;
  size_t i;
  <A HREF="lauxlib.h.html#luaL_Buffer">luaL_Buffer</A> b;
  const char *s = <A HREF="lauxlib.c.html#luaL_checklstring">luaL_checklstring</A>(L, 1, &amp;l);
  char *p = <A HREF="lauxlib.c.html#luaL_buffinitsize">luaL_buffinitsize</A>(L, &amp;b, l);
  for (i=0; i&lt;l; i++)
    p[i] = tolower(<A HREF="lstrlib.c.html#uchar">uchar</A>(s[i]));
  <A HREF="lauxlib.c.html#luaL_pushresultsize">luaL_pushresultsize</A>(&amp;b, l);
  return 1;
}


static int <A NAME="str_upper"><SPAN CLASS="definition">str_upper</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  size_t l;
  size_t i;
  <A HREF="lauxlib.h.html#luaL_Buffer">luaL_Buffer</A> b;
  const char *s = <A HREF="lauxlib.c.html#luaL_checklstring">luaL_checklstring</A>(L, 1, &amp;l);
  char *p = <A HREF="lauxlib.c.html#luaL_buffinitsize">luaL_buffinitsize</A>(L, &amp;b, l);
  for (i=0; i&lt;l; i++)
    p[i] = toupper(<A HREF="lstrlib.c.html#uchar">uchar</A>(s[i]));
  <A HREF="lauxlib.c.html#luaL_pushresultsize">luaL_pushresultsize</A>(&amp;b, l);
  return 1;
}


static int <A NAME="str_rep"><SPAN CLASS="definition">str_rep</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  size_t l, lsep;
  const char *s = <A HREF="lauxlib.c.html#luaL_checklstring">luaL_checklstring</A>(L, 1, &amp;l);
  <A HREF="lua.h.html#lua_Integer">lua_Integer</A> n = <A HREF="lauxlib.c.html#luaL_checkinteger">luaL_checkinteger</A>(L, 2);
  const char *sep = <A HREF="lauxlib.c.html#luaL_optlstring">luaL_optlstring</A>(L, 3, "", &amp;lsep);
  if (n &lt;= 0) <A HREF="lua.h.html#lua_pushliteral">lua_pushliteral</A>(L, "");
  else if (l + lsep &lt; l || l + lsep &gt; <A HREF="lstrlib.c.html#MAXSIZE">MAXSIZE</A> / n)  /* may overflow? */
    return <A HREF="lauxlib.c.html#luaL_error">luaL_error</A>(L, "resulting string too large");
  else {
    size_t totallen = (size_t)n * l + (size_t)(n - 1) * lsep;
    <A HREF="lauxlib.h.html#luaL_Buffer">luaL_Buffer</A> b;
    char *p = <A HREF="lauxlib.c.html#luaL_buffinitsize">luaL_buffinitsize</A>(L, &amp;b, totallen);
    while (n-- &gt; 1) {  /* first n-1 copies (followed by separator) */
      memcpy(p, s, l * sizeof(char)); p += l;
      if (lsep &gt; 0) {  /* empty 'memcpy' is not that cheap */
        memcpy(p, sep, lsep * sizeof(char));
        p += lsep;
      }
    }
    memcpy(p, s, l * sizeof(char));  /* last copy (not followed by separator) */
    <A HREF="lauxlib.c.html#luaL_pushresultsize">luaL_pushresultsize</A>(&amp;b, totallen);
  }
  return 1;
}


static int <A NAME="str_byte"><SPAN CLASS="definition">str_byte</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  size_t l;
  const char *s = <A HREF="lauxlib.c.html#luaL_checklstring">luaL_checklstring</A>(L, 1, &amp;l);
  <A HREF="lua.h.html#lua_Integer">lua_Integer</A> posi = <A HREF="lstrlib.c.html#posrelat">posrelat</A>(<A HREF="lauxlib.c.html#luaL_optinteger">luaL_optinteger</A>(L, 2, 1), l);
  <A HREF="lua.h.html#lua_Integer">lua_Integer</A> pose = <A HREF="lstrlib.c.html#posrelat">posrelat</A>(<A HREF="lauxlib.c.html#luaL_optinteger">luaL_optinteger</A>(L, 3, posi), l);
  int n, i;
  if (posi &lt; 1) posi = 1;
  if (pose &gt; (<A HREF="lua.h.html#lua_Integer">lua_Integer</A>)l) pose = l;
  if (posi &gt; pose) return 0;  /* empty interval; return no values */
  if (pose - posi &gt;= INT_MAX)  /* arithmetic overflow? */
    return <A HREF="lauxlib.c.html#luaL_error">luaL_error</A>(L, "string slice too long");
  n = (int)(pose -  posi) + 1;
  <A HREF="lauxlib.c.html#luaL_checkstack">luaL_checkstack</A>(L, n, "string slice too long");
  for (i=0; i&lt;n; i++)
    <A HREF="lapi.c.html#lua_pushinteger">lua_pushinteger</A>(L, <A HREF="lstrlib.c.html#uchar">uchar</A>(s[posi+i-1]));
  return n;
}


static int <A NAME="str_char"><SPAN CLASS="definition">str_char</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  int n = <A HREF="lapi.c.html#lua_gettop">lua_gettop</A>(L);  /* number of arguments */
  int i;
  <A HREF="lauxlib.h.html#luaL_Buffer">luaL_Buffer</A> b;
  char *p = <A HREF="lauxlib.c.html#luaL_buffinitsize">luaL_buffinitsize</A>(L, &amp;b, n);
  for (i=1; i&lt;=n; i++) {
    <A HREF="lua.h.html#lua_Integer">lua_Integer</A> c = <A HREF="lauxlib.c.html#luaL_checkinteger">luaL_checkinteger</A>(L, i);
    <A HREF="lauxlib.h.html#luaL_argcheck">luaL_argcheck</A>(L, <A HREF="lstrlib.c.html#uchar">uchar</A>(c) == c, i, "value out of range");
    p[i - 1] = <A HREF="lstrlib.c.html#uchar">uchar</A>(c);
  }
  <A HREF="lauxlib.c.html#luaL_pushresultsize">luaL_pushresultsize</A>(&amp;b, n);
  return 1;
}


static int <A NAME="writer"><SPAN CLASS="definition">writer</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L, const void *b, size_t size, void *B) {
  (void)L;
  <A HREF="lauxlib.c.html#luaL_addlstring">luaL_addlstring</A>((<A HREF="lauxlib.h.html#luaL_Buffer">luaL_Buffer</A> *) B, (const char *)b, size);
  return 0;
}


static int <A NAME="str_dump"><SPAN CLASS="definition">str_dump</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  <A HREF="lauxlib.h.html#luaL_Buffer">luaL_Buffer</A> b;
  int strip = <A HREF="lapi.c.html#lua_toboolean">lua_toboolean</A>(L, 2);
  <A HREF="lauxlib.c.html#luaL_checktype">luaL_checktype</A>(L, 1, <A HREF="lua.h.html#LUA_TFUNCTION">LUA_TFUNCTION</A>);
  <A HREF="lapi.c.html#lua_settop">lua_settop</A>(L, 1);
  <A HREF="lauxlib.c.html#luaL_buffinit">luaL_buffinit</A>(L,&amp;b);
  if (<A HREF="lapi.c.html#lua_dump">lua_dump</A>(L, <A HREF="lstrlib.c.html#writer">writer</A>, &amp;b, strip) != 0)
    return <A HREF="lauxlib.c.html#luaL_error">luaL_error</A>(L, "unable to dump given function");
  <A HREF="lauxlib.c.html#luaL_pushresult">luaL_pushresult</A>(&amp;b);
  return 1;
}



/*
** {======================================================
** PATTERN MATCHING
** =======================================================
*/


#define <A NAME="CAP_UNFINISHED"><SPAN CLASS="definition">CAP_UNFINISHED</SPAN></A>  (-1)
#define <A NAME="CAP_POSITION"><SPAN CLASS="definition">CAP_POSITION</SPAN></A>    (-2)


typedef struct <A NAME="MatchState"><SPAN CLASS="definition">MatchState</SPAN></A> {
  const char *src_init;  /* init of source string */
  const char *src_end;  /* end ('\0') of source string */
  const char *p_end;  /* end ('\0') of pattern */
  <A HREF="lstate.h.html#lua_State">lua_State</A> *L;
  size_t nrep;  /* limit to avoid non-linear complexity */
  int matchdepth;  /* control for recursive depth (to avoid C stack overflow) */
  int level;  /* total number of captures (finished or unfinished) */
  struct {
    const char *init;
    ptrdiff_t len;
  } capture[<A HREF="lstrlib.c.html#LUA_MAXCAPTURES">LUA_MAXCAPTURES</A>];
} <A HREF="lstrlib.c.html#MatchState">MatchState</A>;


/* recursive function */
static const char *<A HREF="lstrlib.c.html#match">match</A> (<A HREF="lstrlib.c.html#MatchState">MatchState</A> *ms, const char *s, const char *p);


/* maximum recursion depth for '<A HREF="lstrlib.c.html#match">match</A>' */
#if !defined(<A HREF="lstrlib.c.html#MAXCCALLS">MAXCCALLS</A>)
#define <A NAME="MAXCCALLS"><SPAN CLASS="definition">MAXCCALLS</SPAN></A>       200
#endif


/*
** parameters to control the maximum number of operators handled in
** a <A HREF="lstrlib.c.html#match">match</A> (to avoid non-linear complexity). The maximum will be:
** (subject length) * <A HREF="lstrlib.c.html#A_REPS">A_REPS</A> + <A HREF="lstrlib.c.html#B_REPS">B_REPS</A>
*/
#if !defined(<A HREF="lstrlib.c.html#A_REPS">A_REPS</A>)
#define <A NAME="A_REPS"><SPAN CLASS="definition">A_REPS</SPAN></A>          4
#define <A NAME="B_REPS"><SPAN CLASS="definition">B_REPS</SPAN></A>          100000
#endif


#define <A NAME="L_ESC"><SPAN CLASS="definition">L_ESC</SPAN></A>           '%'
#define <A NAME="SPECIALS"><SPAN CLASS="definition">SPECIALS</SPAN></A>        "^$*+?.([%-"


static int <A NAME="check_capture"><SPAN CLASS="definition">check_capture</SPAN></A> (<A HREF="lstrlib.c.html#MatchState">MatchState</A> *ms, int l) {
  l -= '1';
  if (l &lt; 0 || l &gt;= ms-&gt;level || ms-&gt;capture[l].len == <A HREF="lstrlib.c.html#CAP_UNFINISHED">CAP_UNFINISHED</A>)
    return <A HREF="lauxlib.c.html#luaL_error">luaL_error</A>(ms-&gt;L, "invalid capture index %%%d", l + 1);
  return l;
}


static int <A NAME="capture_to_close"><SPAN CLASS="definition">capture_to_close</SPAN></A> (<A HREF="lstrlib.c.html#MatchState">MatchState</A> *ms) {
  int level = ms-&gt;level;
  for (level--; level&gt;=0; level--)
    if (ms-&gt;capture[level].len == <A HREF="lstrlib.c.html#CAP_UNFINISHED">CAP_UNFINISHED</A>) return level;
  return <A HREF="lauxlib.c.html#luaL_error">luaL_error</A>(ms-&gt;L, "invalid pattern capture");
}


static const char *<A NAME="classend"><SPAN CLASS="definition">classend</SPAN></A> (<A HREF="lstrlib.c.html#MatchState">MatchState</A> *ms, const char *p) {
  switch (*p++) {
    case <A HREF="lstrlib.c.html#L_ESC">L_ESC</A>: {
      if (p == ms-&gt;p_end)
        <A HREF="lauxlib.c.html#luaL_error">luaL_error</A>(ms-&gt;L, "malformed pattern (ends with '%%')");
      return p+1;
    }
    case '[': {
      if (*p == '^') p++;
      do {  /* look for a ']' */
        if (p == ms-&gt;p_end)
          <A HREF="lauxlib.c.html#luaL_error">luaL_error</A>(ms-&gt;L, "malformed pattern (missing ']')");
        if (*(p++) == <A HREF="lstrlib.c.html#L_ESC">L_ESC</A> &amp;&amp; p &lt; ms-&gt;p_end)
          p++;  /* skip escapes (e.g. '%]') */
      } while (*p != ']');
      return p+1;
    }
    default: {
      return p;
    }
  }
}


static int <A NAME="match_class"><SPAN CLASS="definition">match_class</SPAN></A> (int c, int cl) {
  int res;
  switch (tolower(cl)) {
    case 'a' : res = isalpha(c); break;
    case 'c' : res = iscntrl(c); break;
    case 'd' : res = isdigit(c); break;
    case 'g' : res = isgraph(c); break;
    case 'l' : res = islower(c); break;
    case 'p' : res = ispunct(c); break;
    case 's' : res = isspace(c); break;
    case 'u' : res = isupper(c); break;
    case 'w' : res = isalnum(c); break;
    case 'x' : res = isxdigit(c); break;
    case 'z' : res = (c == 0); break;  /* deprecated option */
    default: return (cl == c);
  }
  return (islower(cl) ? res : !res);
}


static int <A NAME="matchbracketclass"><SPAN CLASS="definition">matchbracketclass</SPAN></A> (int c, const char *p, const char *ec) {
  int sig = 1;
  if (*(p+1) == '^') {
    sig = 0;
    p++;  /* skip the '^' */
  }
  while (++p &lt; ec) {
    if (*p == <A HREF="lstrlib.c.html#L_ESC">L_ESC</A>) {
      p++;
      if (<A HREF="lstrlib.c.html#match_class">match_class</A>(c, <A HREF="lstrlib.c.html#uchar">uchar</A>(*p)))
        return sig;
    }
    else if ((*(p+1) == '-') &amp;&amp; (p+2 &lt; ec)) {
      p+=2;
      if (<A HREF="lstrlib.c.html#uchar">uchar</A>(*(p-2)) &lt;= c &amp;&amp; c &lt;= <A HREF="lstrlib.c.html#uchar">uchar</A>(*p))
        return sig;
    }
    else if (<A HREF="lstrlib.c.html#uchar">uchar</A>(*p) == c) return sig;
  }
  return !sig;
}


static int <A NAME="singlematch"><SPAN CLASS="definition">singlematch</SPAN></A> (<A HREF="lstrlib.c.html#MatchState">MatchState</A> *ms, const char *s, const char *p,
                        const char *ep) {
  if (s &gt;= ms-&gt;src_end)
    return 0;
  else {
    int c = <A HREF="lstrlib.c.html#uchar">uchar</A>(*s);
    switch (*p) {
      case '.': return 1;  /* matches any char */
      case <A HREF="lstrlib.c.html#L_ESC">L_ESC</A>: return <A HREF="lstrlib.c.html#match_class">match_class</A>(c, <A HREF="lstrlib.c.html#uchar">uchar</A>(*(p+1)));
      case '[': return <A HREF="lstrlib.c.html#matchbracketclass">matchbracketclass</A>(c, p, ep-1);
      default:  return (<A HREF="lstrlib.c.html#uchar">uchar</A>(*p) == c);
    }
  }
}


static const char *<A NAME="matchbalance"><SPAN CLASS="definition">matchbalance</SPAN></A> (<A HREF="lstrlib.c.html#MatchState">MatchState</A> *ms, const char *s,
                                   const char *p) {
  if (p &gt;= ms-&gt;p_end - 1)
    <A HREF="lauxlib.c.html#luaL_error">luaL_error</A>(ms-&gt;L, "malformed pattern (missing arguments to '%%b')");
  if (*s != *p) return NULL;
  else {
    int b = *p;
    int e = *(p+1);
    int cont = 1;
    while (++s &lt; ms-&gt;src_end) {
      if (*s == e) {
        if (--cont == 0) return s+1;
      }
      else if (*s == b) cont++;
    }
  }
  return NULL;  /* string ends out of balance */
}


static const char *<A NAME="max_expand"><SPAN CLASS="definition">max_expand</SPAN></A> (<A HREF="lstrlib.c.html#MatchState">MatchState</A> *ms, const char *s,
                                 const char *p, const char *ep) {
  ptrdiff_t i = 0;  /* counts maximum expand for item */
  while (<A HREF="lstrlib.c.html#singlematch">singlematch</A>(ms, s + i, p, ep))
    i++;
  /* keeps trying to <A HREF="lstrlib.c.html#match">match</A> with the maximum repetitions */
  while (i&gt;=0) {
    const char *res = <A HREF="lstrlib.c.html#match">match</A>(ms, (s+i), ep+1);
    if (res) return res;
    i--;  /* else didn't <A HREF="lstrlib.c.html#match">match</A>; reduce 1 repetition to try again */
  }
  return NULL;
}


static const char *<A NAME="min_expand"><SPAN CLASS="definition">min_expand</SPAN></A> (<A HREF="lstrlib.c.html#MatchState">MatchState</A> *ms, const char *s,
                                 const char *p, const char *ep) {
  for (;;) {
    const char *res = <A HREF="lstrlib.c.html#match">match</A>(ms, s, ep+1);
    if (res != NULL)
      return res;
    else if (<A HREF="lstrlib.c.html#singlematch">singlematch</A>(ms, s, p, ep))
      s++;  /* try with one more repetition */
    else return NULL;
  }
}


static const char *<A NAME="start_capture"><SPAN CLASS="definition">start_capture</SPAN></A> (<A HREF="lstrlib.c.html#MatchState">MatchState</A> *ms, const char *s,
                                    const char *p, int what) {
  const char *res;
  int level = ms-&gt;level;
  if (level &gt;= <A HREF="lstrlib.c.html#LUA_MAXCAPTURES">LUA_MAXCAPTURES</A>) <A HREF="lauxlib.c.html#luaL_error">luaL_error</A>(ms-&gt;L, "too many captures");
  ms-&gt;capture[level].init = s;
  ms-&gt;capture[level].len = what;
  ms-&gt;level = level+1;
  if ((res=<A HREF="lstrlib.c.html#match">match</A>(ms, s, p)) == NULL)  /* <A HREF="lstrlib.c.html#match">match</A> failed? */
    ms-&gt;level--;  /* undo capture */
  return res;
}


static const char *<A NAME="end_capture"><SPAN CLASS="definition">end_capture</SPAN></A> (<A HREF="lstrlib.c.html#MatchState">MatchState</A> *ms, const char *s,
                                  const char *p) {
  int l = <A HREF="lstrlib.c.html#capture_to_close">capture_to_close</A>(ms);
  const char *res;
  ms-&gt;capture[l].len = s - ms-&gt;capture[l].init;  /* close capture */
  if ((res = <A HREF="lstrlib.c.html#match">match</A>(ms, s, p)) == NULL)  /* <A HREF="lstrlib.c.html#match">match</A> failed? */
    ms-&gt;capture[l].len = <A HREF="lstrlib.c.html#CAP_UNFINISHED">CAP_UNFINISHED</A>;  /* undo capture */
  return res;
}


static const char *<A NAME="match_capture"><SPAN CLASS="definition">match_capture</SPAN></A> (<A HREF="lstrlib.c.html#MatchState">MatchState</A> *ms, const char *s, int l) {
  size_t len;
  l = <A HREF="lstrlib.c.html#check_capture">check_capture</A>(ms, l);
  len = ms-&gt;capture[l].len;
  if ((size_t)(ms-&gt;src_end-s) &gt;= len &amp;&amp;
      memcmp(ms-&gt;capture[l].init, s, len) == 0)
    return s+len;
  else return NULL;
}


static const char *<A NAME="match"><SPAN CLASS="definition">match</SPAN></A> (<A HREF="lstrlib.c.html#MatchState">MatchState</A> *ms, const char *s, const char *p) {
  if (ms-&gt;matchdepth-- == 0)
    <A HREF="lauxlib.c.html#luaL_error">luaL_error</A>(ms-&gt;L, "pattern too complex");
  init: /* using goto's to optimize tail recursion */
  if (p != ms-&gt;p_end) {  /* end of pattern? */
    switch (*p) {
      case '(': {  /* start capture */
        if (*(p + 1) == ')')  /* position capture? */
          s = <A HREF="lstrlib.c.html#start_capture">start_capture</A>(ms, s, p + 2, <A HREF="lstrlib.c.html#CAP_POSITION">CAP_POSITION</A>);
        else
          s = <A HREF="lstrlib.c.html#start_capture">start_capture</A>(ms, s, p + 1, <A HREF="lstrlib.c.html#CAP_UNFINISHED">CAP_UNFINISHED</A>);
        break;
      }
      case ')': {  /* end capture */
        s = <A HREF="lstrlib.c.html#end_capture">end_capture</A>(ms, s, p + 1);
        break;
      }
      case '$': {
        if ((p + 1) != ms-&gt;p_end)  /* is the '$' the last char in pattern? */
          goto dflt;  /* no; go to default */
        s = (s == ms-&gt;src_end) ? s : NULL;  /* check end of string */
        break;
      }
      case <A HREF="lstrlib.c.html#L_ESC">L_ESC</A>: {  /* escaped sequences not in the format class[*+?-]? */
        switch (*(p + 1)) {
          case 'b': {  /* balanced string? */
            s = <A HREF="lstrlib.c.html#matchbalance">matchbalance</A>(ms, s, p + 2);
            if (s != NULL) {
              p += 4; goto init;  /* return <A HREF="lstrlib.c.html#match">match</A>(ms, s, p + 4); */
            }  /* else fail (s == NULL) */
            break;
          }
          case 'f': {  /* frontier? */
            const char *ep; char previous;
            p += 2;
            if (*p != '[')
              <A HREF="lauxlib.c.html#luaL_error">luaL_error</A>(ms-&gt;L, "missing '[' after '%%f' in pattern");
            ep = <A HREF="lstrlib.c.html#classend">classend</A>(ms, p);  /* points to what is next */
            previous = (s == ms-&gt;src_init) ? '\0' : *(s - 1);
            if (!<A HREF="lstrlib.c.html#matchbracketclass">matchbracketclass</A>(<A HREF="lstrlib.c.html#uchar">uchar</A>(previous), p, ep - 1) &amp;&amp;
               <A HREF="lstrlib.c.html#matchbracketclass">matchbracketclass</A>(<A HREF="lstrlib.c.html#uchar">uchar</A>(*s), p, ep - 1)) {
              p = ep; goto init;  /* return <A HREF="lstrlib.c.html#match">match</A>(ms, s, ep); */
            }
            s = NULL;  /* <A HREF="lstrlib.c.html#match">match</A> failed */
            break;
          }
          case '0': case '1': case '2': case '3':
          case '4': case '5': case '6': case '7':
          case '8': case '9': {  /* capture results (%0-%9)? */
            s = <A HREF="lstrlib.c.html#match_capture">match_capture</A>(ms, s, <A HREF="lstrlib.c.html#uchar">uchar</A>(*(p + 1)));
            if (s != NULL) {
              p += 2; goto init;  /* return <A HREF="lstrlib.c.html#match">match</A>(ms, s, p + 2) */
            }
            break;
          }
          default: goto dflt;
        }
        break;
      }
      default: dflt: {  /* pattern class plus optional suffix */
        const char *ep = <A HREF="lstrlib.c.html#classend">classend</A>(ms, p);  /* points to optional suffix */
        /* does not <A HREF="lstrlib.c.html#match">match</A> at least once? */
        if (!<A HREF="lstrlib.c.html#singlematch">singlematch</A>(ms, s, p, ep)) {
          if (*ep == '*' || *ep == '?' || *ep == '-') {  /* accept empty? */
            p = ep + 1; goto init;  /* return <A HREF="lstrlib.c.html#match">match</A>(ms, s, ep + 1); */
          }
          else  /* '+' or no suffix */
            s = NULL;  /* fail */
        }
        else {  /* matched once */
          if (ms-&gt;nrep-- == 0)
            <A HREF="lauxlib.c.html#luaL_error">luaL_error</A>(ms-&gt;L, "pattern too complex");
          switch (*ep) {  /* handle optional suffix */
            case '?': {  /* optional */
              const char *res;
              if ((res = <A HREF="lstrlib.c.html#match">match</A>(ms, s + 1, ep + 1)) != NULL)
                s = res;
              else {
                p = ep + 1; goto init;  /* else return <A HREF="lstrlib.c.html#match">match</A>(ms, s, ep + 1); */
              }
              break;
            }
            case '+':  /* 1 or more repetitions */
              s++;  /* 1 <A HREF="lstrlib.c.html#match">match</A> already done */
              /* FALLTHROUGH */
            case '*':  /* 0 or more repetitions */
              s = <A HREF="lstrlib.c.html#max_expand">max_expand</A>(ms, s, p, ep);
              break;
            case '-':  /* 0 or more repetitions (minimum) */
              s = <A HREF="lstrlib.c.html#min_expand">min_expand</A>(ms, s, p, ep);
              break;
            default:  /* no suffix */
              s++; p = ep; goto init;  /* return <A HREF="lstrlib.c.html#match">match</A>(ms, s + 1, ep); */
          }
        }
        break;
      }
    }
  }
  ms-&gt;matchdepth++;
  return s;
}



static const char *<A NAME="lmemfind"><SPAN CLASS="definition">lmemfind</SPAN></A> (const char *s1, size_t l1,
                               const char *s2, size_t l2) {
  if (l2 == 0) return s1;  /* empty strings are everywhere */
  else if (l2 &gt; l1) return NULL;  /* avoids a negative 'l1' */
  else {
    const char *init;  /* to search for a '*s2' inside 's1' */
    l2--;  /* 1st char will be checked by 'memchr' */
    l1 = l1-l2;  /* 's2' cannot be found after that */
    while (l1 &gt; 0 &amp;&amp; (init = (const char *)memchr(s1, *s2, l1)) != NULL) {
      init++;   /* 1st char is already checked */
      if (memcmp(init, s2+1, l2) == 0)
        return init-1;
      else {  /* correct 'l1' and 's1' to try again */
        l1 -= init-s1;
        s1 = init;
      }
    }
    return NULL;  /* not found */
  }
}


static void <A NAME="push_onecapture"><SPAN CLASS="definition">push_onecapture</SPAN></A> (<A HREF="lstrlib.c.html#MatchState">MatchState</A> *ms, int i, const char *s,
                                                    const char *e) {
  if (i &gt;= ms-&gt;level) {
    if (i == 0)  /* ms-&gt;level == 0, too */
      <A HREF="lapi.c.html#lua_pushlstring">lua_pushlstring</A>(ms-&gt;L, s, e - s);  /* add whole <A HREF="lstrlib.c.html#match">match</A> */
    else
      <A HREF="lauxlib.c.html#luaL_error">luaL_error</A>(ms-&gt;L, "invalid capture index %%%d", i + 1);
  }
  else {
    ptrdiff_t l = ms-&gt;capture[i].len;
    if (l == <A HREF="lstrlib.c.html#CAP_UNFINISHED">CAP_UNFINISHED</A>) <A HREF="lauxlib.c.html#luaL_error">luaL_error</A>(ms-&gt;L, "unfinished capture");
    if (l == <A HREF="lstrlib.c.html#CAP_POSITION">CAP_POSITION</A>)
      <A HREF="lapi.c.html#lua_pushinteger">lua_pushinteger</A>(ms-&gt;L, (ms-&gt;capture[i].init - ms-&gt;src_init) + 1);
    else
      <A HREF="lapi.c.html#lua_pushlstring">lua_pushlstring</A>(ms-&gt;L, ms-&gt;capture[i].init, l);
  }
}


static int <A NAME="push_captures"><SPAN CLASS="definition">push_captures</SPAN></A> (<A HREF="lstrlib.c.html#MatchState">MatchState</A> *ms, const char *s, const char *e) {
  int i;
  int nlevels = (ms-&gt;level == 0 &amp;&amp; s) ? 1 : ms-&gt;level;
  <A HREF="lauxlib.c.html#luaL_checkstack">luaL_checkstack</A>(ms-&gt;L, nlevels, "too many captures");
  for (i = 0; i &lt; nlevels; i++)
    <A HREF="lstrlib.c.html#push_onecapture">push_onecapture</A>(ms, i, s, e);
  return nlevels;  /* number of strings pushed */
}


/* check whether pattern has no special characters */
static int <A NAME="nospecials"><SPAN CLASS="definition">nospecials</SPAN></A> (const char *p, size_t l) {
  size_t upto = 0;
  do {
    if (strpbrk(p + upto, <A HREF="lstrlib.c.html#SPECIALS">SPECIALS</A>))
      return 0;  /* pattern has a special character */
    upto += strlen(p + upto) + 1;  /* may have more after \0 */
  } while (upto &lt;= l);
  return 1;  /* no special chars found */
}


static void <A NAME="prepstate"><SPAN CLASS="definition">prepstate</SPAN></A> (<A HREF="lstrlib.c.html#MatchState">MatchState</A> *ms, <A HREF="lstate.h.html#lua_State">lua_State</A> *L,
                       const char *s, size_t ls, const char *p, size_t lp) {
  ms-&gt;L = L;
  ms-&gt;matchdepth = <A HREF="lstrlib.c.html#MAXCCALLS">MAXCCALLS</A>;
  ms-&gt;src_init = s;
  ms-&gt;src_end = s + ls;
  ms-&gt;p_end = p + lp;
  if (ls &lt; (<A HREF="lstrlib.c.html#MAX_SIZET">MAX_SIZET</A> - <A HREF="lstrlib.c.html#B_REPS">B_REPS</A>) / <A HREF="lstrlib.c.html#A_REPS">A_REPS</A>)
    ms-&gt;nrep = <A HREF="lstrlib.c.html#A_REPS">A_REPS</A> * ls + <A HREF="lstrlib.c.html#B_REPS">B_REPS</A>;
  else  /* overflow (very long subject) */
    ms-&gt;nrep = <A HREF="lstrlib.c.html#MAX_SIZET">MAX_SIZET</A>;  /* no limit */
}


static void <A NAME="reprepstate"><SPAN CLASS="definition">reprepstate</SPAN></A> (<A HREF="lstrlib.c.html#MatchState">MatchState</A> *ms) {
  ms-&gt;level = 0;
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(ms-&gt;matchdepth == <A HREF="lstrlib.c.html#MAXCCALLS">MAXCCALLS</A>);
}


static int <A NAME="str_find_aux"><SPAN CLASS="definition">str_find_aux</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L, int find) {
  size_t ls, lp;
  const char *s = <A HREF="lauxlib.c.html#luaL_checklstring">luaL_checklstring</A>(L, 1, &amp;ls);
  const char *p = <A HREF="lauxlib.c.html#luaL_checklstring">luaL_checklstring</A>(L, 2, &amp;lp);
  <A HREF="lua.h.html#lua_Integer">lua_Integer</A> init = <A HREF="lstrlib.c.html#posrelat">posrelat</A>(<A HREF="lauxlib.c.html#luaL_optinteger">luaL_optinteger</A>(L, 3, 1), ls);
  if (init &lt; 1) init = 1;
  else if (init &gt; (<A HREF="lua.h.html#lua_Integer">lua_Integer</A>)ls + 1) {  /* start after string's end? */
    <A HREF="lapi.c.html#lua_pushnil">lua_pushnil</A>(L);  /* cannot find anything */
    return 1;
  }
  /* explicit request or no special characters? */
  if (find &amp;&amp; (<A HREF="lapi.c.html#lua_toboolean">lua_toboolean</A>(L, 4) || <A HREF="lstrlib.c.html#nospecials">nospecials</A>(p, lp))) {
    /* do a plain search */
    const char *s2 = <A HREF="lstrlib.c.html#lmemfind">lmemfind</A>(s + init - 1, ls - (size_t)init + 1, p, lp);
    if (s2) {
      <A HREF="lapi.c.html#lua_pushinteger">lua_pushinteger</A>(L, (s2 - s) + 1);
      <A HREF="lapi.c.html#lua_pushinteger">lua_pushinteger</A>(L, (s2 - s) + lp);
      return 2;
    }
  }
  else {
    <A HREF="lstrlib.c.html#MatchState">MatchState</A> ms;
    const char *s1 = s + init - 1;
    int anchor = (*p == '^');
    if (anchor) {
      p++; lp--;  /* skip anchor character */
    }
    <A HREF="lstrlib.c.html#prepstate">prepstate</A>(&amp;ms, L, s, ls, p, lp);
    do {
      const char *res;
      <A HREF="lstrlib.c.html#reprepstate">reprepstate</A>(&amp;ms);
      if ((res=<A HREF="lstrlib.c.html#match">match</A>(&amp;ms, s1, p)) != NULL) {
        if (find) {
          <A HREF="lapi.c.html#lua_pushinteger">lua_pushinteger</A>(L, (s1 - s) + 1);  /* start */
          <A HREF="lapi.c.html#lua_pushinteger">lua_pushinteger</A>(L, res - s);   /* end */
          return <A HREF="lstrlib.c.html#push_captures">push_captures</A>(&amp;ms, NULL, 0) + 2;
        }
        else
          return <A HREF="lstrlib.c.html#push_captures">push_captures</A>(&amp;ms, s1, res);
      }
    } while (s1++ &lt; ms.src_end &amp;&amp; !anchor);
  }
  <A HREF="lapi.c.html#lua_pushnil">lua_pushnil</A>(L);  /* not found */
  return 1;
}


static int <A NAME="str_find"><SPAN CLASS="definition">str_find</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  return <A HREF="lstrlib.c.html#str_find_aux">str_find_aux</A>(L, 1);
}


static int <A NAME="str_match"><SPAN CLASS="definition">str_match</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  return <A HREF="lstrlib.c.html#str_find_aux">str_find_aux</A>(L, 0);
}


/* state for '<A HREF="lstrlib.c.html#gmatch">gmatch</A>' */
typedef struct <A NAME="GMatchState"><SPAN CLASS="definition">GMatchState</SPAN></A> {
  const char *src;  /* current position */
  const char *p;  /* pattern */
  <A HREF="lstrlib.c.html#MatchState">MatchState</A> ms;  /* <A HREF="lstrlib.c.html#match">match</A> state */
} <A HREF="lstrlib.c.html#GMatchState">GMatchState</A>;


static int <A NAME="gmatch_aux"><SPAN CLASS="definition">gmatch_aux</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  <A HREF="lstrlib.c.html#GMatchState">GMatchState</A> *gm = (<A HREF="lstrlib.c.html#GMatchState">GMatchState</A> *)<A HREF="lapi.c.html#lua_touserdata">lua_touserdata</A>(L, <A HREF="lua.h.html#lua_upvalueindex">lua_upvalueindex</A>(3));
  const char *src;
  for (src = gm-&gt;src; src &lt;= gm-&gt;ms.src_end; src++) {
    const char *e;
    <A HREF="lstrlib.c.html#reprepstate">reprepstate</A>(&amp;gm-&gt;ms);
    if ((e = <A HREF="lstrlib.c.html#match">match</A>(&amp;gm-&gt;ms, src, gm-&gt;p)) != NULL) {
      if (e == src)  /* empty <A HREF="lstrlib.c.html#match">match</A>? */
        gm-&gt;src =src + 1;  /* go at least one position */
      else
        gm-&gt;src = e;
      return <A HREF="lstrlib.c.html#push_captures">push_captures</A>(&amp;gm-&gt;ms, src, e);
    }
  }
  return 0;  /* not found */
}


static int <A NAME="gmatch"><SPAN CLASS="definition">gmatch</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  size_t ls, lp;
  const char *s = <A HREF="lauxlib.c.html#luaL_checklstring">luaL_checklstring</A>(L, 1, &amp;ls);
  const char *p = <A HREF="lauxlib.c.html#luaL_checklstring">luaL_checklstring</A>(L, 2, &amp;lp);
  <A HREF="lstrlib.c.html#GMatchState">GMatchState</A> *gm;
  <A HREF="lapi.c.html#lua_settop">lua_settop</A>(L, 2);  /* keep them on closure to avoid being collected */
  gm = (<A HREF="lstrlib.c.html#GMatchState">GMatchState</A> *)<A HREF="lapi.c.html#lua_newuserdata">lua_newuserdata</A>(L, sizeof(<A HREF="lstrlib.c.html#GMatchState">GMatchState</A>));
  <A HREF="lstrlib.c.html#prepstate">prepstate</A>(&amp;gm-&gt;ms, L, s, ls, p, lp);
  gm-&gt;src = s; gm-&gt;p = p;
  <A HREF="lapi.c.html#lua_pushcclosure">lua_pushcclosure</A>(L, <A HREF="lstrlib.c.html#gmatch_aux">gmatch_aux</A>, 3);
  return 1;
}


static void <A NAME="add_s"><SPAN CLASS="definition">add_s</SPAN></A> (<A HREF="lstrlib.c.html#MatchState">MatchState</A> *ms, <A HREF="lauxlib.h.html#luaL_Buffer">luaL_Buffer</A> *b, const char *s,
                                                   const char *e) {
  size_t l, i;
  <A HREF="lstate.h.html#lua_State">lua_State</A> *L = ms-&gt;L;
  const char *news = <A HREF="lapi.c.html#lua_tolstring">lua_tolstring</A>(L, 3, &amp;l);
  for (i = 0; i &lt; l; i++) {
    if (news[i] != <A HREF="lstrlib.c.html#L_ESC">L_ESC</A>)
      <A HREF="lauxlib.h.html#luaL_addchar">luaL_addchar</A>(b, news[i]);
    else {
      i++;  /* skip ESC */
      if (!isdigit(<A HREF="lstrlib.c.html#uchar">uchar</A>(news[i]))) {
        if (news[i] != <A HREF="lstrlib.c.html#L_ESC">L_ESC</A>)
          <A HREF="lauxlib.c.html#luaL_error">luaL_error</A>(L, "invalid use of '%c' in replacement string", <A HREF="lstrlib.c.html#L_ESC">L_ESC</A>);
        <A HREF="lauxlib.h.html#luaL_addchar">luaL_addchar</A>(b, news[i]);
      }
      else if (news[i] == '0')
          <A HREF="lauxlib.c.html#luaL_addlstring">luaL_addlstring</A>(b, s, e - s);
      else {
        <A HREF="lstrlib.c.html#push_onecapture">push_onecapture</A>(ms, news[i] - '1', s, e);
        <A HREF="lauxlib.c.html#luaL_tolstring">luaL_tolstring</A>(L, -1, NULL);  /* if number, convert it to string */
        <A HREF="lua.h.html#lua_remove">lua_remove</A>(L, -2);  /* remove original value */
        <A HREF="lauxlib.c.html#luaL_addvalue">luaL_addvalue</A>(b);  /* add capture to accumulated result */
      }
    }
  }
}


static void <A NAME="add_value"><SPAN CLASS="definition">add_value</SPAN></A> (<A HREF="lstrlib.c.html#MatchState">MatchState</A> *ms, <A HREF="lauxlib.h.html#luaL_Buffer">luaL_Buffer</A> *b, const char *s,
                                       const char *e, int tr) {
  <A HREF="lstate.h.html#lua_State">lua_State</A> *L = ms-&gt;L;
  switch (tr) {
    case <A HREF="lua.h.html#LUA_TFUNCTION">LUA_TFUNCTION</A>: {
      int n;
      <A HREF="lapi.c.html#lua_pushvalue">lua_pushvalue</A>(L, 3);
      n = <A HREF="lstrlib.c.html#push_captures">push_captures</A>(ms, s, e);
      <A HREF="lua.h.html#lua_call">lua_call</A>(L, n, 1);
      break;
    }
    case <A HREF="lua.h.html#LUA_TTABLE">LUA_TTABLE</A>: {
      <A HREF="lstrlib.c.html#push_onecapture">push_onecapture</A>(ms, 0, s, e);
      <A HREF="lapi.c.html#lua_gettable">lua_gettable</A>(L, 3);
      break;
    }
    default: {  /* <A HREF="lua.h.html#LUA_TNUMBER">LUA_TNUMBER</A> or <A HREF="lua.h.html#LUA_TSTRING">LUA_TSTRING</A> */
      <A HREF="lstrlib.c.html#add_s">add_s</A>(ms, b, s, e);
      return;
    }
  }
  if (!<A HREF="lapi.c.html#lua_toboolean">lua_toboolean</A>(L, -1)) {  /* nil or false? */
    <A HREF="lua.h.html#lua_pop">lua_pop</A>(L, 1);
    <A HREF="lapi.c.html#lua_pushlstring">lua_pushlstring</A>(L, s, e - s);  /* keep original text */
  }
  else if (!<A HREF="lapi.c.html#lua_isstring">lua_isstring</A>(L, -1))
    <A HREF="lauxlib.c.html#luaL_error">luaL_error</A>(L, "invalid replacement value (a %s)", <A HREF="lauxlib.h.html#luaL_typename">luaL_typename</A>(L, -1));
  <A HREF="lauxlib.c.html#luaL_addvalue">luaL_addvalue</A>(b);  /* add result to accumulator */
}


static int <A NAME="str_gsub"><SPAN CLASS="definition">str_gsub</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  size_t srcl, lp;
  const char *src = <A HREF="lauxlib.c.html#luaL_checklstring">luaL_checklstring</A>(L, 1, &amp;srcl);
  const char *p = <A HREF="lauxlib.c.html#luaL_checklstring">luaL_checklstring</A>(L, 2, &amp;lp);
  int tr = <A HREF="lapi.c.html#lua_type">lua_type</A>(L, 3);
  <A HREF="lua.h.html#lua_Integer">lua_Integer</A> max_s = <A HREF="lauxlib.c.html#luaL_optinteger">luaL_optinteger</A>(L, 4, srcl + 1);
  int anchor = (*p == '^');
  <A HREF="lua.h.html#lua_Integer">lua_Integer</A> n = 0;
  <A HREF="lstrlib.c.html#MatchState">MatchState</A> ms;
  <A HREF="lauxlib.h.html#luaL_Buffer">luaL_Buffer</A> b;
  <A HREF="lauxlib.h.html#luaL_argcheck">luaL_argcheck</A>(L, tr == <A HREF="lua.h.html#LUA_TNUMBER">LUA_TNUMBER</A> || tr == <A HREF="lua.h.html#LUA_TSTRING">LUA_TSTRING</A> ||
                   tr == <A HREF="lua.h.html#LUA_TFUNCTION">LUA_TFUNCTION</A> || tr == <A HREF="lua.h.html#LUA_TTABLE">LUA_TTABLE</A>, 3,
                      "string/function/table expected");
  <A HREF="lauxlib.c.html#luaL_buffinit">luaL_buffinit</A>(L, &amp;b);
  if (anchor) {
    p++; lp--;  /* skip anchor character */
  }
  <A HREF="lstrlib.c.html#prepstate">prepstate</A>(&amp;ms, L, src, srcl, p, lp);
  while (n &lt; max_s) {
    const char *e;
    <A HREF="lstrlib.c.html#reprepstate">reprepstate</A>(&amp;ms);
    if ((e = <A HREF="lstrlib.c.html#match">match</A>(&amp;ms, src, p)) != NULL) {
      n++;
      <A HREF="lstrlib.c.html#add_value">add_value</A>(&amp;ms, &amp;b, src, e, tr);
    }
    if (e &amp;&amp; e&gt;src) /* non empty <A HREF="lstrlib.c.html#match">match</A>? */
      src = e;  /* skip it */
    else if (src &lt; ms.src_end)
      <A HREF="lauxlib.h.html#luaL_addchar">luaL_addchar</A>(&amp;b, *src++);
    else break;
    if (anchor) break;
  }
  <A HREF="lauxlib.c.html#luaL_addlstring">luaL_addlstring</A>(&amp;b, src, ms.src_end-src);
  <A HREF="lauxlib.c.html#luaL_pushresult">luaL_pushresult</A>(&amp;b);
  <A HREF="lapi.c.html#lua_pushinteger">lua_pushinteger</A>(L, n);  /* number of substitutions */
  return 2;
}

/* }====================================================== */



/*
** {======================================================
** STRING FORMAT
** =======================================================
*/

#if !defined(<A HREF="lstrlib.c.html#lua_number2strx">lua_number2strx</A>)   /* { */

/*
** Hexadecimal floating-point formatter
*/

#include &lt;locale.h&gt;
#include &lt;math.h&gt;

#define <A NAME="SIZELENMOD"><SPAN CLASS="definition">SIZELENMOD</SPAN></A>      (sizeof(<A HREF="luaconf.h.html#LUA_NUMBER_FRMLEN">LUA_NUMBER_FRMLEN</A>)/sizeof(char))


/*
** Number of bits that goes into the first <A HREF="lstrlib.c.html#digit">digit</A>. It can be any value
** between 1 and 4; the following definition tries to align the number
** to nibble boundaries by making what is left after that first <A HREF="lstrlib.c.html#digit">digit</A> a
** multiple of 4.
*/
#define <A NAME="L_NBFD"><SPAN CLASS="definition">L_NBFD</SPAN></A>          ((<A HREF="luaconf.h.html#l_mathlim">l_mathlim</A>(MANT_DIG) - 1)%4 + 1)


/*
** Add integer part of 'x' to buffer and return new 'x'
*/
static <A HREF="lua.h.html#lua_Number">lua_Number</A> <A NAME="adddigit"><SPAN CLASS="definition">adddigit</SPAN></A> (char *buff, int n, <A HREF="lua.h.html#lua_Number">lua_Number</A> x) {
  <A HREF="lua.h.html#lua_Number">lua_Number</A> dd = <A HREF="luaconf.h.html#l_mathop">l_mathop</A>(floor)(x);  /* get integer part from 'x' */
  int d = (int)dd;
  buff[n] = (d &lt; 10 ? d + '0' : d - 10 + 'a');  /* add to buffer */
  return x - dd;  /* return what is left */
}


static int <A NAME="num2straux"><SPAN CLASS="definition">num2straux</SPAN></A> (char *buff, int sz, <A HREF="lua.h.html#lua_Number">lua_Number</A> x) {
  if (x != x || x == HUGE_VAL || x == -HUGE_VAL)  /* inf or NaN? */
    return <A HREF="luaconf.h.html#l_sprintf">l_sprintf</A>(buff, sz, <A HREF="luaconf.h.html#LUA_NUMBER_FMT">LUA_NUMBER_FMT</A>, x);  /* equal to '%g' */
  else if (x == 0) {  /* can be -0... */
    /* create "0" or "-0" followed by exponent */
    return <A HREF="luaconf.h.html#l_sprintf">l_sprintf</A>(buff, sz, <A HREF="luaconf.h.html#LUA_NUMBER_FMT">LUA_NUMBER_FMT</A> "x0p+0", x);
  }
  else {
    int e;
    <A HREF="lua.h.html#lua_Number">lua_Number</A> m = <A HREF="luaconf.h.html#l_mathop">l_mathop</A>(frexp)(x, &amp;e);  /* 'x' fraction and exponent */
    int n = 0;  /* character count */
    if (m &lt; 0) {  /* is number negative? */
      buff[n++] = '-';  /* add signal */
      m = -m;  /* make it positive */
    }
    buff[n++] = '0'; buff[n++] = 'x';  /* add "0x" */
    m = <A HREF="lstrlib.c.html#adddigit">adddigit</A>(buff, n++, m * (1 &lt;&lt; <A HREF="lstrlib.c.html#L_NBFD">L_NBFD</A>));  /* add first <A HREF="lstrlib.c.html#digit">digit</A> */
    e -= <A HREF="lstrlib.c.html#L_NBFD">L_NBFD</A>;  /* this <A HREF="lstrlib.c.html#digit">digit</A> goes before the radix point */
    if (m &gt; 0) {  /* more digits? */
      buff[n++] = <A HREF="luaconf.h.html#lua_getlocaledecpoint">lua_getlocaledecpoint</A>();  /* add radix point */
      do {  /* add as many digits as needed */
        m = <A HREF="lstrlib.c.html#adddigit">adddigit</A>(buff, n++, m * 16);
      } while (m &gt; 0);
    }
    n += <A HREF="luaconf.h.html#l_sprintf">l_sprintf</A>(buff + n, sz - n, "p%+d", e);  /* add exponent */
    <A HREF="llimits.h.html#lua_assert">lua_assert</A>(n &lt; sz);
    return n;
  }
}


static int <A NAME="lua_number2strx"><SPAN CLASS="definition">lua_number2strx</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L, char *buff, int sz,
                            const char *fmt, <A HREF="lua.h.html#lua_Number">lua_Number</A> x) {
  int n = <A HREF="lstrlib.c.html#num2straux">num2straux</A>(buff, sz, x);
  if (fmt[<A HREF="lstrlib.c.html#SIZELENMOD">SIZELENMOD</A>] == 'A') {
    int i;
    for (i = 0; i &lt; n; i++)
      buff[i] = toupper(<A HREF="lstrlib.c.html#uchar">uchar</A>(buff[i]));
  }
  else if (fmt[<A HREF="lstrlib.c.html#SIZELENMOD">SIZELENMOD</A>] != 'a')
    <A HREF="lauxlib.c.html#luaL_error">luaL_error</A>(L, "modifiers for format '%%a'/'%%A' not implemented");
  return n;
}

#endif                          /* } */


/*
** Maximum size of each formatted item. This maximum size is produced
** by format('%.99f', -maxfloat), and is equal to 99 + 3 ('-', '.',
** and '\0') + number of decimal digits to represent maxfloat (which
** is maximum exponent + 1). (99+3+1 then rounded to 120 for "extra
** expenses", such as locale-dependent stuff)
*/
#define <A NAME="MAX_ITEM"><SPAN CLASS="definition">MAX_ITEM</SPAN></A>        (120 + <A HREF="luaconf.h.html#l_mathlim">l_mathlim</A>(MAX_10_EXP))


/* valid flags in a format specification */
#define <A NAME="FLAGS"><SPAN CLASS="definition">FLAGS</SPAN></A>   "-+ #0"

/*
** maximum size of each format specification (such as "%-099.99d")
*/
#define <A NAME="MAX_FORMAT"><SPAN CLASS="definition">MAX_FORMAT</SPAN></A>      32


static void <A NAME="addquoted"><SPAN CLASS="definition">addquoted</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L, <A HREF="lauxlib.h.html#luaL_Buffer">luaL_Buffer</A> *b, int arg) {
  size_t l;
  const char *s = <A HREF="lauxlib.c.html#luaL_checklstring">luaL_checklstring</A>(L, arg, &amp;l);
  <A HREF="lauxlib.h.html#luaL_addchar">luaL_addchar</A>(b, '"');
  while (l--) {
    if (*s == '"' || *s == '\\' || *s == '\n') {
      <A HREF="lauxlib.h.html#luaL_addchar">luaL_addchar</A>(b, '\\');
      <A HREF="lauxlib.h.html#luaL_addchar">luaL_addchar</A>(b, *s);
    }
    else if (*s == '\0' || iscntrl(<A HREF="lstrlib.c.html#uchar">uchar</A>(*s))) {
      char buff[10];
      if (!isdigit(<A HREF="lstrlib.c.html#uchar">uchar</A>(*(s+1))))
        <A HREF="luaconf.h.html#l_sprintf">l_sprintf</A>(buff, sizeof(buff), "\\%d", (int)<A HREF="lstrlib.c.html#uchar">uchar</A>(*s));
      else
        <A HREF="luaconf.h.html#l_sprintf">l_sprintf</A>(buff, sizeof(buff), "\\%03d", (int)<A HREF="lstrlib.c.html#uchar">uchar</A>(*s));
      <A HREF="lauxlib.c.html#luaL_addstring">luaL_addstring</A>(b, buff);
    }
    else
      <A HREF="lauxlib.h.html#luaL_addchar">luaL_addchar</A>(b, *s);
    s++;
  }
  <A HREF="lauxlib.h.html#luaL_addchar">luaL_addchar</A>(b, '"');
}

static const char *<A NAME="scanformat"><SPAN CLASS="definition">scanformat</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L, const char *strfrmt, char *form) {
  const char *p = strfrmt;
  while (*p != '\0' &amp;&amp; strchr(<A HREF="lstrlib.c.html#FLAGS">FLAGS</A>, *p) != NULL) p++;  /* skip flags */
  if ((size_t)(p - strfrmt) &gt;= sizeof(<A HREF="lstrlib.c.html#FLAGS">FLAGS</A>)/sizeof(char))
    <A HREF="lauxlib.c.html#luaL_error">luaL_error</A>(L, "invalid format (repeated flags)");
  if (isdigit(<A HREF="lstrlib.c.html#uchar">uchar</A>(*p))) p++;  /* skip width */
  if (isdigit(<A HREF="lstrlib.c.html#uchar">uchar</A>(*p))) p++;  /* (2 digits at most) */
  if (*p == '.') {
    p++;
    if (isdigit(<A HREF="lstrlib.c.html#uchar">uchar</A>(*p))) p++;  /* skip precision */
    if (isdigit(<A HREF="lstrlib.c.html#uchar">uchar</A>(*p))) p++;  /* (2 digits at most) */
  }
  if (isdigit(<A HREF="lstrlib.c.html#uchar">uchar</A>(*p)))
    <A HREF="lauxlib.c.html#luaL_error">luaL_error</A>(L, "invalid format (width or precision too long)");
  *(form++) = '%';
  memcpy(form, strfrmt, ((p - strfrmt) + 1) * sizeof(char));
  form += (p - strfrmt) + 1;
  *form = '\0';
  return p;
}


/*
** add length modifier into formats
*/
static void <A NAME="addlenmod"><SPAN CLASS="definition">addlenmod</SPAN></A> (char *form, const char *lenmod) {
  size_t l = strlen(form);
  size_t lm = strlen(lenmod);
  char spec = form[l - 1];
  strcpy(form + l - 1, lenmod);
  form[l + lm - 1] = spec;
  form[l + lm] = '\0';
}


static int <A NAME="str_format"><SPAN CLASS="definition">str_format</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  int top = <A HREF="lapi.c.html#lua_gettop">lua_gettop</A>(L);
  int arg = 1;
  size_t sfl;
  const char *strfrmt = <A HREF="lauxlib.c.html#luaL_checklstring">luaL_checklstring</A>(L, arg, &amp;sfl);
  const char *strfrmt_end = strfrmt+sfl;
  <A HREF="lauxlib.h.html#luaL_Buffer">luaL_Buffer</A> b;
  <A HREF="lauxlib.c.html#luaL_buffinit">luaL_buffinit</A>(L, &amp;b);
  while (strfrmt &lt; strfrmt_end) {
    if (*strfrmt != <A HREF="lstrlib.c.html#L_ESC">L_ESC</A>)
      <A HREF="lauxlib.h.html#luaL_addchar">luaL_addchar</A>(&amp;b, *strfrmt++);
    else if (*++strfrmt == <A HREF="lstrlib.c.html#L_ESC">L_ESC</A>)
      <A HREF="lauxlib.h.html#luaL_addchar">luaL_addchar</A>(&amp;b, *strfrmt++);  /* %% */
    else { /* format item */
      char form[<A HREF="lstrlib.c.html#MAX_FORMAT">MAX_FORMAT</A>];  /* to store the format ('%...') */
      char *buff = <A HREF="lauxlib.c.html#luaL_prepbuffsize">luaL_prepbuffsize</A>(&amp;b, <A HREF="lstrlib.c.html#MAX_ITEM">MAX_ITEM</A>);  /* to put formatted item */
      int nb = 0;  /* number of bytes in added item */
      if (++arg &gt; top)
        <A HREF="lauxlib.c.html#luaL_argerror">luaL_argerror</A>(L, arg, "no value");
      strfrmt = <A HREF="lstrlib.c.html#scanformat">scanformat</A>(L, strfrmt, form);
      switch (*strfrmt++) {
        case 'c': {
          nb = <A HREF="luaconf.h.html#l_sprintf">l_sprintf</A>(buff, <A HREF="lstrlib.c.html#MAX_ITEM">MAX_ITEM</A>, form, (int)<A HREF="lauxlib.c.html#luaL_checkinteger">luaL_checkinteger</A>(L, arg));
          break;
        }
        case 'd': case 'i':
        case 'o': case 'u': case 'x': case 'X': {
          <A HREF="lua.h.html#lua_Integer">lua_Integer</A> n = <A HREF="lauxlib.c.html#luaL_checkinteger">luaL_checkinteger</A>(L, arg);
          <A HREF="lstrlib.c.html#addlenmod">addlenmod</A>(form, <A HREF="luaconf.h.html#LUA_INTEGER_FRMLEN">LUA_INTEGER_FRMLEN</A>);
          nb = <A HREF="luaconf.h.html#l_sprintf">l_sprintf</A>(buff, <A HREF="lstrlib.c.html#MAX_ITEM">MAX_ITEM</A>, form, n);
          break;
        }
        case 'a': case 'A':
          <A HREF="lstrlib.c.html#addlenmod">addlenmod</A>(form, <A HREF="luaconf.h.html#LUA_NUMBER_FRMLEN">LUA_NUMBER_FRMLEN</A>);
          nb = <A HREF="lstrlib.c.html#lua_number2strx">lua_number2strx</A>(L, buff, <A HREF="lstrlib.c.html#MAX_ITEM">MAX_ITEM</A>, form,
                                  <A HREF="lauxlib.c.html#luaL_checknumber">luaL_checknumber</A>(L, arg));
          break;
        case 'e': case 'E': case 'f':
        case 'g': case '<A HREF="lstate.h.html#G">G</A>': {
          <A HREF="lstrlib.c.html#addlenmod">addlenmod</A>(form, <A HREF="luaconf.h.html#LUA_NUMBER_FRMLEN">LUA_NUMBER_FRMLEN</A>);
          nb = <A HREF="luaconf.h.html#l_sprintf">l_sprintf</A>(buff, <A HREF="lstrlib.c.html#MAX_ITEM">MAX_ITEM</A>, form, <A HREF="lauxlib.c.html#luaL_checknumber">luaL_checknumber</A>(L, arg));
          break;
        }
        case 'q': {
          <A HREF="lstrlib.c.html#addquoted">addquoted</A>(L, &amp;b, arg);
          break;
        }
        case 's': {
          size_t l;
          const char *s = <A HREF="lauxlib.c.html#luaL_tolstring">luaL_tolstring</A>(L, arg, &amp;l);
          if (form[2] == '\0')  /* no modifiers? */
            <A HREF="lauxlib.c.html#luaL_addvalue">luaL_addvalue</A>(&amp;b);  /* keep entire string */
          else {
            <A HREF="lauxlib.h.html#luaL_argcheck">luaL_argcheck</A>(L, l == strlen(s), arg, "string contains zeros");
            if (!strchr(form, '.') &amp;&amp; l &gt;= 100) {
              /* no precision and string is too long to be formatted */
              <A HREF="lauxlib.c.html#luaL_addvalue">luaL_addvalue</A>(&amp;b);  /* keep entire string */
            }
            else {  /* format the string into 'buff' */
              nb = <A HREF="luaconf.h.html#l_sprintf">l_sprintf</A>(buff, <A HREF="lstrlib.c.html#MAX_ITEM">MAX_ITEM</A>, form, s);
              <A HREF="lua.h.html#lua_pop">lua_pop</A>(L, 1);  /* remove result from '<A HREF="lauxlib.c.html#luaL_tolstring">luaL_tolstring</A>' */
            }
          }
          break;
        }
        default: {  /* also treat cases 'pnLlh' */
          return <A HREF="lauxlib.c.html#luaL_error">luaL_error</A>(L, "invalid option '%%%c' to 'format'",
                               *(strfrmt - 1));
        }
      }
      <A HREF="llimits.h.html#lua_assert">lua_assert</A>(nb &lt; <A HREF="lstrlib.c.html#MAX_ITEM">MAX_ITEM</A>);
      <A HREF="lauxlib.h.html#luaL_addsize">luaL_addsize</A>(&amp;b, nb);
    }
  }
  <A HREF="lauxlib.c.html#luaL_pushresult">luaL_pushresult</A>(&amp;b);
  return 1;
}

/* }====================================================== */


/*
** {======================================================
** PACK/UNPACK
** =======================================================
*/


/* value used for padding */
#if !defined(<A HREF="lstrlib.c.html#LUA_PACKPADBYTE">LUA_PACKPADBYTE</A>)
#define <A NAME="LUA_PACKPADBYTE"><SPAN CLASS="definition">LUA_PACKPADBYTE</SPAN></A>         0x00
#endif

/* maximum size for the binary representation of an integer */
#define <A NAME="MAXINTSIZE"><SPAN CLASS="definition">MAXINTSIZE</SPAN></A>      16

/* number of bits in a character */
#define <A NAME="NB"><SPAN CLASS="definition">NB</SPAN></A>      CHAR_BIT

/* mask for one character (<A HREF="lstrlib.c.html#NB">NB</A> 1's) */
#define <A NAME="MC"><SPAN CLASS="definition">MC</SPAN></A>      ((1 &lt;&lt; <A HREF="lstrlib.c.html#NB">NB</A>) - 1)

/* size of a <A HREF="lua.h.html#lua_Integer">lua_Integer</A> */
#define <A NAME="SZINT"><SPAN CLASS="definition">SZINT</SPAN></A>   ((int)sizeof(<A HREF="lua.h.html#lua_Integer">lua_Integer</A>))


/* dummy union to get native endianness */
static const union {
  int dummy;
  char little;  /* true iff machine is little endian */
} <A NAME="nativeendian"><SPAN CLASS="definition">nativeendian</SPAN></A> = {1};


/* dummy structure to get native alignment requirements */
struct <A NAME="cD"><SPAN CLASS="definition">cD</SPAN></A> {
  char c;
  union { double d; void *p; <A HREF="lua.h.html#lua_Integer">lua_Integer</A> i; <A HREF="lua.h.html#lua_Number">lua_Number</A> n; } u;
};

#define <A NAME="MAXALIGN"><SPAN CLASS="definition">MAXALIGN</SPAN></A>        (offsetof(struct <A HREF="lstrlib.c.html#cD">cD</A>, u))


/*
** Union for serializing floats
*/
typedef union <A NAME="Ftypes"><SPAN CLASS="definition">Ftypes</SPAN></A> {
  float f;
  double d;
  <A HREF="lua.h.html#lua_Number">lua_Number</A> n;
  char buff[5 * sizeof(<A HREF="lua.h.html#lua_Number">lua_Number</A>)];  /* enough for any float type */
} <A HREF="lstrlib.c.html#Ftypes">Ftypes</A>;


/*
** information to pack/unpack stuff
*/
typedef struct <A NAME="Header"><SPAN CLASS="definition">Header</SPAN></A> {
  <A HREF="lstate.h.html#lua_State">lua_State</A> *L;
  int islittle;
  int maxalign;
} <A HREF="lstrlib.c.html#Header">Header</A>;


/*
** options for pack/unpack
*/
typedef enum <A NAME="KOption"><SPAN CLASS="definition">KOption</SPAN></A> {
  <A NAME="Kint"><SPAN CLASS="definition">Kint</SPAN></A>,         /* signed integers */
  <A NAME="Kuint"><SPAN CLASS="definition">Kuint</SPAN></A>,        /* unsigned integers */
  <A NAME="Kfloat"><SPAN CLASS="definition">Kfloat</SPAN></A>,       /* floating-point numbers */
  <A NAME="Kchar"><SPAN CLASS="definition">Kchar</SPAN></A>,        /* fixed-length strings */
  <A NAME="Kstring"><SPAN CLASS="definition">Kstring</SPAN></A>,      /* strings with prefixed length */
  <A NAME="Kzstr"><SPAN CLASS="definition">Kzstr</SPAN></A>,        /* zero-terminated strings */
  <A NAME="Kpadding"><SPAN CLASS="definition">Kpadding</SPAN></A>,     /* padding */
  <A NAME="Kpaddalign"><SPAN CLASS="definition">Kpaddalign</SPAN></A>,   /* padding for alignment */
  <A NAME="Knop"><SPAN CLASS="definition">Knop</SPAN></A>          /* no-op (configuration or spaces) */
} <A HREF="lstrlib.c.html#KOption">KOption</A>;


/*
** Read an integer numeral from string 'fmt' or return 'df' if
** there is no numeral
*/
static int <A NAME="digit"><SPAN CLASS="definition">digit</SPAN></A> (int c) { return '0' &lt;= c &amp;&amp; c &lt;= '9'; }

static int <A NAME="getnum"><SPAN CLASS="definition">getnum</SPAN></A> (const char **fmt, int df) {
  if (!<A HREF="lstrlib.c.html#digit">digit</A>(**fmt))  /* no number? */
    return df;  /* return default value */
  else {
    int a = 0;
    do {
      a = a*10 + (*((*fmt)++) - '0');
    } while (<A HREF="lstrlib.c.html#digit">digit</A>(**fmt) &amp;&amp; a &lt;= ((int)<A HREF="lstrlib.c.html#MAXSIZE">MAXSIZE</A> - 9)/10);
    return a;
  }
}


/*
** Read an integer numeral and raises an error if it is larger
** than the maximum size for integers.
*/
static int <A NAME="getnumlimit"><SPAN CLASS="definition">getnumlimit</SPAN></A> (<A HREF="lstrlib.c.html#Header">Header</A> *h, const char **fmt, int df) {
  int sz = <A HREF="lstrlib.c.html#getnum">getnum</A>(fmt, df);
  if (sz &gt; <A HREF="lstrlib.c.html#MAXINTSIZE">MAXINTSIZE</A> || sz &lt;= 0)
    <A HREF="lauxlib.c.html#luaL_error">luaL_error</A>(h-&gt;L, "integral size (%d) out of limits [1,%d]",
                     sz, <A HREF="lstrlib.c.html#MAXINTSIZE">MAXINTSIZE</A>);
  return sz;
}


/*
** Initialize <A HREF="lstrlib.c.html#Header">Header</A>
*/
static void <A NAME="initheader"><SPAN CLASS="definition">initheader</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L, <A HREF="lstrlib.c.html#Header">Header</A> *h) {
  h-&gt;L = L;
  h-&gt;islittle = <A HREF="lstrlib.c.html#nativeendian">nativeendian</A>.little;
  h-&gt;maxalign = 1;
}


/*
** Read and classify next option. 'size' is filled with option's size.
*/
static <A HREF="lstrlib.c.html#KOption">KOption</A> <A NAME="getoption"><SPAN CLASS="definition">getoption</SPAN></A> (<A HREF="lstrlib.c.html#Header">Header</A> *h, const char **fmt, int *size) {
  int opt = *((*fmt)++);
  *size = 0;  /* default */
  switch (opt) {
    case 'b': *size = sizeof(char); return <A HREF="lstrlib.c.html#Kint">Kint</A>;
    case 'B': *size = sizeof(char); return <A HREF="lstrlib.c.html#Kuint">Kuint</A>;
    case 'h': *size = sizeof(short); return <A HREF="lstrlib.c.html#Kint">Kint</A>;
    case 'H': *size = sizeof(short); return <A HREF="lstrlib.c.html#Kuint">Kuint</A>;
    case 'l': *size = sizeof(long); return <A HREF="lstrlib.c.html#Kint">Kint</A>;
    case 'L': *size = sizeof(long); return <A HREF="lstrlib.c.html#Kuint">Kuint</A>;
    case 'j': *size = sizeof(<A HREF="lua.h.html#lua_Integer">lua_Integer</A>); return <A HREF="lstrlib.c.html#Kint">Kint</A>;
    case 'J': *size = sizeof(<A HREF="lua.h.html#lua_Integer">lua_Integer</A>); return <A HREF="lstrlib.c.html#Kuint">Kuint</A>;
    case 'T': *size = sizeof(size_t); return <A HREF="lstrlib.c.html#Kuint">Kuint</A>;
    case 'f': *size = sizeof(float); return <A HREF="lstrlib.c.html#Kfloat">Kfloat</A>;
    case 'd': *size = sizeof(double); return <A HREF="lstrlib.c.html#Kfloat">Kfloat</A>;
    case 'n': *size = sizeof(<A HREF="lua.h.html#lua_Number">lua_Number</A>); return <A HREF="lstrlib.c.html#Kfloat">Kfloat</A>;
    case 'i': *size = <A HREF="lstrlib.c.html#getnumlimit">getnumlimit</A>(h, fmt, sizeof(int)); return <A HREF="lstrlib.c.html#Kint">Kint</A>;
    case 'I': *size = <A HREF="lstrlib.c.html#getnumlimit">getnumlimit</A>(h, fmt, sizeof(int)); return <A HREF="lstrlib.c.html#Kuint">Kuint</A>;
    case 's': *size = <A HREF="lstrlib.c.html#getnumlimit">getnumlimit</A>(h, fmt, sizeof(size_t)); return <A HREF="lstrlib.c.html#Kstring">Kstring</A>;
    case 'c':
      *size = <A HREF="lstrlib.c.html#getnum">getnum</A>(fmt, -1);
      if (*size == -1)
        <A HREF="lauxlib.c.html#luaL_error">luaL_error</A>(h-&gt;L, "missing size for format option 'c'");
      return <A HREF="lstrlib.c.html#Kchar">Kchar</A>;
    case 'z': return <A HREF="lstrlib.c.html#Kzstr">Kzstr</A>;
    case 'x': *size = 1; return <A HREF="lstrlib.c.html#Kpadding">Kpadding</A>;
    case 'X': return <A HREF="lstrlib.c.html#Kpaddalign">Kpaddalign</A>;
    case ' ': break;
    case '&lt;': h-&gt;islittle = 1; break;
    case '&gt;': h-&gt;islittle = 0; break;
    case '=': h-&gt;islittle = <A HREF="lstrlib.c.html#nativeendian">nativeendian</A>.little; break;
    case '!': h-&gt;maxalign = <A HREF="lstrlib.c.html#getnumlimit">getnumlimit</A>(h, fmt, <A HREF="lstrlib.c.html#MAXALIGN">MAXALIGN</A>); break;
    default: <A HREF="lauxlib.c.html#luaL_error">luaL_error</A>(h-&gt;L, "invalid format option '%c'", opt);
  }
  return <A HREF="lstrlib.c.html#Knop">Knop</A>;
}


/*
** Read, classify, and fill other details about the next option.
** 'psize' is filled with option's size, 'notoalign' with its
** alignment requirements.
** Local variable 'size' gets the size to be aligned. (Kpadal option
** always gets its full alignment, other options are limited by 
** the maximum alignment ('maxalign'). <A HREF="lstrlib.c.html#Kchar">Kchar</A> option needs no alignment
** despite its size.
*/
static <A HREF="lstrlib.c.html#KOption">KOption</A> <A NAME="getdetails"><SPAN CLASS="definition">getdetails</SPAN></A> (<A HREF="lstrlib.c.html#Header">Header</A> *h, size_t totalsize,
                           const char **fmt, int *psize, int *ntoalign) {
  <A HREF="lstrlib.c.html#KOption">KOption</A> opt = <A HREF="lstrlib.c.html#getoption">getoption</A>(h, fmt, psize);
  int align = *psize;  /* usually, alignment follows size */
  if (opt == <A HREF="lstrlib.c.html#Kpaddalign">Kpaddalign</A>) {  /* 'X' gets alignment from following option */
    if (**fmt == '\0' || <A HREF="lstrlib.c.html#getoption">getoption</A>(h, fmt, &amp;align) == <A HREF="lstrlib.c.html#Kchar">Kchar</A> || align == 0)
      <A HREF="lauxlib.c.html#luaL_argerror">luaL_argerror</A>(h-&gt;L, 1, "invalid next option for option 'X'");
  }
  if (align &lt;= 1 || opt == <A HREF="lstrlib.c.html#Kchar">Kchar</A>)  /* need no alignment? */
    *ntoalign = 0;
  else {
    if (align &gt; h-&gt;maxalign)  /* enforce maximum alignment */
      align = h-&gt;maxalign;
    if ((align &amp; (align - 1)) != 0)  /* is 'align' not a power of 2? */
      <A HREF="lauxlib.c.html#luaL_argerror">luaL_argerror</A>(h-&gt;L, 1, "format asks for alignment not power of 2");
    *ntoalign = (align - (int)(totalsize &amp; (align - 1))) &amp; (align - 1);
  }
  return opt;
}


/*
** Pack integer 'n' with 'size' bytes and 'islittle' endianness.
** The final 'if' handles the case when 'size' is larger than
** the size of a Lua integer, correcting the extra sign-extension
** bytes if necessary (by default they would be zeros).
*/
static void <A NAME="packint"><SPAN CLASS="definition">packint</SPAN></A> (<A HREF="lauxlib.h.html#luaL_Buffer">luaL_Buffer</A> *b, <A HREF="lua.h.html#lua_Unsigned">lua_Unsigned</A> n,
                     int islittle, int size, int neg) {
  char *buff = <A HREF="lauxlib.c.html#luaL_prepbuffsize">luaL_prepbuffsize</A>(b, size);
  int i;
  buff[islittle ? 0 : size - 1] = (char)(n &amp; <A HREF="lstrlib.c.html#MC">MC</A>);  /* first byte */
  for (i = 1; i &lt; size; i++) {
    n &gt;&gt;= <A HREF="lstrlib.c.html#NB">NB</A>;
    buff[islittle ? i : size - 1 - i] = (char)(n &amp; <A HREF="lstrlib.c.html#MC">MC</A>);
  }
  if (neg &amp;&amp; size &gt; <A HREF="lstrlib.c.html#SZINT">SZINT</A>) {  /* negative number need sign extension? */
    for (i = <A HREF="lstrlib.c.html#SZINT">SZINT</A>; i &lt; size; i++)  /* correct extra bytes */
      buff[islittle ? i : size - 1 - i] = (char)<A HREF="lstrlib.c.html#MC">MC</A>;
  }
  <A HREF="lauxlib.h.html#luaL_addsize">luaL_addsize</A>(b, size);  /* add result to buffer */
}


/*
** Copy 'size' bytes from 'src' to 'dest', correcting endianness if
** given 'islittle' is different from native endianness.
*/
static void <A NAME="copywithendian"><SPAN CLASS="definition">copywithendian</SPAN></A> (volatile char *dest, volatile const char *src,
                            int size, int islittle) {
  if (islittle == <A HREF="lstrlib.c.html#nativeendian">nativeendian</A>.little) {
    while (size-- != 0)
      *(dest++) = *(src++);
  }
  else {
    dest += size - 1;
    while (size-- != 0)
      *(dest--) = *(src++);
  }
}


static int <A NAME="str_pack"><SPAN CLASS="definition">str_pack</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  <A HREF="lauxlib.h.html#luaL_Buffer">luaL_Buffer</A> b;
  <A HREF="lstrlib.c.html#Header">Header</A> h;
  const char *fmt = <A HREF="lauxlib.h.html#luaL_checkstring">luaL_checkstring</A>(L, 1);  /* format string */
  int arg = 1;  /* current argument to pack */
  size_t totalsize = 0;  /* accumulate total size of result */
  <A HREF="lstrlib.c.html#initheader">initheader</A>(L, &amp;h);
  <A HREF="lapi.c.html#lua_pushnil">lua_pushnil</A>(L);  /* mark to separate arguments from string buffer */
  <A HREF="lauxlib.c.html#luaL_buffinit">luaL_buffinit</A>(L, &amp;b);
  while (*fmt != '\0') {
    int size, ntoalign;
    <A HREF="lstrlib.c.html#KOption">KOption</A> opt = <A HREF="lstrlib.c.html#getdetails">getdetails</A>(&amp;h, totalsize, &amp;fmt, &amp;size, &amp;ntoalign);
    totalsize += ntoalign + size;
    while (ntoalign-- &gt; 0)
     <A HREF="lauxlib.h.html#luaL_addchar">luaL_addchar</A>(&amp;b, <A HREF="lstrlib.c.html#LUA_PACKPADBYTE">LUA_PACKPADBYTE</A>);  /* fill alignment */
    arg++;
    switch (opt) {
      case <A HREF="lstrlib.c.html#Kint">Kint</A>: {  /* signed integers */
        <A HREF="lua.h.html#lua_Integer">lua_Integer</A> n = <A HREF="lauxlib.c.html#luaL_checkinteger">luaL_checkinteger</A>(L, arg);
        if (size &lt; <A HREF="lstrlib.c.html#SZINT">SZINT</A>) {  /* need overflow check? */
          <A HREF="lua.h.html#lua_Integer">lua_Integer</A> lim = (<A HREF="lua.h.html#lua_Integer">lua_Integer</A>)1 &lt;&lt; ((size * <A HREF="lstrlib.c.html#NB">NB</A>) - 1);
          <A HREF="lauxlib.h.html#luaL_argcheck">luaL_argcheck</A>(L, -lim &lt;= n &amp;&amp; n &lt; lim, arg, "integer overflow");
        }
        <A HREF="lstrlib.c.html#packint">packint</A>(&amp;b, (<A HREF="lua.h.html#lua_Unsigned">lua_Unsigned</A>)n, h.islittle, size, (n &lt; 0));
        break;
      }
      case <A HREF="lstrlib.c.html#Kuint">Kuint</A>: {  /* unsigned integers */
        <A HREF="lua.h.html#lua_Integer">lua_Integer</A> n = <A HREF="lauxlib.c.html#luaL_checkinteger">luaL_checkinteger</A>(L, arg);
        if (size &lt; <A HREF="lstrlib.c.html#SZINT">SZINT</A>)  /* need overflow check? */
          <A HREF="lauxlib.h.html#luaL_argcheck">luaL_argcheck</A>(L, (<A HREF="lua.h.html#lua_Unsigned">lua_Unsigned</A>)n &lt; ((<A HREF="lua.h.html#lua_Unsigned">lua_Unsigned</A>)1 &lt;&lt; (size * <A HREF="lstrlib.c.html#NB">NB</A>)),
                           arg, "unsigned overflow");
        <A HREF="lstrlib.c.html#packint">packint</A>(&amp;b, (<A HREF="lua.h.html#lua_Unsigned">lua_Unsigned</A>)n, h.islittle, size, 0);
        break;
      }
      case <A HREF="lstrlib.c.html#Kfloat">Kfloat</A>: {  /* floating-point options */
        volatile <A HREF="lstrlib.c.html#Ftypes">Ftypes</A> u;
        char *buff = <A HREF="lauxlib.c.html#luaL_prepbuffsize">luaL_prepbuffsize</A>(&amp;b, size);
        <A HREF="lua.h.html#lua_Number">lua_Number</A> n = <A HREF="lauxlib.c.html#luaL_checknumber">luaL_checknumber</A>(L, arg);  /* get argument */
        if (size == sizeof(u.f)) u.f = (float)n;  /* copy it into 'u' */
        else if (size == sizeof(u.d)) u.d = (double)n;
        else u.n = n;
        /* move 'u' to final result, correcting endianness if needed */
        <A HREF="lstrlib.c.html#copywithendian">copywithendian</A>(buff, u.buff, size, h.islittle);
        <A HREF="lauxlib.h.html#luaL_addsize">luaL_addsize</A>(&amp;b, size);
        break;
      }
      case <A HREF="lstrlib.c.html#Kchar">Kchar</A>: {  /* fixed-size string */
        size_t len;
        const char *s = <A HREF="lauxlib.c.html#luaL_checklstring">luaL_checklstring</A>(L, arg, &amp;len);
        if ((size_t)size &lt;= len)  /* string larger than (or equal to) needed? */
          <A HREF="lauxlib.c.html#luaL_addlstring">luaL_addlstring</A>(&amp;b, s, size);  /* truncate string to asked size */
        else {  /* string smaller than needed */
          <A HREF="lauxlib.c.html#luaL_addlstring">luaL_addlstring</A>(&amp;b, s, len);  /* add it all */
          while (len++ &lt; (size_t)size)  /* pad extra space */
            <A HREF="lauxlib.h.html#luaL_addchar">luaL_addchar</A>(&amp;b, <A HREF="lstrlib.c.html#LUA_PACKPADBYTE">LUA_PACKPADBYTE</A>);
        }
        break;
      }
      case <A HREF="lstrlib.c.html#Kstring">Kstring</A>: {  /* strings with length count */
        size_t len;
        const char *s = <A HREF="lauxlib.c.html#luaL_checklstring">luaL_checklstring</A>(L, arg, &amp;len);
        <A HREF="lauxlib.h.html#luaL_argcheck">luaL_argcheck</A>(L, size &gt;= (int)sizeof(size_t) ||
                         len &lt; ((size_t)1 &lt;&lt; (size * <A HREF="lstrlib.c.html#NB">NB</A>)),
                         arg, "string length does not fit in given size");
        <A HREF="lstrlib.c.html#packint">packint</A>(&amp;b, (<A HREF="lua.h.html#lua_Unsigned">lua_Unsigned</A>)len, h.islittle, size, 0);  /* pack length */
        <A HREF="lauxlib.c.html#luaL_addlstring">luaL_addlstring</A>(&amp;b, s, len);
        totalsize += len;
        break;
      }
      case <A HREF="lstrlib.c.html#Kzstr">Kzstr</A>: {  /* zero-terminated string */
        size_t len;
        const char *s = <A HREF="lauxlib.c.html#luaL_checklstring">luaL_checklstring</A>(L, arg, &amp;len);
        <A HREF="lauxlib.h.html#luaL_argcheck">luaL_argcheck</A>(L, strlen(s) == len, arg, "string contains zeros");
        <A HREF="lauxlib.c.html#luaL_addlstring">luaL_addlstring</A>(&amp;b, s, len);
        <A HREF="lauxlib.h.html#luaL_addchar">luaL_addchar</A>(&amp;b, '\0');  /* add zero at the end */
        totalsize += len + 1;
        break;
      }
      case <A HREF="lstrlib.c.html#Kpadding">Kpadding</A>: <A HREF="lauxlib.h.html#luaL_addchar">luaL_addchar</A>(&amp;b, <A HREF="lstrlib.c.html#LUA_PACKPADBYTE">LUA_PACKPADBYTE</A>);  /* FALLTHROUGH */
      case <A HREF="lstrlib.c.html#Kpaddalign">Kpaddalign</A>: case <A HREF="lstrlib.c.html#Knop">Knop</A>:
        arg--;  /* undo increment */
        break;
    }
  }
  <A HREF="lauxlib.c.html#luaL_pushresult">luaL_pushresult</A>(&amp;b);
  return 1;
}


static int <A NAME="str_packsize"><SPAN CLASS="definition">str_packsize</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  <A HREF="lstrlib.c.html#Header">Header</A> h;
  const char *fmt = <A HREF="lauxlib.h.html#luaL_checkstring">luaL_checkstring</A>(L, 1);  /* format string */
  size_t totalsize = 0;  /* accumulate total size of result */
  <A HREF="lstrlib.c.html#initheader">initheader</A>(L, &amp;h);
  while (*fmt != '\0') {
    int size, ntoalign;
    <A HREF="lstrlib.c.html#KOption">KOption</A> opt = <A HREF="lstrlib.c.html#getdetails">getdetails</A>(&amp;h, totalsize, &amp;fmt, &amp;size, &amp;ntoalign);
    size += ntoalign;  /* total space used by option */
    <A HREF="lauxlib.h.html#luaL_argcheck">luaL_argcheck</A>(L, totalsize &lt;= <A HREF="lstrlib.c.html#MAXSIZE">MAXSIZE</A> - size, 1,
                     "format result too large");
    totalsize += size;
    switch (opt) {
      case <A HREF="lstrlib.c.html#Kstring">Kstring</A>:  /* strings with length count */
      case <A HREF="lstrlib.c.html#Kzstr">Kzstr</A>:    /* zero-terminated string */
        <A HREF="lauxlib.c.html#luaL_argerror">luaL_argerror</A>(L, 1, "variable-length format");
        /* call never return, but to avoid warnings: *//* FALLTHROUGH */
      default:  break;
    }
  }
  <A HREF="lapi.c.html#lua_pushinteger">lua_pushinteger</A>(L, (<A HREF="lua.h.html#lua_Integer">lua_Integer</A>)totalsize);
  return 1;
}


/*
** Unpack an integer with 'size' bytes and 'islittle' endianness.
** If size is smaller than the size of a Lua integer and integer
** is signed, must do sign extension (propagating the sign to the
** higher bits); if size is larger than the size of a Lua integer,
** it must check the unread bytes to see whether they do not cause an
** overflow.
*/
static <A HREF="lua.h.html#lua_Integer">lua_Integer</A> <A NAME="unpackint"><SPAN CLASS="definition">unpackint</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L, const char *str,
                              int islittle, int size, int issigned) {
  <A HREF="lua.h.html#lua_Unsigned">lua_Unsigned</A> res = 0;
  int i;
  int limit = (size  &lt;= <A HREF="lstrlib.c.html#SZINT">SZINT</A>) ? size : <A HREF="lstrlib.c.html#SZINT">SZINT</A>;
  for (i = limit - 1; i &gt;= 0; i--) {
    res &lt;&lt;= <A HREF="lstrlib.c.html#NB">NB</A>;
    res |= (<A HREF="lua.h.html#lua_Unsigned">lua_Unsigned</A>)(unsigned char)str[islittle ? i : size - 1 - i];
  }
  if (size &lt; <A HREF="lstrlib.c.html#SZINT">SZINT</A>) {  /* real size smaller than <A HREF="lua.h.html#lua_Integer">lua_Integer</A>? */
    if (issigned) {  /* needs sign extension? */
      <A HREF="lua.h.html#lua_Unsigned">lua_Unsigned</A> mask = (<A HREF="lua.h.html#lua_Unsigned">lua_Unsigned</A>)1 &lt;&lt; (size*<A HREF="lstrlib.c.html#NB">NB</A> - 1);
      res = ((res ^ mask) - mask);  /* do sign extension */
    }
  }
  else if (size &gt; <A HREF="lstrlib.c.html#SZINT">SZINT</A>) {  /* must check unread bytes */
    int mask = (!issigned || (<A HREF="lua.h.html#lua_Integer">lua_Integer</A>)res &gt;= 0) ? 0 : <A HREF="lstrlib.c.html#MC">MC</A>;
    for (i = limit; i &lt; size; i++) {
      if ((unsigned char)str[islittle ? i : size - 1 - i] != mask)
        <A HREF="lauxlib.c.html#luaL_error">luaL_error</A>(L, "%d-byte integer does not fit into Lua Integer", size);
    }
  }
  return (<A HREF="lua.h.html#lua_Integer">lua_Integer</A>)res;
}


static int <A NAME="str_unpack"><SPAN CLASS="definition">str_unpack</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  <A HREF="lstrlib.c.html#Header">Header</A> h;
  const char *fmt = <A HREF="lauxlib.h.html#luaL_checkstring">luaL_checkstring</A>(L, 1);
  size_t ld;
  const char *data = <A HREF="lauxlib.c.html#luaL_checklstring">luaL_checklstring</A>(L, 2, &amp;ld);
  size_t pos = (size_t)<A HREF="lstrlib.c.html#posrelat">posrelat</A>(<A HREF="lauxlib.c.html#luaL_optinteger">luaL_optinteger</A>(L, 3, 1), ld) - 1;
  int n = 0;  /* number of results */
  <A HREF="lauxlib.h.html#luaL_argcheck">luaL_argcheck</A>(L, pos &lt;= ld, 3, "initial position out of string");
  <A HREF="lstrlib.c.html#initheader">initheader</A>(L, &amp;h);
  while (*fmt != '\0') {
    int size, ntoalign;
    <A HREF="lstrlib.c.html#KOption">KOption</A> opt = <A HREF="lstrlib.c.html#getdetails">getdetails</A>(&amp;h, pos, &amp;fmt, &amp;size, &amp;ntoalign);
    if ((size_t)ntoalign + size &gt; ~pos || pos + ntoalign + size &gt; ld)
      <A HREF="lauxlib.c.html#luaL_argerror">luaL_argerror</A>(L, 2, "data string too short");
    pos += ntoalign;  /* skip alignment */
    /* stack space for item + next position */
    <A HREF="lauxlib.c.html#luaL_checkstack">luaL_checkstack</A>(L, 2, "too many results");
    n++;
    switch (opt) {
      case <A HREF="lstrlib.c.html#Kint">Kint</A>:
      case <A HREF="lstrlib.c.html#Kuint">Kuint</A>: {
        <A HREF="lua.h.html#lua_Integer">lua_Integer</A> res = <A HREF="lstrlib.c.html#unpackint">unpackint</A>(L, data + pos, h.islittle, size,
                                       (opt == <A HREF="lstrlib.c.html#Kint">Kint</A>));
        <A HREF="lapi.c.html#lua_pushinteger">lua_pushinteger</A>(L, res);
        break;
      }
      case <A HREF="lstrlib.c.html#Kfloat">Kfloat</A>: {
        volatile <A HREF="lstrlib.c.html#Ftypes">Ftypes</A> u;
        <A HREF="lua.h.html#lua_Number">lua_Number</A> num;
        <A HREF="lstrlib.c.html#copywithendian">copywithendian</A>(u.buff, data + pos, size, h.islittle);
        if (size == sizeof(u.f)) num = (<A HREF="lua.h.html#lua_Number">lua_Number</A>)u.f;
        else if (size == sizeof(u.d)) num = (<A HREF="lua.h.html#lua_Number">lua_Number</A>)u.d;
        else num = u.n;
        <A HREF="lapi.c.html#lua_pushnumber">lua_pushnumber</A>(L, num);
        break;
      }
      case <A HREF="lstrlib.c.html#Kchar">Kchar</A>: {
        <A HREF="lapi.c.html#lua_pushlstring">lua_pushlstring</A>(L, data + pos, size);
        break;
      }
      case <A HREF="lstrlib.c.html#Kstring">Kstring</A>: {
        size_t len = (size_t)<A HREF="lstrlib.c.html#unpackint">unpackint</A>(L, data + pos, h.islittle, size, 0);
        <A HREF="lauxlib.h.html#luaL_argcheck">luaL_argcheck</A>(L, pos + len + size &lt;= ld, 2, "data string too short");
        <A HREF="lapi.c.html#lua_pushlstring">lua_pushlstring</A>(L, data + pos + size, len);
        pos += len;  /* skip string */
        break;
      }
      case <A HREF="lstrlib.c.html#Kzstr">Kzstr</A>: {
        size_t len = (int)strlen(data + pos);
        <A HREF="lapi.c.html#lua_pushlstring">lua_pushlstring</A>(L, data + pos, len);
        pos += len + 1;  /* skip string plus final '\0' */
        break;
      }
      case <A HREF="lstrlib.c.html#Kpaddalign">Kpaddalign</A>: case <A HREF="lstrlib.c.html#Kpadding">Kpadding</A>: case <A HREF="lstrlib.c.html#Knop">Knop</A>:
        n--;  /* undo increment */
        break;
    }
    pos += size;
  }
  <A HREF="lapi.c.html#lua_pushinteger">lua_pushinteger</A>(L, pos + 1);  /* next position */
  return n + 1;
}

/* }====================================================== */


static const <A HREF="lauxlib.h.html#luaL_Reg">luaL_Reg</A> <A NAME="strlib"><SPAN CLASS="definition">strlib</SPAN></A>[] = {
  {"byte", <A HREF="lstrlib.c.html#str_byte">str_byte</A>},
  {"char", <A HREF="lstrlib.c.html#str_char">str_char</A>},
  {"dump", <A HREF="lstrlib.c.html#str_dump">str_dump</A>},
  {"find", <A HREF="lstrlib.c.html#str_find">str_find</A>},
  {"format", <A HREF="lstrlib.c.html#str_format">str_format</A>},
  {"<A HREF="lstrlib.c.html#gmatch">gmatch</A>", <A HREF="lstrlib.c.html#gmatch">gmatch</A>},
  {"gsub", <A HREF="lstrlib.c.html#str_gsub">str_gsub</A>},
  {"len", <A HREF="lstrlib.c.html#str_len">str_len</A>},
  {"lower", <A HREF="lstrlib.c.html#str_lower">str_lower</A>},
  {"<A HREF="lstrlib.c.html#match">match</A>", <A HREF="lstrlib.c.html#str_match">str_match</A>},
  {"rep", <A HREF="lstrlib.c.html#str_rep">str_rep</A>},
  {"reverse", <A HREF="lstrlib.c.html#str_reverse">str_reverse</A>},
  {"sub", <A HREF="lstrlib.c.html#str_sub">str_sub</A>},
  {"upper", <A HREF="lstrlib.c.html#str_upper">str_upper</A>},
  {"pack", <A HREF="lstrlib.c.html#str_pack">str_pack</A>},
  {"packsize", <A HREF="lstrlib.c.html#str_packsize">str_packsize</A>},
  {"unpack", <A HREF="lstrlib.c.html#str_unpack">str_unpack</A>},
  {NULL, NULL}
};


static void <A NAME="createmetatable"><SPAN CLASS="definition">createmetatable</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  <A HREF="lapi.c.html#lua_createtable">lua_createtable</A>(L, 0, 1);  /* table to be metatable for strings */
  <A HREF="lua.h.html#lua_pushliteral">lua_pushliteral</A>(L, "");  /* dummy string */
  <A HREF="lapi.c.html#lua_pushvalue">lua_pushvalue</A>(L, -2);  /* copy table */
  <A HREF="lapi.c.html#lua_setmetatable">lua_setmetatable</A>(L, -2);  /* set table as metatable for strings */
  <A HREF="lua.h.html#lua_pop">lua_pop</A>(L, 1);  /* pop dummy string */
  <A HREF="lapi.c.html#lua_pushvalue">lua_pushvalue</A>(L, -2);  /* get string library */
  <A HREF="lapi.c.html#lua_setfield">lua_setfield</A>(L, -2, "__index");  /* metatable.__index = string */
  <A HREF="lua.h.html#lua_pop">lua_pop</A>(L, 1);  /* pop metatable */
}


/*
** Open string library
*/
<A HREF="luaconf.h.html#LUAMOD_API">LUAMOD_API</A> int <A NAME="luaopen_string"><SPAN CLASS="definition">luaopen_string</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  <A HREF="lauxlib.h.html#luaL_newlib">luaL_newlib</A>(L, <A HREF="lstrlib.c.html#strlib">strlib</A>);
  <A HREF="lstrlib.c.html#createmetatable">createmetatable</A>(L);
  return 1;
}

</PRE>

<P CLASS="footer">
Last update:
Mon Nov 30 10:09:15 2015
</P>

</BODY>
</HTML>
