<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Lua 5.3.2 source code - lcode.c</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../lua.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../source.css">
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
</HEAD>

<BODY>

<H1>
<A HREF="../../home.html"><IMG SRC="../../images/logo.gif" ALT="Lua"></A>
lcode.c
<SPAN CLASS="note">(5.3.2)</SPAN>
</H1>

<DIV CLASS="menubar">
<A HREF="./">module index</A>
&middot;
<A HREF="idx.html">name index</A>
&middot;
<A HREF="../">other versions</A>
</DIV>

<PRE>
/*
** $Id: lcode.c,v 2.103 2015/11/19 19:16:22 roberto Exp $
** Code generator for Lua
** See Copyright Notice in lua.h
*/

#define <A NAME="lcode_c"><SPAN CLASS="definition">lcode_c</SPAN></A>
#define <A NAME="LUA_CORE"><SPAN CLASS="definition">LUA_CORE</SPAN></A>

#include "<A HREF="lprefix.h.html">lprefix.h</A>"


#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

#include "<A HREF="lua.h.html">lua.h</A>"

#include "<A HREF="lcode.h.html">lcode.h</A>"
#include "<A HREF="ldebug.h.html">ldebug.h</A>"
#include "<A HREF="ldo.h.html">ldo.h</A>"
#include "<A HREF="lgc.h.html">lgc.h</A>"
#include "<A HREF="llex.h.html">llex.h</A>"
#include "<A HREF="lmem.h.html">lmem.h</A>"
#include "<A HREF="lobject.h.html">lobject.h</A>"
#include "<A HREF="lopcodes.h.html">lopcodes.h</A>"
#include "<A HREF="lparser.h.html">lparser.h</A>"
#include "<A HREF="lstring.h.html">lstring.h</A>"
#include "<A HREF="ltable.h.html">ltable.h</A>"
#include "<A HREF="lvm.h.html">lvm.h</A>"


/* Maximum number of registers in a Lua function (must fit in 8 bits) */
#define <A NAME="MAXREGS"><SPAN CLASS="definition">MAXREGS</SPAN></A>         255


#define <A NAME="hasjumps"><SPAN CLASS="definition">hasjumps</SPAN></A>(e)     ((e)-&gt;t != (e)-&gt;f)


static int <A NAME="tonumeral"><SPAN CLASS="definition">tonumeral</SPAN></A>(<A HREF="lparser.h.html#expdesc">expdesc</A> *e, <A HREF="lobject.h.html#TValue">TValue</A> *v) {
  if (<A HREF="lcode.c.html#hasjumps">hasjumps</A>(e))
    return 0;  /* not a numeral */
  switch (e-&gt;k) {
    case <A HREF="lparser.h.html#VKINT">VKINT</A>:
      if (v) <A HREF="lobject.h.html#setivalue">setivalue</A>(v, e-&gt;u.ival);
      return 1;
    case <A HREF="lparser.h.html#VKFLT">VKFLT</A>:
      if (v) <A HREF="lobject.h.html#setfltvalue">setfltvalue</A>(v, e-&gt;u.nval);
      return 1;
    default: return 0;
  }
}


void <A NAME="luaK_nil"><SPAN CLASS="definition">luaK_nil</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int from, int n) {
  <A HREF="llimits.h.html#Instruction">Instruction</A> *previous;
  int l = from + n - 1;  /* last register to set nil */
  if (fs-&gt;pc &gt; fs-&gt;lasttarget) {  /* no jumps to current position? */
    previous = &amp;fs-&gt;f-&gt;code[fs-&gt;pc-1];
    if (<A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(*previous) == <A HREF="lopcodes.h.html#OP_LOADNIL">OP_LOADNIL</A>) {
      int pfrom = <A HREF="lopcodes.h.html#GETARG_A">GETARG_A</A>(*previous);
      int pl = pfrom + <A HREF="lopcodes.h.html#GETARG_B">GETARG_B</A>(*previous);
      if ((pfrom &lt;= from &amp;&amp; from &lt;= pl + 1) ||
          (from &lt;= pfrom &amp;&amp; pfrom &lt;= l + 1)) {  /* can connect both? */
        if (pfrom &lt; from) from = pfrom;  /* from = min(from, pfrom) */
        if (pl &gt; l) l = pl;  /* l = max(l, pl) */
        <A HREF="lopcodes.h.html#SETARG_A">SETARG_A</A>(*previous, from);
        <A HREF="lopcodes.h.html#SETARG_B">SETARG_B</A>(*previous, l - from);
        return;
      }
    }  /* else go through */
  }
  <A HREF="lcode.c.html#luaK_codeABC">luaK_codeABC</A>(fs, <A HREF="lopcodes.h.html#OP_LOADNIL">OP_LOADNIL</A>, from, n - 1, 0);  /* else no optimization */
}


int <A NAME="luaK_jump"><SPAN CLASS="definition">luaK_jump</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs) {
  int jpc = fs-&gt;jpc;  /* save list of jumps to here */
  int j;
  fs-&gt;jpc = <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;
  j = <A HREF="lcode.h.html#luaK_codeAsBx">luaK_codeAsBx</A>(fs, <A HREF="lopcodes.h.html#OP_JMP">OP_JMP</A>, 0, <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>);
  <A HREF="lcode.c.html#luaK_concat">luaK_concat</A>(fs, &amp;j, jpc);  /* keep them on hold */
  return j;
}


void <A NAME="luaK_ret"><SPAN CLASS="definition">luaK_ret</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int first, int nret) {
  <A HREF="lcode.c.html#luaK_codeABC">luaK_codeABC</A>(fs, <A HREF="lopcodes.h.html#OP_RETURN">OP_RETURN</A>, first, nret+1, 0);
}


static int <A NAME="condjump"><SPAN CLASS="definition">condjump</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lopcodes.h.html#OpCode">OpCode</A> op, int A, int B, int C) {
  <A HREF="lcode.c.html#luaK_codeABC">luaK_codeABC</A>(fs, op, A, B, C);
  return <A HREF="lcode.c.html#luaK_jump">luaK_jump</A>(fs);
}


static void <A NAME="fixjump"><SPAN CLASS="definition">fixjump</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int pc, int dest) {
  <A HREF="llimits.h.html#Instruction">Instruction</A> *jmp = &amp;fs-&gt;f-&gt;code[pc];
  int offset = dest-(pc+1);
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(dest != <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>);
  if (abs(offset) &gt; <A HREF="lopcodes.h.html#MAXARG_sBx">MAXARG_sBx</A>)
    <A HREF="llex.c.html#luaX_syntaxerror">luaX_syntaxerror</A>(fs-&gt;ls, "control structure too long");
  <A HREF="lopcodes.h.html#SETARG_sBx">SETARG_sBx</A>(*jmp, offset);
}


/*
** returns current 'pc' and marks it as a jump target (to avoid wrong
** optimizations with consecutive instructions not in the same basic block).
*/
int <A NAME="luaK_getlabel"><SPAN CLASS="definition">luaK_getlabel</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs) {
  fs-&gt;lasttarget = fs-&gt;pc;
  return fs-&gt;pc;
}


static int <A NAME="getjump"><SPAN CLASS="definition">getjump</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int pc) {
  int offset = <A HREF="lopcodes.h.html#GETARG_sBx">GETARG_sBx</A>(fs-&gt;f-&gt;code[pc]);
  if (offset == <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>)  /* point to itself represents end of list */
    return <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;  /* end of list */
  else
    return (pc+1)+offset;  /* turn offset into absolute position */
}


static <A HREF="llimits.h.html#Instruction">Instruction</A> *<A NAME="getjumpcontrol"><SPAN CLASS="definition">getjumpcontrol</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int pc) {
  <A HREF="llimits.h.html#Instruction">Instruction</A> *pi = &amp;fs-&gt;f-&gt;code[pc];
  if (pc &gt;= 1 &amp;&amp; <A HREF="lopcodes.h.html#testTMode">testTMode</A>(<A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(*(pi-1))))
    return pi-1;
  else
    return pi;
}


/*
** check whether list has any jump that do not produce a value
** (or produce an inverted value)
*/
static int <A NAME="need_value"><SPAN CLASS="definition">need_value</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int list) {
  for (; list != <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>; list = <A HREF="lcode.c.html#getjump">getjump</A>(fs, list)) {
    <A HREF="llimits.h.html#Instruction">Instruction</A> i = *<A HREF="lcode.c.html#getjumpcontrol">getjumpcontrol</A>(fs, list);
    if (<A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(i) != <A HREF="lopcodes.h.html#OP_TESTSET">OP_TESTSET</A>) return 1;
  }
  return 0;  /* not found */
}


static int <A NAME="patchtestreg"><SPAN CLASS="definition">patchtestreg</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int node, int reg) {
  <A HREF="llimits.h.html#Instruction">Instruction</A> *i = <A HREF="lcode.c.html#getjumpcontrol">getjumpcontrol</A>(fs, node);
  if (<A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(*i) != <A HREF="lopcodes.h.html#OP_TESTSET">OP_TESTSET</A>)
    return 0;  /* cannot patch other instructions */
  if (reg != <A HREF="lopcodes.h.html#NO_REG">NO_REG</A> &amp;&amp; reg != <A HREF="lopcodes.h.html#GETARG_B">GETARG_B</A>(*i))
    <A HREF="lopcodes.h.html#SETARG_A">SETARG_A</A>(*i, reg);
  else  /* no register to put value or register already has the value */
    *i = <A HREF="lopcodes.h.html#CREATE_ABC">CREATE_ABC</A>(<A HREF="lopcodes.h.html#OP_TEST">OP_TEST</A>, <A HREF="lopcodes.h.html#GETARG_B">GETARG_B</A>(*i), 0, <A HREF="lopcodes.h.html#GETARG_C">GETARG_C</A>(*i));

  return 1;
}


static void <A NAME="removevalues"><SPAN CLASS="definition">removevalues</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int list) {
  for (; list != <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>; list = <A HREF="lcode.c.html#getjump">getjump</A>(fs, list))
      <A HREF="lcode.c.html#patchtestreg">patchtestreg</A>(fs, list, <A HREF="lopcodes.h.html#NO_REG">NO_REG</A>);
}


static void <A NAME="patchlistaux"><SPAN CLASS="definition">patchlistaux</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int list, int vtarget, int reg,
                          int dtarget) {
  while (list != <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>) {
    int next = <A HREF="lcode.c.html#getjump">getjump</A>(fs, list);
    if (<A HREF="lcode.c.html#patchtestreg">patchtestreg</A>(fs, list, reg))
      <A HREF="lcode.c.html#fixjump">fixjump</A>(fs, list, vtarget);
    else
      <A HREF="lcode.c.html#fixjump">fixjump</A>(fs, list, dtarget);  /* jump to default target */
    list = next;
  }
}


static void <A NAME="dischargejpc"><SPAN CLASS="definition">dischargejpc</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs) {
  <A HREF="lcode.c.html#patchlistaux">patchlistaux</A>(fs, fs-&gt;jpc, fs-&gt;pc, <A HREF="lopcodes.h.html#NO_REG">NO_REG</A>, fs-&gt;pc);
  fs-&gt;jpc = <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;
}


void <A NAME="luaK_patchlist"><SPAN CLASS="definition">luaK_patchlist</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int list, int target) {
  if (target == fs-&gt;pc)
    <A HREF="lcode.c.html#luaK_patchtohere">luaK_patchtohere</A>(fs, list);
  else {
    <A HREF="llimits.h.html#lua_assert">lua_assert</A>(target &lt; fs-&gt;pc);
    <A HREF="lcode.c.html#patchlistaux">patchlistaux</A>(fs, list, target, <A HREF="lopcodes.h.html#NO_REG">NO_REG</A>, target);
  }
}


void <A NAME="luaK_patchclose"><SPAN CLASS="definition">luaK_patchclose</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int list, int level) {
  level++;  /* argument is +1 to reserve 0 as non-op */
  while (list != <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>) {
    int next = <A HREF="lcode.c.html#getjump">getjump</A>(fs, list);
    <A HREF="llimits.h.html#lua_assert">lua_assert</A>(<A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(fs-&gt;f-&gt;code[list]) == <A HREF="lopcodes.h.html#OP_JMP">OP_JMP</A> &amp;&amp;
                (<A HREF="lopcodes.h.html#GETARG_A">GETARG_A</A>(fs-&gt;f-&gt;code[list]) == 0 ||
                 <A HREF="lopcodes.h.html#GETARG_A">GETARG_A</A>(fs-&gt;f-&gt;code[list]) &gt;= level));
    <A HREF="lopcodes.h.html#SETARG_A">SETARG_A</A>(fs-&gt;f-&gt;code[list], level);
    list = next;
  }
}


void <A NAME="luaK_patchtohere"><SPAN CLASS="definition">luaK_patchtohere</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int list) {
  <A HREF="lcode.c.html#luaK_getlabel">luaK_getlabel</A>(fs);
  <A HREF="lcode.c.html#luaK_concat">luaK_concat</A>(fs, &amp;fs-&gt;jpc, list);
}


void <A NAME="luaK_concat"><SPAN CLASS="definition">luaK_concat</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int *l1, int l2) {
  if (l2 == <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>) return;
  else if (*l1 == <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>)
    *l1 = l2;
  else {
    int list = *l1;
    int next;
    while ((next = <A HREF="lcode.c.html#getjump">getjump</A>(fs, list)) != <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>)  /* find last element */
      list = next;
    <A HREF="lcode.c.html#fixjump">fixjump</A>(fs, list, l2);
  }
}


static int <A NAME="luaK_code"><SPAN CLASS="definition">luaK_code</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="llimits.h.html#Instruction">Instruction</A> i) {
  <A HREF="lobject.h.html#Proto">Proto</A> *f = fs-&gt;f;
  <A HREF="lcode.c.html#dischargejpc">dischargejpc</A>(fs);  /* 'pc' will change */
  /* put new instruction in code array */
  <A HREF="lmem.h.html#luaM_growvector">luaM_growvector</A>(fs-&gt;ls-&gt;L, f-&gt;code, fs-&gt;pc, f-&gt;sizecode, <A HREF="llimits.h.html#Instruction">Instruction</A>,
                  <A HREF="llimits.h.html#MAX_INT">MAX_INT</A>, "opcodes");
  f-&gt;code[fs-&gt;pc] = i;
  /* save corresponding line information */
  <A HREF="lmem.h.html#luaM_growvector">luaM_growvector</A>(fs-&gt;ls-&gt;L, f-&gt;lineinfo, fs-&gt;pc, f-&gt;sizelineinfo, int,
                  <A HREF="llimits.h.html#MAX_INT">MAX_INT</A>, "opcodes");
  f-&gt;lineinfo[fs-&gt;pc] = fs-&gt;ls-&gt;lastline;
  return fs-&gt;pc++;
}


int <A NAME="luaK_codeABC"><SPAN CLASS="definition">luaK_codeABC</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lopcodes.h.html#OpCode">OpCode</A> o, int a, int b, int c) {
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(<A HREF="lopcodes.h.html#getOpMode">getOpMode</A>(o) == <A HREF="lopcodes.h.html#iABC">iABC</A>);
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(<A HREF="lopcodes.h.html#getBMode">getBMode</A>(o) != <A HREF="lopcodes.h.html#OpArgN">OpArgN</A> || b == 0);
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(<A HREF="lopcodes.h.html#getCMode">getCMode</A>(o) != <A HREF="lopcodes.h.html#OpArgN">OpArgN</A> || c == 0);
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(a &lt;= <A HREF="lopcodes.h.html#MAXARG_A">MAXARG_A</A> &amp;&amp; b &lt;= <A HREF="lopcodes.h.html#MAXARG_B">MAXARG_B</A> &amp;&amp; c &lt;= <A HREF="lopcodes.h.html#MAXARG_C">MAXARG_C</A>);
  return <A HREF="lcode.c.html#luaK_code">luaK_code</A>(fs, <A HREF="lopcodes.h.html#CREATE_ABC">CREATE_ABC</A>(o, a, b, c));
}


int <A NAME="luaK_codeABx"><SPAN CLASS="definition">luaK_codeABx</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lopcodes.h.html#OpCode">OpCode</A> o, int a, unsigned int bc) {
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(<A HREF="lopcodes.h.html#getOpMode">getOpMode</A>(o) == <A HREF="lopcodes.h.html#iABx">iABx</A> || <A HREF="lopcodes.h.html#getOpMode">getOpMode</A>(o) == <A HREF="lopcodes.h.html#iAsBx">iAsBx</A>);
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(<A HREF="lopcodes.h.html#getCMode">getCMode</A>(o) == <A HREF="lopcodes.h.html#OpArgN">OpArgN</A>);
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(a &lt;= <A HREF="lopcodes.h.html#MAXARG_A">MAXARG_A</A> &amp;&amp; bc &lt;= <A HREF="lopcodes.h.html#MAXARG_Bx">MAXARG_Bx</A>);
  return <A HREF="lcode.c.html#luaK_code">luaK_code</A>(fs, <A HREF="lopcodes.h.html#CREATE_ABx">CREATE_ABx</A>(o, a, bc));
}


static int <A NAME="codeextraarg"><SPAN CLASS="definition">codeextraarg</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int a) {
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(a &lt;= <A HREF="lopcodes.h.html#MAXARG_Ax">MAXARG_Ax</A>);
  return <A HREF="lcode.c.html#luaK_code">luaK_code</A>(fs, <A HREF="lopcodes.h.html#CREATE_Ax">CREATE_Ax</A>(<A HREF="lopcodes.h.html#OP_EXTRAARG">OP_EXTRAARG</A>, a));
}


int <A NAME="luaK_codek"><SPAN CLASS="definition">luaK_codek</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int reg, int k) {
  if (k &lt;= <A HREF="lopcodes.h.html#MAXARG_Bx">MAXARG_Bx</A>)
    return <A HREF="lcode.c.html#luaK_codeABx">luaK_codeABx</A>(fs, <A HREF="lopcodes.h.html#OP_LOADK">OP_LOADK</A>, reg, k);
  else {
    int p = <A HREF="lcode.c.html#luaK_codeABx">luaK_codeABx</A>(fs, <A HREF="lopcodes.h.html#OP_LOADKX">OP_LOADKX</A>, reg, 0);
    <A HREF="lcode.c.html#codeextraarg">codeextraarg</A>(fs, k);
    return p;
  }
}


void <A NAME="luaK_checkstack"><SPAN CLASS="definition">luaK_checkstack</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int n) {
  int newstack = fs-&gt;<A HREF="lcode.c.html#freereg">freereg</A> + n;
  if (newstack &gt; fs-&gt;f-&gt;maxstacksize) {
    if (newstack &gt;= <A HREF="lcode.c.html#MAXREGS">MAXREGS</A>)
      <A HREF="llex.c.html#luaX_syntaxerror">luaX_syntaxerror</A>(fs-&gt;ls,
        "function or expression needs too many registers");
    fs-&gt;f-&gt;maxstacksize = <A HREF="llimits.h.html#cast_byte">cast_byte</A>(newstack);
  }
}


void <A NAME="luaK_reserveregs"><SPAN CLASS="definition">luaK_reserveregs</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int n) {
  <A HREF="lcode.c.html#luaK_checkstack">luaK_checkstack</A>(fs, n);
  fs-&gt;<A HREF="lcode.c.html#freereg">freereg</A> += n;
}


static void <A NAME="freereg"><SPAN CLASS="definition">freereg</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int reg) {
  if (!<A HREF="lopcodes.h.html#ISK">ISK</A>(reg) &amp;&amp; reg &gt;= fs-&gt;nactvar) {
    fs-&gt;<A HREF="lcode.c.html#freereg">freereg</A>--;
    <A HREF="llimits.h.html#lua_assert">lua_assert</A>(reg == fs-&gt;<A HREF="lcode.c.html#freereg">freereg</A>);
  }
}


static void <A NAME="freeexp"><SPAN CLASS="definition">freeexp</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lparser.h.html#expdesc">expdesc</A> *e) {
  if (e-&gt;k == <A HREF="lparser.h.html#VNONRELOC">VNONRELOC</A>)
    <A HREF="lcode.c.html#freereg">freereg</A>(fs, e-&gt;u.info);
}


/*
** Use scanner's table to cache position of constants in constant list
** and try to reuse constants
*/
static int <A NAME="addk"><SPAN CLASS="definition">addk</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lobject.h.html#TValue">TValue</A> *key, <A HREF="lobject.h.html#TValue">TValue</A> *v) {
  <A HREF="lstate.h.html#lua_State">lua_State</A> *L = fs-&gt;ls-&gt;L;
  <A HREF="lobject.h.html#Proto">Proto</A> *f = fs-&gt;f;
  <A HREF="lobject.h.html#TValue">TValue</A> *idx = <A HREF="ltable.c.html#luaH_set">luaH_set</A>(L, fs-&gt;ls-&gt;h, key);  /* index scanner table */
  int k, oldsize;
  if (<A HREF="lobject.h.html#ttisinteger">ttisinteger</A>(idx)) {  /* is there an index there? */
    k = <A HREF="llimits.h.html#cast_int">cast_int</A>(<A HREF="lobject.h.html#ivalue">ivalue</A>(idx));
    /* correct value? (warning: must distinguish floats from integers!) */
    if (k &lt; fs-&gt;nk &amp;&amp; <A HREF="lobject.h.html#ttype">ttype</A>(&amp;f-&gt;k[k]) == <A HREF="lobject.h.html#ttype">ttype</A>(v) &amp;&amp;
                      <A HREF="lvm.h.html#luaV_rawequalobj">luaV_rawequalobj</A>(&amp;f-&gt;k[k], v))
      return k;  /* reuse index */
  }
  /* constant not found; create a new entry */
  oldsize = f-&gt;sizek;
  k = fs-&gt;nk;
  /* numerical value does not need GC barrier;
     table has no metatable, so it does not need to invalidate cache */
  <A HREF="lobject.h.html#setivalue">setivalue</A>(idx, k);
  <A HREF="lmem.h.html#luaM_growvector">luaM_growvector</A>(L, f-&gt;k, k, f-&gt;sizek, <A HREF="lobject.h.html#TValue">TValue</A>, <A HREF="lopcodes.h.html#MAXARG_Ax">MAXARG_Ax</A>, "constants");
  while (oldsize &lt; f-&gt;sizek) <A HREF="lobject.h.html#setnilvalue">setnilvalue</A>(&amp;f-&gt;k[oldsize++]);
  <A HREF="lobject.h.html#setobj">setobj</A>(L, &amp;f-&gt;k[k], v);
  fs-&gt;nk++;
  <A HREF="lgc.h.html#luaC_barrier">luaC_barrier</A>(L, f, v);
  return k;
}


int <A NAME="luaK_stringK"><SPAN CLASS="definition">luaK_stringK</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lobject.h.html#TString">TString</A> *s) {
  <A HREF="lobject.h.html#TValue">TValue</A> o;
  <A HREF="lobject.h.html#setsvalue">setsvalue</A>(fs-&gt;ls-&gt;L, &amp;o, s);
  return <A HREF="lcode.c.html#addk">addk</A>(fs, &amp;o, &amp;o);
}


/*
** Integers use userdata as keys to avoid collision with floats with same
** value; conversion to 'void*' used only for hashing, no "precision"
** problems
*/
int <A NAME="luaK_intK"><SPAN CLASS="definition">luaK_intK</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lua.h.html#lua_Integer">lua_Integer</A> n) {
  <A HREF="lobject.h.html#TValue">TValue</A> k, o;
  <A HREF="lobject.h.html#setpvalue">setpvalue</A>(&amp;k, <A HREF="llimits.h.html#cast">cast</A>(void*, <A HREF="llimits.h.html#cast">cast</A>(size_t, n)));
  <A HREF="lobject.h.html#setivalue">setivalue</A>(&amp;o, n);
  return <A HREF="lcode.c.html#addk">addk</A>(fs, &amp;k, &amp;o);
}


static int <A NAME="luaK_numberK"><SPAN CLASS="definition">luaK_numberK</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lua.h.html#lua_Number">lua_Number</A> r) {
  <A HREF="lobject.h.html#TValue">TValue</A> o;
  <A HREF="lobject.h.html#setfltvalue">setfltvalue</A>(&amp;o, r);
  return <A HREF="lcode.c.html#addk">addk</A>(fs, &amp;o, &amp;o);
}


static int <A NAME="boolK"><SPAN CLASS="definition">boolK</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int b) {
  <A HREF="lobject.h.html#TValue">TValue</A> o;
  <A HREF="lobject.h.html#setbvalue">setbvalue</A>(&amp;o, b);
  return <A HREF="lcode.c.html#addk">addk</A>(fs, &amp;o, &amp;o);
}


static int <A NAME="nilK"><SPAN CLASS="definition">nilK</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs) {
  <A HREF="lobject.h.html#TValue">TValue</A> k, v;
  <A HREF="lobject.h.html#setnilvalue">setnilvalue</A>(&amp;v);
  /* cannot use nil as key; instead use table itself to represent nil */
  <A HREF="lobject.h.html#sethvalue">sethvalue</A>(fs-&gt;ls-&gt;L, &amp;k, fs-&gt;ls-&gt;h);
  return <A HREF="lcode.c.html#addk">addk</A>(fs, &amp;k, &amp;v);
}


void <A NAME="luaK_setreturns"><SPAN CLASS="definition">luaK_setreturns</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lparser.h.html#expdesc">expdesc</A> *e, int nresults) {
  if (e-&gt;k == <A HREF="lparser.h.html#VCALL">VCALL</A>) {  /* expression is an open function call? */
    <A HREF="lopcodes.h.html#SETARG_C">SETARG_C</A>(<A HREF="lcode.h.html#getcode">getcode</A>(fs, e), nresults+1);
  }
  else if (e-&gt;k == <A HREF="lparser.h.html#VVARARG">VVARARG</A>) {
    <A HREF="lopcodes.h.html#SETARG_B">SETARG_B</A>(<A HREF="lcode.h.html#getcode">getcode</A>(fs, e), nresults+1);
    <A HREF="lopcodes.h.html#SETARG_A">SETARG_A</A>(<A HREF="lcode.h.html#getcode">getcode</A>(fs, e), fs-&gt;<A HREF="lcode.c.html#freereg">freereg</A>);
    <A HREF="lcode.c.html#luaK_reserveregs">luaK_reserveregs</A>(fs, 1);
  }
}


void <A NAME="luaK_setoneret"><SPAN CLASS="definition">luaK_setoneret</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lparser.h.html#expdesc">expdesc</A> *e) {
  if (e-&gt;k == <A HREF="lparser.h.html#VCALL">VCALL</A>) {  /* expression is an open function call? */
    e-&gt;k = <A HREF="lparser.h.html#VNONRELOC">VNONRELOC</A>;
    e-&gt;u.info = <A HREF="lopcodes.h.html#GETARG_A">GETARG_A</A>(<A HREF="lcode.h.html#getcode">getcode</A>(fs, e));
  }
  else if (e-&gt;k == <A HREF="lparser.h.html#VVARARG">VVARARG</A>) {
    <A HREF="lopcodes.h.html#SETARG_B">SETARG_B</A>(<A HREF="lcode.h.html#getcode">getcode</A>(fs, e), 2);
    e-&gt;k = <A HREF="lparser.h.html#VRELOCABLE">VRELOCABLE</A>;  /* can relocate its simple result */
  }
}


void <A NAME="luaK_dischargevars"><SPAN CLASS="definition">luaK_dischargevars</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lparser.h.html#expdesc">expdesc</A> *e) {
  switch (e-&gt;k) {
    case <A HREF="lparser.h.html#VLOCAL">VLOCAL</A>: {
      e-&gt;k = <A HREF="lparser.h.html#VNONRELOC">VNONRELOC</A>;
      break;
    }
    case <A HREF="lparser.h.html#VUPVAL">VUPVAL</A>: {
      e-&gt;u.info = <A HREF="lcode.c.html#luaK_codeABC">luaK_codeABC</A>(fs, <A HREF="lopcodes.h.html#OP_GETUPVAL">OP_GETUPVAL</A>, 0, e-&gt;u.info, 0);
      e-&gt;k = <A HREF="lparser.h.html#VRELOCABLE">VRELOCABLE</A>;
      break;
    }
    case <A HREF="lparser.h.html#VINDEXED">VINDEXED</A>: {
      <A HREF="lopcodes.h.html#OpCode">OpCode</A> op = <A HREF="lopcodes.h.html#OP_GETTABUP">OP_GETTABUP</A>;  /* assume 't' is in an upvalue */
      <A HREF="lcode.c.html#freereg">freereg</A>(fs, e-&gt;u.ind.idx);
      if (e-&gt;u.ind.vt == <A HREF="lparser.h.html#VLOCAL">VLOCAL</A>) {  /* 't' is in a register? */
        <A HREF="lcode.c.html#freereg">freereg</A>(fs, e-&gt;u.ind.t);
        op = <A HREF="lopcodes.h.html#OP_GETTABLE">OP_GETTABLE</A>;
      }
      e-&gt;u.info = <A HREF="lcode.c.html#luaK_codeABC">luaK_codeABC</A>(fs, op, 0, e-&gt;u.ind.t, e-&gt;u.ind.idx);
      e-&gt;k = <A HREF="lparser.h.html#VRELOCABLE">VRELOCABLE</A>;
      break;
    }
    case <A HREF="lparser.h.html#VVARARG">VVARARG</A>:
    case <A HREF="lparser.h.html#VCALL">VCALL</A>: {
      <A HREF="lcode.c.html#luaK_setoneret">luaK_setoneret</A>(fs, e);
      break;
    }
    default: break;  /* there is one value available (somewhere) */
  }
}


static int <A NAME="code_label"><SPAN CLASS="definition">code_label</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int A, int b, int jump) {
  <A HREF="lcode.c.html#luaK_getlabel">luaK_getlabel</A>(fs);  /* those instructions may be jump targets */
  return <A HREF="lcode.c.html#luaK_codeABC">luaK_codeABC</A>(fs, <A HREF="lopcodes.h.html#OP_LOADBOOL">OP_LOADBOOL</A>, A, b, jump);
}


static void <A NAME="discharge2reg"><SPAN CLASS="definition">discharge2reg</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lparser.h.html#expdesc">expdesc</A> *e, int reg) {
  <A HREF="lcode.c.html#luaK_dischargevars">luaK_dischargevars</A>(fs, e);
  switch (e-&gt;k) {
    case <A HREF="lparser.h.html#VNIL">VNIL</A>: {
      <A HREF="lcode.c.html#luaK_nil">luaK_nil</A>(fs, reg, 1);
      break;
    }
    case <A HREF="lparser.h.html#VFALSE">VFALSE</A>: case <A HREF="lparser.h.html#VTRUE">VTRUE</A>: {
      <A HREF="lcode.c.html#luaK_codeABC">luaK_codeABC</A>(fs, <A HREF="lopcodes.h.html#OP_LOADBOOL">OP_LOADBOOL</A>, reg, e-&gt;k == <A HREF="lparser.h.html#VTRUE">VTRUE</A>, 0);
      break;
    }
    case <A HREF="lparser.h.html#VK">VK</A>: {
      <A HREF="lcode.c.html#luaK_codek">luaK_codek</A>(fs, reg, e-&gt;u.info);
      break;
    }
    case <A HREF="lparser.h.html#VKFLT">VKFLT</A>: {
      <A HREF="lcode.c.html#luaK_codek">luaK_codek</A>(fs, reg, <A HREF="lcode.c.html#luaK_numberK">luaK_numberK</A>(fs, e-&gt;u.nval));
      break;
    }
    case <A HREF="lparser.h.html#VKINT">VKINT</A>: {
      <A HREF="lcode.c.html#luaK_codek">luaK_codek</A>(fs, reg, <A HREF="lcode.c.html#luaK_intK">luaK_intK</A>(fs, e-&gt;u.ival));
      break;
    }
    case <A HREF="lparser.h.html#VRELOCABLE">VRELOCABLE</A>: {
      <A HREF="llimits.h.html#Instruction">Instruction</A> *pc = &amp;<A HREF="lcode.h.html#getcode">getcode</A>(fs, e);
      <A HREF="lopcodes.h.html#SETARG_A">SETARG_A</A>(*pc, reg);
      break;
    }
    case <A HREF="lparser.h.html#VNONRELOC">VNONRELOC</A>: {
      if (reg != e-&gt;u.info)
        <A HREF="lcode.c.html#luaK_codeABC">luaK_codeABC</A>(fs, <A HREF="lopcodes.h.html#OP_MOVE">OP_MOVE</A>, reg, e-&gt;u.info, 0);
      break;
    }
    default: {
      <A HREF="llimits.h.html#lua_assert">lua_assert</A>(e-&gt;k == <A HREF="lparser.h.html#VVOID">VVOID</A> || e-&gt;k == <A HREF="lparser.h.html#VJMP">VJMP</A>);
      return;  /* nothing to do... */
    }
  }
  e-&gt;u.info = reg;
  e-&gt;k = <A HREF="lparser.h.html#VNONRELOC">VNONRELOC</A>;
}


static void <A NAME="discharge2anyreg"><SPAN CLASS="definition">discharge2anyreg</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lparser.h.html#expdesc">expdesc</A> *e) {
  if (e-&gt;k != <A HREF="lparser.h.html#VNONRELOC">VNONRELOC</A>) {
    <A HREF="lcode.c.html#luaK_reserveregs">luaK_reserveregs</A>(fs, 1);
    <A HREF="lcode.c.html#discharge2reg">discharge2reg</A>(fs, e, fs-&gt;<A HREF="lcode.c.html#freereg">freereg</A>-1);
  }
}


static void <A NAME="exp2reg"><SPAN CLASS="definition">exp2reg</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lparser.h.html#expdesc">expdesc</A> *e, int reg) {
  <A HREF="lcode.c.html#discharge2reg">discharge2reg</A>(fs, e, reg);
  if (e-&gt;k == <A HREF="lparser.h.html#VJMP">VJMP</A>)
    <A HREF="lcode.c.html#luaK_concat">luaK_concat</A>(fs, &amp;e-&gt;t, e-&gt;u.info);  /* put this jump in 't' list */
  if (<A HREF="lcode.c.html#hasjumps">hasjumps</A>(e)) {
    int final;  /* position after whole expression */
    int p_f = <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;  /* position of an eventual LOAD false */
    int p_t = <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;  /* position of an eventual LOAD true */
    if (<A HREF="lcode.c.html#need_value">need_value</A>(fs, e-&gt;t) || <A HREF="lcode.c.html#need_value">need_value</A>(fs, e-&gt;f)) {
      int fj = (e-&gt;k == <A HREF="lparser.h.html#VJMP">VJMP</A>) ? <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A> : <A HREF="lcode.c.html#luaK_jump">luaK_jump</A>(fs);
      p_f = <A HREF="lcode.c.html#code_label">code_label</A>(fs, reg, 0, 1);
      p_t = <A HREF="lcode.c.html#code_label">code_label</A>(fs, reg, 1, 0);
      <A HREF="lcode.c.html#luaK_patchtohere">luaK_patchtohere</A>(fs, fj);
    }
    final = <A HREF="lcode.c.html#luaK_getlabel">luaK_getlabel</A>(fs);
    <A HREF="lcode.c.html#patchlistaux">patchlistaux</A>(fs, e-&gt;f, final, reg, p_f);
    <A HREF="lcode.c.html#patchlistaux">patchlistaux</A>(fs, e-&gt;t, final, reg, p_t);
  }
  e-&gt;f = e-&gt;t = <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;
  e-&gt;u.info = reg;
  e-&gt;k = <A HREF="lparser.h.html#VNONRELOC">VNONRELOC</A>;
}


void <A NAME="luaK_exp2nextreg"><SPAN CLASS="definition">luaK_exp2nextreg</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lparser.h.html#expdesc">expdesc</A> *e) {
  <A HREF="lcode.c.html#luaK_dischargevars">luaK_dischargevars</A>(fs, e);
  <A HREF="lcode.c.html#freeexp">freeexp</A>(fs, e);
  <A HREF="lcode.c.html#luaK_reserveregs">luaK_reserveregs</A>(fs, 1);
  <A HREF="lcode.c.html#exp2reg">exp2reg</A>(fs, e, fs-&gt;<A HREF="lcode.c.html#freereg">freereg</A> - 1);
}


int <A NAME="luaK_exp2anyreg"><SPAN CLASS="definition">luaK_exp2anyreg</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lparser.h.html#expdesc">expdesc</A> *e) {
  <A HREF="lcode.c.html#luaK_dischargevars">luaK_dischargevars</A>(fs, e);
  if (e-&gt;k == <A HREF="lparser.h.html#VNONRELOC">VNONRELOC</A>) {
    if (!<A HREF="lcode.c.html#hasjumps">hasjumps</A>(e)) return e-&gt;u.info;  /* exp is already in a register */
    if (e-&gt;u.info &gt;= fs-&gt;nactvar) {  /* reg. is not a local? */
      <A HREF="lcode.c.html#exp2reg">exp2reg</A>(fs, e, e-&gt;u.info);  /* put value on it */
      return e-&gt;u.info;
    }
  }
  <A HREF="lcode.c.html#luaK_exp2nextreg">luaK_exp2nextreg</A>(fs, e);  /* default */
  return e-&gt;u.info;
}


void <A NAME="luaK_exp2anyregup"><SPAN CLASS="definition">luaK_exp2anyregup</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lparser.h.html#expdesc">expdesc</A> *e) {
  if (e-&gt;k != <A HREF="lparser.h.html#VUPVAL">VUPVAL</A> || <A HREF="lcode.c.html#hasjumps">hasjumps</A>(e))
    <A HREF="lcode.c.html#luaK_exp2anyreg">luaK_exp2anyreg</A>(fs, e);
}


void <A NAME="luaK_exp2val"><SPAN CLASS="definition">luaK_exp2val</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lparser.h.html#expdesc">expdesc</A> *e) {
  if (<A HREF="lcode.c.html#hasjumps">hasjumps</A>(e))
    <A HREF="lcode.c.html#luaK_exp2anyreg">luaK_exp2anyreg</A>(fs, e);
  else
    <A HREF="lcode.c.html#luaK_dischargevars">luaK_dischargevars</A>(fs, e);
}


int <A NAME="luaK_exp2RK"><SPAN CLASS="definition">luaK_exp2RK</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lparser.h.html#expdesc">expdesc</A> *e) {
  <A HREF="lcode.c.html#luaK_exp2val">luaK_exp2val</A>(fs, e);
  switch (e-&gt;k) {
    case <A HREF="lparser.h.html#VTRUE">VTRUE</A>:
    case <A HREF="lparser.h.html#VFALSE">VFALSE</A>:
    case <A HREF="lparser.h.html#VNIL">VNIL</A>: {
      if (fs-&gt;nk &lt;= <A HREF="lopcodes.h.html#MAXINDEXRK">MAXINDEXRK</A>) {  /* constant fits in RK operand? */
        e-&gt;u.info = (e-&gt;k == <A HREF="lparser.h.html#VNIL">VNIL</A>) ? <A HREF="lcode.c.html#nilK">nilK</A>(fs) : <A HREF="lcode.c.html#boolK">boolK</A>(fs, (e-&gt;k == <A HREF="lparser.h.html#VTRUE">VTRUE</A>));
        e-&gt;k = <A HREF="lparser.h.html#VK">VK</A>;
        return <A HREF="lopcodes.h.html#RKASK">RKASK</A>(e-&gt;u.info);
      }
      else break;
    }
    case <A HREF="lparser.h.html#VKINT">VKINT</A>: {
      e-&gt;u.info = <A HREF="lcode.c.html#luaK_intK">luaK_intK</A>(fs, e-&gt;u.ival);
      e-&gt;k = <A HREF="lparser.h.html#VK">VK</A>;
      goto vk;
    }
    case <A HREF="lparser.h.html#VKFLT">VKFLT</A>: {
      e-&gt;u.info = <A HREF="lcode.c.html#luaK_numberK">luaK_numberK</A>(fs, e-&gt;u.nval);
      e-&gt;k = <A HREF="lparser.h.html#VK">VK</A>;
    }
    /* FALLTHROUGH */
    case <A HREF="lparser.h.html#VK">VK</A>: {
     vk:
      if (e-&gt;u.info &lt;= <A HREF="lopcodes.h.html#MAXINDEXRK">MAXINDEXRK</A>)  /* constant fits in 'argC'? */
        return <A HREF="lopcodes.h.html#RKASK">RKASK</A>(e-&gt;u.info);
      else break;
    }
    default: break;
  }
  /* not a constant in the right range: put it in a register */
  return <A HREF="lcode.c.html#luaK_exp2anyreg">luaK_exp2anyreg</A>(fs, e);
}


void <A NAME="luaK_storevar"><SPAN CLASS="definition">luaK_storevar</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lparser.h.html#expdesc">expdesc</A> *var, <A HREF="lparser.h.html#expdesc">expdesc</A> *ex) {
  switch (var-&gt;k) {
    case <A HREF="lparser.h.html#VLOCAL">VLOCAL</A>: {
      <A HREF="lcode.c.html#freeexp">freeexp</A>(fs, ex);
      <A HREF="lcode.c.html#exp2reg">exp2reg</A>(fs, ex, var-&gt;u.info);
      return;
    }
    case <A HREF="lparser.h.html#VUPVAL">VUPVAL</A>: {
      int e = <A HREF="lcode.c.html#luaK_exp2anyreg">luaK_exp2anyreg</A>(fs, ex);
      <A HREF="lcode.c.html#luaK_codeABC">luaK_codeABC</A>(fs, <A HREF="lopcodes.h.html#OP_SETUPVAL">OP_SETUPVAL</A>, e, var-&gt;u.info, 0);
      break;
    }
    case <A HREF="lparser.h.html#VINDEXED">VINDEXED</A>: {
      <A HREF="lopcodes.h.html#OpCode">OpCode</A> op = (var-&gt;u.ind.vt == <A HREF="lparser.h.html#VLOCAL">VLOCAL</A>) ? <A HREF="lopcodes.h.html#OP_SETTABLE">OP_SETTABLE</A> : <A HREF="lopcodes.h.html#OP_SETTABUP">OP_SETTABUP</A>;
      int e = <A HREF="lcode.c.html#luaK_exp2RK">luaK_exp2RK</A>(fs, ex);
      <A HREF="lcode.c.html#luaK_codeABC">luaK_codeABC</A>(fs, op, var-&gt;u.ind.t, var-&gt;u.ind.idx, e);
      break;
    }
    default: {
      <A HREF="llimits.h.html#lua_assert">lua_assert</A>(0);  /* invalid var kind to store */
      break;
    }
  }
  <A HREF="lcode.c.html#freeexp">freeexp</A>(fs, ex);
}


void <A NAME="luaK_self"><SPAN CLASS="definition">luaK_self</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lparser.h.html#expdesc">expdesc</A> *e, <A HREF="lparser.h.html#expdesc">expdesc</A> *key) {
  int ereg;
  <A HREF="lcode.c.html#luaK_exp2anyreg">luaK_exp2anyreg</A>(fs, e);
  ereg = e-&gt;u.info;  /* register where 'e' was placed */
  <A HREF="lcode.c.html#freeexp">freeexp</A>(fs, e);
  e-&gt;u.info = fs-&gt;<A HREF="lcode.c.html#freereg">freereg</A>;  /* base register for op_self */
  e-&gt;k = <A HREF="lparser.h.html#VNONRELOC">VNONRELOC</A>;
  <A HREF="lcode.c.html#luaK_reserveregs">luaK_reserveregs</A>(fs, 2);  /* function and 'self' produced by op_self */
  <A HREF="lcode.c.html#luaK_codeABC">luaK_codeABC</A>(fs, <A HREF="lopcodes.h.html#OP_SELF">OP_SELF</A>, e-&gt;u.info, ereg, <A HREF="lcode.c.html#luaK_exp2RK">luaK_exp2RK</A>(fs, key));
  <A HREF="lcode.c.html#freeexp">freeexp</A>(fs, key);
}


static void <A NAME="invertjump"><SPAN CLASS="definition">invertjump</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lparser.h.html#expdesc">expdesc</A> *e) {
  <A HREF="llimits.h.html#Instruction">Instruction</A> *pc = <A HREF="lcode.c.html#getjumpcontrol">getjumpcontrol</A>(fs, e-&gt;u.info);
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(<A HREF="lopcodes.h.html#testTMode">testTMode</A>(<A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(*pc)) &amp;&amp; <A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(*pc) != <A HREF="lopcodes.h.html#OP_TESTSET">OP_TESTSET</A> &amp;&amp;
                                           <A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(*pc) != <A HREF="lopcodes.h.html#OP_TEST">OP_TEST</A>);
  <A HREF="lopcodes.h.html#SETARG_A">SETARG_A</A>(*pc, !(<A HREF="lopcodes.h.html#GETARG_A">GETARG_A</A>(*pc)));
}


static int <A NAME="jumponcond"><SPAN CLASS="definition">jumponcond</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lparser.h.html#expdesc">expdesc</A> *e, int cond) {
  if (e-&gt;k == <A HREF="lparser.h.html#VRELOCABLE">VRELOCABLE</A>) {
    <A HREF="llimits.h.html#Instruction">Instruction</A> ie = <A HREF="lcode.h.html#getcode">getcode</A>(fs, e);
    if (<A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(ie) == <A HREF="lopcodes.h.html#OP_NOT">OP_NOT</A>) {
      fs-&gt;pc--;  /* remove previous <A HREF="lopcodes.h.html#OP_NOT">OP_NOT</A> */
      return <A HREF="lcode.c.html#condjump">condjump</A>(fs, <A HREF="lopcodes.h.html#OP_TEST">OP_TEST</A>, <A HREF="lopcodes.h.html#GETARG_B">GETARG_B</A>(ie), 0, !cond);
    }
    /* else go through */
  }
  <A HREF="lcode.c.html#discharge2anyreg">discharge2anyreg</A>(fs, e);
  <A HREF="lcode.c.html#freeexp">freeexp</A>(fs, e);
  return <A HREF="lcode.c.html#condjump">condjump</A>(fs, <A HREF="lopcodes.h.html#OP_TESTSET">OP_TESTSET</A>, <A HREF="lopcodes.h.html#NO_REG">NO_REG</A>, e-&gt;u.info, cond);
}


void <A NAME="luaK_goiftrue"><SPAN CLASS="definition">luaK_goiftrue</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lparser.h.html#expdesc">expdesc</A> *e) {
  int pc;  /* pc of last jump */
  <A HREF="lcode.c.html#luaK_dischargevars">luaK_dischargevars</A>(fs, e);
  switch (e-&gt;k) {
    case <A HREF="lparser.h.html#VJMP">VJMP</A>: {
      <A HREF="lcode.c.html#invertjump">invertjump</A>(fs, e);
      pc = e-&gt;u.info;
      break;
    }
    case <A HREF="lparser.h.html#VK">VK</A>: case <A HREF="lparser.h.html#VKFLT">VKFLT</A>: case <A HREF="lparser.h.html#VKINT">VKINT</A>: case <A HREF="lparser.h.html#VTRUE">VTRUE</A>: {
      pc = <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;  /* always true; do nothing */
      break;
    }
    default: {
      pc = <A HREF="lcode.c.html#jumponcond">jumponcond</A>(fs, e, 0);
      break;
    }
  }
  <A HREF="lcode.c.html#luaK_concat">luaK_concat</A>(fs, &amp;e-&gt;f, pc);  /* insert last jump in 'f' list */
  <A HREF="lcode.c.html#luaK_patchtohere">luaK_patchtohere</A>(fs, e-&gt;t);
  e-&gt;t = <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;
}


void <A NAME="luaK_goiffalse"><SPAN CLASS="definition">luaK_goiffalse</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lparser.h.html#expdesc">expdesc</A> *e) {
  int pc;  /* pc of last jump */
  <A HREF="lcode.c.html#luaK_dischargevars">luaK_dischargevars</A>(fs, e);
  switch (e-&gt;k) {
    case <A HREF="lparser.h.html#VJMP">VJMP</A>: {
      pc = e-&gt;u.info;
      break;
    }
    case <A HREF="lparser.h.html#VNIL">VNIL</A>: case <A HREF="lparser.h.html#VFALSE">VFALSE</A>: {
      pc = <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;  /* always false; do nothing */
      break;
    }
    default: {
      pc = <A HREF="lcode.c.html#jumponcond">jumponcond</A>(fs, e, 1);
      break;
    }
  }
  <A HREF="lcode.c.html#luaK_concat">luaK_concat</A>(fs, &amp;e-&gt;t, pc);  /* insert last jump in 't' list */
  <A HREF="lcode.c.html#luaK_patchtohere">luaK_patchtohere</A>(fs, e-&gt;f);
  e-&gt;f = <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;
}


static void <A NAME="codenot"><SPAN CLASS="definition">codenot</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lparser.h.html#expdesc">expdesc</A> *e) {
  <A HREF="lcode.c.html#luaK_dischargevars">luaK_dischargevars</A>(fs, e);
  switch (e-&gt;k) {
    case <A HREF="lparser.h.html#VNIL">VNIL</A>: case <A HREF="lparser.h.html#VFALSE">VFALSE</A>: {
      e-&gt;k = <A HREF="lparser.h.html#VTRUE">VTRUE</A>;
      break;
    }
    case <A HREF="lparser.h.html#VK">VK</A>: case <A HREF="lparser.h.html#VKFLT">VKFLT</A>: case <A HREF="lparser.h.html#VKINT">VKINT</A>: case <A HREF="lparser.h.html#VTRUE">VTRUE</A>: {
      e-&gt;k = <A HREF="lparser.h.html#VFALSE">VFALSE</A>;
      break;
    }
    case <A HREF="lparser.h.html#VJMP">VJMP</A>: {
      <A HREF="lcode.c.html#invertjump">invertjump</A>(fs, e);
      break;
    }
    case <A HREF="lparser.h.html#VRELOCABLE">VRELOCABLE</A>:
    case <A HREF="lparser.h.html#VNONRELOC">VNONRELOC</A>: {
      <A HREF="lcode.c.html#discharge2anyreg">discharge2anyreg</A>(fs, e);
      <A HREF="lcode.c.html#freeexp">freeexp</A>(fs, e);
      e-&gt;u.info = <A HREF="lcode.c.html#luaK_codeABC">luaK_codeABC</A>(fs, <A HREF="lopcodes.h.html#OP_NOT">OP_NOT</A>, 0, e-&gt;u.info, 0);
      e-&gt;k = <A HREF="lparser.h.html#VRELOCABLE">VRELOCABLE</A>;
      break;
    }
    default: {
      <A HREF="llimits.h.html#lua_assert">lua_assert</A>(0);  /* cannot happen */
      break;
    }
  }
  /* interchange true and false lists */
  { int temp = e-&gt;f; e-&gt;f = e-&gt;t; e-&gt;t = temp; }
  <A HREF="lcode.c.html#removevalues">removevalues</A>(fs, e-&gt;f);
  <A HREF="lcode.c.html#removevalues">removevalues</A>(fs, e-&gt;t);
}


void <A NAME="luaK_indexed"><SPAN CLASS="definition">luaK_indexed</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lparser.h.html#expdesc">expdesc</A> *t, <A HREF="lparser.h.html#expdesc">expdesc</A> *k) {
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(!<A HREF="lcode.c.html#hasjumps">hasjumps</A>(t));
  t-&gt;u.ind.t = t-&gt;u.info;
  t-&gt;u.ind.idx = <A HREF="lcode.c.html#luaK_exp2RK">luaK_exp2RK</A>(fs, k);
  t-&gt;u.ind.vt = (t-&gt;k == <A HREF="lparser.h.html#VUPVAL">VUPVAL</A>) ? <A HREF="lparser.h.html#VUPVAL">VUPVAL</A>
                                 : <A HREF="llimits.h.html#check_exp">check_exp</A>(<A HREF="lparser.h.html#vkisinreg">vkisinreg</A>(t-&gt;k), <A HREF="lparser.h.html#VLOCAL">VLOCAL</A>);
  t-&gt;k = <A HREF="lparser.h.html#VINDEXED">VINDEXED</A>;
}


/*
** return false if folding can raise an error
*/
static int <A NAME="validop"><SPAN CLASS="definition">validop</SPAN></A> (int op, <A HREF="lobject.h.html#TValue">TValue</A> *v1, <A HREF="lobject.h.html#TValue">TValue</A> *v2) {
  switch (op) {
    case <A HREF="lua.h.html#LUA_OPBAND">LUA_OPBAND</A>: case <A HREF="lua.h.html#LUA_OPBOR">LUA_OPBOR</A>: case <A HREF="lua.h.html#LUA_OPBXOR">LUA_OPBXOR</A>:
    case <A HREF="lua.h.html#LUA_OPSHL">LUA_OPSHL</A>: case <A HREF="lua.h.html#LUA_OPSHR">LUA_OPSHR</A>: case <A HREF="lua.h.html#LUA_OPBNOT">LUA_OPBNOT</A>: {  /* conversion errors */
      <A HREF="lua.h.html#lua_Integer">lua_Integer</A> i;
      return (<A HREF="lvm.h.html#tointeger">tointeger</A>(v1, &amp;i) &amp;&amp; <A HREF="lvm.h.html#tointeger">tointeger</A>(v2, &amp;i));
    }
    case <A HREF="lua.h.html#LUA_OPDIV">LUA_OPDIV</A>: case <A HREF="lua.h.html#LUA_OPIDIV">LUA_OPIDIV</A>: case <A HREF="lua.h.html#LUA_OPMOD">LUA_OPMOD</A>:  /* division by 0 */
      return (<A HREF="lobject.h.html#nvalue">nvalue</A>(v2) != 0);
    default: return 1;  /* everything else is valid */
  }
}


/*
** Try to "constant-fold" an operation; return 1 iff successful
*/
static int <A NAME="constfolding"><SPAN CLASS="definition">constfolding</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int op, <A HREF="lparser.h.html#expdesc">expdesc</A> *e1, <A HREF="lparser.h.html#expdesc">expdesc</A> *e2) {
  <A HREF="lobject.h.html#TValue">TValue</A> v1, v2, res;
  if (!<A HREF="lcode.c.html#tonumeral">tonumeral</A>(e1, &amp;v1) || !<A HREF="lcode.c.html#tonumeral">tonumeral</A>(e2, &amp;v2) || !<A HREF="lcode.c.html#validop">validop</A>(op, &amp;v1, &amp;v2))
    return 0;  /* non-numeric operands or not safe to fold */
  <A HREF="lobject.c.html#luaO_arith">luaO_arith</A>(fs-&gt;ls-&gt;L, op, &amp;v1, &amp;v2, &amp;res);  /* does operation */
  if (<A HREF="lobject.h.html#ttisinteger">ttisinteger</A>(&amp;res)) {
    e1-&gt;k = <A HREF="lparser.h.html#VKINT">VKINT</A>;
    e1-&gt;u.ival = <A HREF="lobject.h.html#ivalue">ivalue</A>(&amp;res);
  }
  else {  /* folds neither NaN nor 0.0 (to avoid collapsing with -0.0) */
    <A HREF="lua.h.html#lua_Number">lua_Number</A> n = <A HREF="lobject.h.html#fltvalue">fltvalue</A>(&amp;res);
    if (<A HREF="llimits.h.html#luai_numisnan">luai_numisnan</A>(n) || n == 0)
      return 0;
    e1-&gt;k = <A HREF="lparser.h.html#VKFLT">VKFLT</A>;
    e1-&gt;u.nval = n;
  }
  return 1;
}


/*
** Code for binary and unary expressions that "produce values"
** (arithmetic operations, bitwise operations, concat, length). First
** try to do constant folding (only for numeric [arithmetic and
** bitwise] operations, which is what '<A HREF="lapi.c.html#lua_arith">lua_arith</A>' accepts).
** Expression to produce final result will be encoded in 'e1'.
*/
static void <A NAME="codeexpval"><SPAN CLASS="definition">codeexpval</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lopcodes.h.html#OpCode">OpCode</A> op,
                        <A HREF="lparser.h.html#expdesc">expdesc</A> *e1, <A HREF="lparser.h.html#expdesc">expdesc</A> *e2, int line) {
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(op &gt;= <A HREF="lopcodes.h.html#OP_ADD">OP_ADD</A>);
  if (op &lt;= <A HREF="lopcodes.h.html#OP_BNOT">OP_BNOT</A> &amp;&amp; <A HREF="lcode.c.html#constfolding">constfolding</A>(fs, (op - <A HREF="lopcodes.h.html#OP_ADD">OP_ADD</A>) + <A HREF="lua.h.html#LUA_OPADD">LUA_OPADD</A>, e1, e2))
    return;  /* result has been folded */
  else {
    int o1, o2;
    /* move operands to registers (if needed) */
    if (op == <A HREF="lopcodes.h.html#OP_UNM">OP_UNM</A> || op == <A HREF="lopcodes.h.html#OP_BNOT">OP_BNOT</A> || op == <A HREF="lopcodes.h.html#OP_LEN">OP_LEN</A>) {  /* unary op? */
      o2 = 0;  /* no second expression */
      o1 = <A HREF="lcode.c.html#luaK_exp2anyreg">luaK_exp2anyreg</A>(fs, e1);  /* cannot operate on constants */
    }
    else {  /* regular case (binary operators) */
      o2 = <A HREF="lcode.c.html#luaK_exp2RK">luaK_exp2RK</A>(fs, e2);  /* both operands are "RK" */
      o1 = <A HREF="lcode.c.html#luaK_exp2RK">luaK_exp2RK</A>(fs, e1);
    }
    if (o1 &gt; o2) {  /* free registers in proper order */
      <A HREF="lcode.c.html#freeexp">freeexp</A>(fs, e1);
      <A HREF="lcode.c.html#freeexp">freeexp</A>(fs, e2);
    }
    else {
      <A HREF="lcode.c.html#freeexp">freeexp</A>(fs, e2);
      <A HREF="lcode.c.html#freeexp">freeexp</A>(fs, e1);
    }
    e1-&gt;u.info = <A HREF="lcode.c.html#luaK_codeABC">luaK_codeABC</A>(fs, op, 0, o1, o2);  /* generate opcode */
    e1-&gt;k = <A HREF="lparser.h.html#VRELOCABLE">VRELOCABLE</A>;  /* all those operations are relocatable */
    <A HREF="lcode.c.html#luaK_fixline">luaK_fixline</A>(fs, line);
  }
}


static void <A NAME="codecomp"><SPAN CLASS="definition">codecomp</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lopcodes.h.html#OpCode">OpCode</A> op, int cond, <A HREF="lparser.h.html#expdesc">expdesc</A> *e1,
                                                          <A HREF="lparser.h.html#expdesc">expdesc</A> *e2) {
  int o1 = <A HREF="lcode.c.html#luaK_exp2RK">luaK_exp2RK</A>(fs, e1);
  int o2 = <A HREF="lcode.c.html#luaK_exp2RK">luaK_exp2RK</A>(fs, e2);
  <A HREF="lcode.c.html#freeexp">freeexp</A>(fs, e2);
  <A HREF="lcode.c.html#freeexp">freeexp</A>(fs, e1);
  if (cond == 0 &amp;&amp; op != <A HREF="lopcodes.h.html#OP_EQ">OP_EQ</A>) {
    int temp;  /* exchange args to replace by '&lt;' or '&lt;=' */
    temp = o1; o1 = o2; o2 = temp;  /* o1 &lt;==&gt; o2 */
    cond = 1;
  }
  e1-&gt;u.info = <A HREF="lcode.c.html#condjump">condjump</A>(fs, op, cond, o1, o2);
  e1-&gt;k = <A HREF="lparser.h.html#VJMP">VJMP</A>;
}


void <A NAME="luaK_prefix"><SPAN CLASS="definition">luaK_prefix</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lcode.h.html#UnOpr">UnOpr</A> op, <A HREF="lparser.h.html#expdesc">expdesc</A> *e, int line) {
  <A HREF="lparser.h.html#expdesc">expdesc</A> e2;
  e2.t = e2.f = <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>; e2.k = <A HREF="lparser.h.html#VKINT">VKINT</A>; e2.u.ival = 0;
  switch (op) {
    case <A HREF="lcode.h.html#OPR_MINUS">OPR_MINUS</A>: case <A HREF="lcode.h.html#OPR_BNOT">OPR_BNOT</A>: case <A HREF="lcode.h.html#OPR_LEN">OPR_LEN</A>: {
      <A HREF="lcode.c.html#codeexpval">codeexpval</A>(fs, <A HREF="llimits.h.html#cast">cast</A>(<A HREF="lopcodes.h.html#OpCode">OpCode</A>, (op - <A HREF="lcode.h.html#OPR_MINUS">OPR_MINUS</A>) + <A HREF="lopcodes.h.html#OP_UNM">OP_UNM</A>), e, &amp;e2, line);
      break;
    }
    case <A HREF="lcode.h.html#OPR_NOT">OPR_NOT</A>: <A HREF="lcode.c.html#codenot">codenot</A>(fs, e); break;
    default: <A HREF="llimits.h.html#lua_assert">lua_assert</A>(0);
  }
}


void <A NAME="luaK_infix"><SPAN CLASS="definition">luaK_infix</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lcode.h.html#BinOpr">BinOpr</A> op, <A HREF="lparser.h.html#expdesc">expdesc</A> *v) {
  switch (op) {
    case <A HREF="lcode.h.html#OPR_AND">OPR_AND</A>: {
      <A HREF="lcode.c.html#luaK_goiftrue">luaK_goiftrue</A>(fs, v);
      break;
    }
    case <A HREF="lcode.h.html#OPR_OR">OPR_OR</A>: {
      <A HREF="lcode.c.html#luaK_goiffalse">luaK_goiffalse</A>(fs, v);
      break;
    }
    case <A HREF="lcode.h.html#OPR_CONCAT">OPR_CONCAT</A>: {
      <A HREF="lcode.c.html#luaK_exp2nextreg">luaK_exp2nextreg</A>(fs, v);  /* operand must be on the 'stack' */
      break;
    }
    case <A HREF="lcode.h.html#OPR_ADD">OPR_ADD</A>: case <A HREF="lcode.h.html#OPR_SUB">OPR_SUB</A>:
    case <A HREF="lcode.h.html#OPR_MUL">OPR_MUL</A>: case <A HREF="lcode.h.html#OPR_DIV">OPR_DIV</A>: case <A HREF="lcode.h.html#OPR_IDIV">OPR_IDIV</A>:
    case <A HREF="lcode.h.html#OPR_MOD">OPR_MOD</A>: case <A HREF="lcode.h.html#OPR_POW">OPR_POW</A>:
    case <A HREF="lcode.h.html#OPR_BAND">OPR_BAND</A>: case <A HREF="lcode.h.html#OPR_BOR">OPR_BOR</A>: case <A HREF="lcode.h.html#OPR_BXOR">OPR_BXOR</A>:
    case <A HREF="lcode.h.html#OPR_SHL">OPR_SHL</A>: case <A HREF="lcode.h.html#OPR_SHR">OPR_SHR</A>: {
      if (!<A HREF="lcode.c.html#tonumeral">tonumeral</A>(v, NULL)) <A HREF="lcode.c.html#luaK_exp2RK">luaK_exp2RK</A>(fs, v);
      break;
    }
    default: {
      <A HREF="lcode.c.html#luaK_exp2RK">luaK_exp2RK</A>(fs, v);
      break;
    }
  }
}


void <A NAME="luaK_posfix"><SPAN CLASS="definition">luaK_posfix</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lcode.h.html#BinOpr">BinOpr</A> op,
                  <A HREF="lparser.h.html#expdesc">expdesc</A> *e1, <A HREF="lparser.h.html#expdesc">expdesc</A> *e2, int line) {
  switch (op) {
    case <A HREF="lcode.h.html#OPR_AND">OPR_AND</A>: {
      <A HREF="llimits.h.html#lua_assert">lua_assert</A>(e1-&gt;t == <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>);  /* list must be closed */
      <A HREF="lcode.c.html#luaK_dischargevars">luaK_dischargevars</A>(fs, e2);
      <A HREF="lcode.c.html#luaK_concat">luaK_concat</A>(fs, &amp;e2-&gt;f, e1-&gt;f);
      *e1 = *e2;
      break;
    }
    case <A HREF="lcode.h.html#OPR_OR">OPR_OR</A>: {
      <A HREF="llimits.h.html#lua_assert">lua_assert</A>(e1-&gt;f == <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>);  /* list must be closed */
      <A HREF="lcode.c.html#luaK_dischargevars">luaK_dischargevars</A>(fs, e2);
      <A HREF="lcode.c.html#luaK_concat">luaK_concat</A>(fs, &amp;e2-&gt;t, e1-&gt;t);
      *e1 = *e2;
      break;
    }
    case <A HREF="lcode.h.html#OPR_CONCAT">OPR_CONCAT</A>: {
      <A HREF="lcode.c.html#luaK_exp2val">luaK_exp2val</A>(fs, e2);
      if (e2-&gt;k == <A HREF="lparser.h.html#VRELOCABLE">VRELOCABLE</A> &amp;&amp; <A HREF="lopcodes.h.html#GET_OPCODE">GET_OPCODE</A>(<A HREF="lcode.h.html#getcode">getcode</A>(fs, e2)) == <A HREF="lopcodes.h.html#OP_CONCAT">OP_CONCAT</A>) {
        <A HREF="llimits.h.html#lua_assert">lua_assert</A>(e1-&gt;u.info == <A HREF="lopcodes.h.html#GETARG_B">GETARG_B</A>(<A HREF="lcode.h.html#getcode">getcode</A>(fs, e2))-1);
        <A HREF="lcode.c.html#freeexp">freeexp</A>(fs, e1);
        <A HREF="lopcodes.h.html#SETARG_B">SETARG_B</A>(<A HREF="lcode.h.html#getcode">getcode</A>(fs, e2), e1-&gt;u.info);
        e1-&gt;k = <A HREF="lparser.h.html#VRELOCABLE">VRELOCABLE</A>; e1-&gt;u.info = e2-&gt;u.info;
      }
      else {
        <A HREF="lcode.c.html#luaK_exp2nextreg">luaK_exp2nextreg</A>(fs, e2);  /* operand must be on the 'stack' */
        <A HREF="lcode.c.html#codeexpval">codeexpval</A>(fs, <A HREF="lopcodes.h.html#OP_CONCAT">OP_CONCAT</A>, e1, e2, line);
      }
      break;
    }
    case <A HREF="lcode.h.html#OPR_ADD">OPR_ADD</A>: case <A HREF="lcode.h.html#OPR_SUB">OPR_SUB</A>: case <A HREF="lcode.h.html#OPR_MUL">OPR_MUL</A>: case <A HREF="lcode.h.html#OPR_DIV">OPR_DIV</A>:
    case <A HREF="lcode.h.html#OPR_IDIV">OPR_IDIV</A>: case <A HREF="lcode.h.html#OPR_MOD">OPR_MOD</A>: case <A HREF="lcode.h.html#OPR_POW">OPR_POW</A>:
    case <A HREF="lcode.h.html#OPR_BAND">OPR_BAND</A>: case <A HREF="lcode.h.html#OPR_BOR">OPR_BOR</A>: case <A HREF="lcode.h.html#OPR_BXOR">OPR_BXOR</A>:
    case <A HREF="lcode.h.html#OPR_SHL">OPR_SHL</A>: case <A HREF="lcode.h.html#OPR_SHR">OPR_SHR</A>: {
      <A HREF="lcode.c.html#codeexpval">codeexpval</A>(fs, <A HREF="llimits.h.html#cast">cast</A>(<A HREF="lopcodes.h.html#OpCode">OpCode</A>, (op - <A HREF="lcode.h.html#OPR_ADD">OPR_ADD</A>) + <A HREF="lopcodes.h.html#OP_ADD">OP_ADD</A>), e1, e2, line);
      break;
    }
    case <A HREF="lcode.h.html#OPR_EQ">OPR_EQ</A>: case <A HREF="lcode.h.html#OPR_LT">OPR_LT</A>: case <A HREF="lcode.h.html#OPR_LE">OPR_LE</A>: {
      <A HREF="lcode.c.html#codecomp">codecomp</A>(fs, <A HREF="llimits.h.html#cast">cast</A>(<A HREF="lopcodes.h.html#OpCode">OpCode</A>, (op - <A HREF="lcode.h.html#OPR_EQ">OPR_EQ</A>) + <A HREF="lopcodes.h.html#OP_EQ">OP_EQ</A>), 1, e1, e2);
      break;
    }
    case <A HREF="lcode.h.html#OPR_NE">OPR_NE</A>: case <A HREF="lcode.h.html#OPR_GT">OPR_GT</A>: case <A HREF="lcode.h.html#OPR_GE">OPR_GE</A>: {
      <A HREF="lcode.c.html#codecomp">codecomp</A>(fs, <A HREF="llimits.h.html#cast">cast</A>(<A HREF="lopcodes.h.html#OpCode">OpCode</A>, (op - <A HREF="lcode.h.html#OPR_NE">OPR_NE</A>) + <A HREF="lopcodes.h.html#OP_EQ">OP_EQ</A>), 0, e1, e2);
      break;
    }
    default: <A HREF="llimits.h.html#lua_assert">lua_assert</A>(0);
  }
}


void <A NAME="luaK_fixline"><SPAN CLASS="definition">luaK_fixline</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int line) {
  fs-&gt;f-&gt;lineinfo[fs-&gt;pc - 1] = line;
}


void <A NAME="luaK_setlist"><SPAN CLASS="definition">luaK_setlist</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int base, int nelems, int tostore) {
  int c =  (nelems - 1)/<A HREF="lopcodes.h.html#LFIELDS_PER_FLUSH">LFIELDS_PER_FLUSH</A> + 1;
  int b = (tostore == <A HREF="lua.h.html#LUA_MULTRET">LUA_MULTRET</A>) ? 0 : tostore;
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(tostore != 0);
  if (c &lt;= <A HREF="lopcodes.h.html#MAXARG_C">MAXARG_C</A>)
    <A HREF="lcode.c.html#luaK_codeABC">luaK_codeABC</A>(fs, <A HREF="lopcodes.h.html#OP_SETLIST">OP_SETLIST</A>, base, b, c);
  else if (c &lt;= <A HREF="lopcodes.h.html#MAXARG_Ax">MAXARG_Ax</A>) {
    <A HREF="lcode.c.html#luaK_codeABC">luaK_codeABC</A>(fs, <A HREF="lopcodes.h.html#OP_SETLIST">OP_SETLIST</A>, base, b, 0);
    <A HREF="lcode.c.html#codeextraarg">codeextraarg</A>(fs, c);
  }
  else
    <A HREF="llex.c.html#luaX_syntaxerror">luaX_syntaxerror</A>(fs-&gt;ls, "constructor too long");
  fs-&gt;<A HREF="lcode.c.html#freereg">freereg</A> = base + 1;  /* free registers with list values */
}

</PRE>

<P CLASS="footer">
Last update:
Mon Nov 30 10:09:13 2015
</P>

</BODY>
</HTML>
