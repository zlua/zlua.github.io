<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Lua 5.1.5 source code - lparser.c</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../lua.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../source.css">
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
</HEAD>

<BODY>

<H1>
<A HREF="../../home.html"><IMG SRC="../../images/logo.gif" ALT="Lua"></A>
lparser.c
<SPAN CLASS="note">(5.1.5)</SPAN>
</H1>

<DIV CLASS="menubar">
<A HREF="./">module index</A>
&middot;
<A HREF="idx.html">name index</A>
&middot;
<A HREF="../">other versions</A>
</DIV>

<PRE>
/*
** $Id: lparser.c,v 2.42.1.4 2011/10/21 19:31:42 roberto Exp $
** Lua Parser
** See Copyright Notice in lua.h
*/


#include &lt;string.h&gt;

#define <A NAME="lparser_c"><SPAN CLASS="definition">lparser_c</SPAN></A>
#define <A NAME="LUA_CORE"><SPAN CLASS="definition">LUA_CORE</SPAN></A>

#include "<A HREF="lua.h.html">lua.h</A>"

#include "<A HREF="lcode.h.html">lcode.h</A>"
#include "<A HREF="ldebug.h.html">ldebug.h</A>"
#include "<A HREF="ldo.h.html">ldo.h</A>"
#include "<A HREF="lfunc.h.html">lfunc.h</A>"
#include "<A HREF="llex.h.html">llex.h</A>"
#include "<A HREF="lmem.h.html">lmem.h</A>"
#include "<A HREF="lobject.h.html">lobject.h</A>"
#include "<A HREF="lopcodes.h.html">lopcodes.h</A>"
#include "<A HREF="lparser.h.html">lparser.h</A>"
#include "<A HREF="lstate.h.html">lstate.h</A>"
#include "<A HREF="lstring.h.html">lstring.h</A>"
#include "<A HREF="ltable.h.html">ltable.h</A>"



#define <A NAME="hasmultret"><SPAN CLASS="definition">hasmultret</SPAN></A>(k)           ((k) == <A HREF="lparser.h.html#VCALL">VCALL</A> || (k) == <A HREF="lparser.h.html#VVARARG">VVARARG</A>)

#define <A NAME="getlocvar"><SPAN CLASS="definition">getlocvar</SPAN></A>(fs, i)        ((fs)-&gt;f-&gt;locvars[(fs)-&gt;actvar[i]])

#define <A NAME="luaY_checklimit"><SPAN CLASS="definition">luaY_checklimit</SPAN></A>(fs,v,l,m)       if ((v)&gt;(l)) <A HREF="lparser.c.html#errorlimit">errorlimit</A>(fs,l,m)


/*
** nodes for <A HREF="lparser.c.html#block">block</A> list (list of active blocks)
*/
typedef struct <A NAME="BlockCnt"><SPAN CLASS="definition">BlockCnt</SPAN></A> {
  struct <A HREF="lparser.c.html#BlockCnt">BlockCnt</A> *previous;  /* chain */
  int breaklist;  /* list of jumps out of this loop */
  <A HREF="llimits.h.html#lu_byte">lu_byte</A> nactvar;  /* # active locals outside the breakable structure */
  <A HREF="llimits.h.html#lu_byte">lu_byte</A> upval;  /* true if some variable in the <A HREF="lparser.c.html#block">block</A> is an upvalue */
  <A HREF="llimits.h.html#lu_byte">lu_byte</A> isbreakable;  /* true if `<A HREF="lparser.c.html#block">block</A>' is a loop */
} <A HREF="lparser.c.html#BlockCnt">BlockCnt</A>;



/*
** prototypes for recursive non-terminal functions
*/
static void <A HREF="lparser.c.html#chunk">chunk</A> (<A HREF="llex.h.html#LexState">LexState</A> *ls);
static void <A HREF="lparser.c.html#expr">expr</A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, <A HREF="lparser.h.html#expdesc">expdesc</A> *v);


static void <A NAME="anchor_token"><SPAN CLASS="definition">anchor_token</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls) {
  if (ls-&gt;t.token == <A HREF="llex.h.html#TK_NAME">TK_NAME</A> || ls-&gt;t.token == <A HREF="llex.h.html#TK_STRING">TK_STRING</A>) {
    <A HREF="lobject.h.html#TString">TString</A> *ts = ls-&gt;t.seminfo.ts;
    <A HREF="llex.c.html#luaX_newstring">luaX_newstring</A>(ls, <A HREF="lobject.h.html#getstr">getstr</A>(ts), ts-&gt;tsv.len);
  }
}


static void <A NAME="error_expected"><SPAN CLASS="definition">error_expected</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, int token) {
  <A HREF="llex.c.html#luaX_syntaxerror">luaX_syntaxerror</A>(ls,
      <A HREF="lobject.c.html#luaO_pushfstring">luaO_pushfstring</A>(ls-&gt;L, <A HREF="luaconf.h.html#LUA_QS">LUA_QS</A> " expected", <A HREF="llex.c.html#luaX_token2str">luaX_token2str</A>(ls, token)));
}


static void <A NAME="errorlimit"><SPAN CLASS="definition">errorlimit</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int limit, const char *what) {
  const char *msg = (fs-&gt;f-&gt;linedefined == 0) ?
    <A HREF="lobject.c.html#luaO_pushfstring">luaO_pushfstring</A>(fs-&gt;L, "<A HREF="lua.c.html#main">main</A> function has more than %d %s", limit, what) :
    <A HREF="lobject.c.html#luaO_pushfstring">luaO_pushfstring</A>(fs-&gt;L, "function at line %d has more than %d %s",
                            fs-&gt;f-&gt;linedefined, limit, what);
  <A HREF="llex.c.html#luaX_lexerror">luaX_lexerror</A>(fs-&gt;ls, msg, 0);
}


static int <A NAME="testnext"><SPAN CLASS="definition">testnext</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, int c) {
  if (ls-&gt;t.token == c) {
    <A HREF="llex.c.html#luaX_next">luaX_next</A>(ls);
    return 1;
  }
  else return 0;
}


static void <A NAME="check"><SPAN CLASS="definition">check</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, int c) {
  if (ls-&gt;t.token != c)
    <A HREF="lparser.c.html#error_expected">error_expected</A>(ls, c);
}

static void <A NAME="checknext"><SPAN CLASS="definition">checknext</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, int c) {
  <A HREF="lparser.c.html#check">check</A>(ls, c);
  <A HREF="llex.c.html#luaX_next">luaX_next</A>(ls);
}


#define <A NAME="check_condition"><SPAN CLASS="definition">check_condition</SPAN></A>(ls,c,msg)       { if (!(c)) <A HREF="llex.c.html#luaX_syntaxerror">luaX_syntaxerror</A>(ls, msg); }



static void <A NAME="check_match"><SPAN CLASS="definition">check_match</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, int what, int who, int where) {
  if (!<A HREF="lparser.c.html#testnext">testnext</A>(ls, what)) {
    if (where == ls-&gt;linenumber)
      <A HREF="lparser.c.html#error_expected">error_expected</A>(ls, what);
    else {
      <A HREF="llex.c.html#luaX_syntaxerror">luaX_syntaxerror</A>(ls, <A HREF="lobject.c.html#luaO_pushfstring">luaO_pushfstring</A>(ls-&gt;L,
             <A HREF="luaconf.h.html#LUA_QS">LUA_QS</A> " expected (to close " <A HREF="luaconf.h.html#LUA_QS">LUA_QS</A> " at line %d)",
              <A HREF="llex.c.html#luaX_token2str">luaX_token2str</A>(ls, what), <A HREF="llex.c.html#luaX_token2str">luaX_token2str</A>(ls, who), where));
    }
  }
}


static <A HREF="lobject.h.html#TString">TString</A> *<A NAME="str_checkname"><SPAN CLASS="definition">str_checkname</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls) {
  <A HREF="lobject.h.html#TString">TString</A> *ts;
  <A HREF="lparser.c.html#check">check</A>(ls, <A HREF="llex.h.html#TK_NAME">TK_NAME</A>);
  ts = ls-&gt;t.seminfo.ts;
  <A HREF="llex.c.html#luaX_next">luaX_next</A>(ls);
  return ts;
}


static void <A NAME="init_exp"><SPAN CLASS="definition">init_exp</SPAN></A> (<A HREF="lparser.h.html#expdesc">expdesc</A> *e, <A HREF="lparser.h.html#expkind">expkind</A> k, int i) {
  e-&gt;f = e-&gt;t = <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;
  e-&gt;k = k;
  e-&gt;u.s.info = i;
}


static void <A NAME="codestring"><SPAN CLASS="definition">codestring</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, <A HREF="lparser.h.html#expdesc">expdesc</A> *e, <A HREF="lobject.h.html#TString">TString</A> *s) {
  <A HREF="lparser.c.html#init_exp">init_exp</A>(e, <A HREF="lparser.h.html#VK">VK</A>, <A HREF="lcode.c.html#luaK_stringK">luaK_stringK</A>(ls-&gt;fs, s));
}


static void <A NAME="checkname"><SPAN CLASS="definition">checkname</SPAN></A>(<A HREF="llex.h.html#LexState">LexState</A> *ls, <A HREF="lparser.h.html#expdesc">expdesc</A> *e) {
  <A HREF="lparser.c.html#codestring">codestring</A>(ls, e, <A HREF="lparser.c.html#str_checkname">str_checkname</A>(ls));
}


static int <A NAME="registerlocalvar"><SPAN CLASS="definition">registerlocalvar</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, <A HREF="lobject.h.html#TString">TString</A> *varname) {
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  <A HREF="lobject.h.html#Proto">Proto</A> *f = fs-&gt;f;
  int oldsize = f-&gt;sizelocvars;
  <A HREF="lmem.h.html#luaM_growvector">luaM_growvector</A>(ls-&gt;L, f-&gt;locvars, fs-&gt;nlocvars, f-&gt;sizelocvars,
                  <A HREF="lobject.h.html#LocVar">LocVar</A>, SHRT_MAX, "too many local variables");
  while (oldsize &lt; f-&gt;sizelocvars) f-&gt;locvars[oldsize++].varname = NULL;
  f-&gt;locvars[fs-&gt;nlocvars].varname = varname;
  <A HREF="lgc.h.html#luaC_objbarrier">luaC_objbarrier</A>(ls-&gt;L, f, varname);
  return fs-&gt;nlocvars++;
}


#define <A NAME="new_localvarliteral"><SPAN CLASS="definition">new_localvarliteral</SPAN></A>(ls,v,n) \
  <A HREF="lparser.c.html#new_localvar">new_localvar</A>(ls, <A HREF="llex.c.html#luaX_newstring">luaX_newstring</A>(ls, "" v, (sizeof(v)/sizeof(char))-1), n)


static void <A NAME="new_localvar"><SPAN CLASS="definition">new_localvar</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, <A HREF="lobject.h.html#TString">TString</A> *name, int n) {
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  <A HREF="lparser.c.html#luaY_checklimit">luaY_checklimit</A>(fs, fs-&gt;nactvar+n+1, <A HREF="luaconf.h.html#LUAI_MAXVARS">LUAI_MAXVARS</A>, "local variables");
  fs-&gt;actvar[fs-&gt;nactvar+n] = <A HREF="llimits.h.html#cast">cast</A>(unsigned short, <A HREF="lparser.c.html#registerlocalvar">registerlocalvar</A>(ls, name));
}


static void <A NAME="adjustlocalvars"><SPAN CLASS="definition">adjustlocalvars</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, int nvars) {
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  fs-&gt;nactvar = <A HREF="llimits.h.html#cast_byte">cast_byte</A>(fs-&gt;nactvar + nvars);
  for (; nvars; nvars--) {
    <A HREF="lparser.c.html#getlocvar">getlocvar</A>(fs, fs-&gt;nactvar - nvars).startpc = fs-&gt;pc;
  }
}


static void <A NAME="removevars"><SPAN CLASS="definition">removevars</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, int tolevel) {
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  while (fs-&gt;nactvar &gt; tolevel)
    <A HREF="lparser.c.html#getlocvar">getlocvar</A>(fs, --fs-&gt;nactvar).endpc = fs-&gt;pc;
}


static int <A NAME="indexupvalue"><SPAN CLASS="definition">indexupvalue</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lobject.h.html#TString">TString</A> *name, <A HREF="lparser.h.html#expdesc">expdesc</A> *v) {
  int i;
  <A HREF="lobject.h.html#Proto">Proto</A> *f = fs-&gt;f;
  int oldsize = f-&gt;sizeupvalues;
  for (i=0; i&lt;f-&gt;nups; i++) {
    if (fs-&gt;upvalues[i].k == v-&gt;k &amp;&amp; fs-&gt;upvalues[i].info == v-&gt;u.s.info) {
      <A HREF="llimits.h.html#lua_assert">lua_assert</A>(f-&gt;upvalues[i] == name);
      return i;
    }
  }
  /* new one */
  <A HREF="lparser.c.html#luaY_checklimit">luaY_checklimit</A>(fs, f-&gt;nups + 1, <A HREF="luaconf.h.html#LUAI_MAXUPVALUES">LUAI_MAXUPVALUES</A>, "upvalues");
  <A HREF="lmem.h.html#luaM_growvector">luaM_growvector</A>(fs-&gt;L, f-&gt;upvalues, f-&gt;nups, f-&gt;sizeupvalues,
                  <A HREF="lobject.h.html#TString">TString</A> *, <A HREF="llimits.h.html#MAX_INT">MAX_INT</A>, "");
  while (oldsize &lt; f-&gt;sizeupvalues) f-&gt;upvalues[oldsize++] = NULL;
  f-&gt;upvalues[f-&gt;nups] = name;
  <A HREF="lgc.h.html#luaC_objbarrier">luaC_objbarrier</A>(fs-&gt;L, f, name);
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(v-&gt;k == <A HREF="lparser.h.html#VLOCAL">VLOCAL</A> || v-&gt;k == <A HREF="lparser.h.html#VUPVAL">VUPVAL</A>);
  fs-&gt;upvalues[f-&gt;nups].k = <A HREF="llimits.h.html#cast_byte">cast_byte</A>(v-&gt;k);
  fs-&gt;upvalues[f-&gt;nups].info = <A HREF="llimits.h.html#cast_byte">cast_byte</A>(v-&gt;u.s.info);
  return f-&gt;nups++;
}


static int <A NAME="searchvar"><SPAN CLASS="definition">searchvar</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lobject.h.html#TString">TString</A> *n) {
  int i;
  for (i=fs-&gt;nactvar-1; i &gt;= 0; i--) {
    if (n == <A HREF="lparser.c.html#getlocvar">getlocvar</A>(fs, i).varname)
      return i;
  }
  return -1;  /* not found */
}


static void <A NAME="markupval"><SPAN CLASS="definition">markupval</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, int level) {
  <A HREF="lparser.c.html#BlockCnt">BlockCnt</A> *bl = fs-&gt;bl;
  while (bl &amp;&amp; bl-&gt;nactvar &gt; level) bl = bl-&gt;previous;
  if (bl) bl-&gt;upval = 1;
}


static int <A NAME="singlevaraux"><SPAN CLASS="definition">singlevaraux</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lobject.h.html#TString">TString</A> *n, <A HREF="lparser.h.html#expdesc">expdesc</A> *var, int base) {
  if (fs == NULL) {  /* no more levels? */
    <A HREF="lparser.c.html#init_exp">init_exp</A>(var, <A HREF="lparser.h.html#VGLOBAL">VGLOBAL</A>, <A HREF="lopcodes.h.html#NO_REG">NO_REG</A>);  /* default is global variable */
    return <A HREF="lparser.h.html#VGLOBAL">VGLOBAL</A>;
  }
  else {
    int v = <A HREF="lparser.c.html#searchvar">searchvar</A>(fs, n);  /* look up at current level */
    if (v &gt;= 0) {
      <A HREF="lparser.c.html#init_exp">init_exp</A>(var, <A HREF="lparser.h.html#VLOCAL">VLOCAL</A>, v);
      if (!base)
        <A HREF="lparser.c.html#markupval">markupval</A>(fs, v);  /* local will be used as an upval */
      return <A HREF="lparser.h.html#VLOCAL">VLOCAL</A>;
    }
    else {  /* not found at current level; try upper one */
      if (<A HREF="lparser.c.html#singlevaraux">singlevaraux</A>(fs-&gt;prev, n, var, 0) == <A HREF="lparser.h.html#VGLOBAL">VGLOBAL</A>)
        return <A HREF="lparser.h.html#VGLOBAL">VGLOBAL</A>;
      var-&gt;u.s.info = <A HREF="lparser.c.html#indexupvalue">indexupvalue</A>(fs, n, var);  /* else was LOCAL or UPVAL */
      var-&gt;k = <A HREF="lparser.h.html#VUPVAL">VUPVAL</A>;  /* upvalue in this level */
      return <A HREF="lparser.h.html#VUPVAL">VUPVAL</A>;
    }
  }
}


static void <A NAME="singlevar"><SPAN CLASS="definition">singlevar</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, <A HREF="lparser.h.html#expdesc">expdesc</A> *var) {
  <A HREF="lobject.h.html#TString">TString</A> *varname = <A HREF="lparser.c.html#str_checkname">str_checkname</A>(ls);
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  if (<A HREF="lparser.c.html#singlevaraux">singlevaraux</A>(fs, varname, var, 1) == <A HREF="lparser.h.html#VGLOBAL">VGLOBAL</A>)
    var-&gt;u.s.info = <A HREF="lcode.c.html#luaK_stringK">luaK_stringK</A>(fs, varname);  /* info points to global name */
}


static void <A NAME="adjust_assign"><SPAN CLASS="definition">adjust_assign</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, int nvars, int nexps, <A HREF="lparser.h.html#expdesc">expdesc</A> *e) {
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  int extra = nvars - nexps;
  if (<A HREF="lparser.c.html#hasmultret">hasmultret</A>(e-&gt;k)) {
    extra++;  /* includes call itself */
    if (extra &lt; 0) extra = 0;
    <A HREF="lcode.c.html#luaK_setreturns">luaK_setreturns</A>(fs, e, extra);  /* last exp. provides the difference */
    if (extra &gt; 1) <A HREF="lcode.c.html#luaK_reserveregs">luaK_reserveregs</A>(fs, extra-1);
  }
  else {
    if (e-&gt;k != <A HREF="lparser.h.html#VVOID">VVOID</A>) <A HREF="lcode.c.html#luaK_exp2nextreg">luaK_exp2nextreg</A>(fs, e);  /* close last expression */
    if (extra &gt; 0) {
      int reg = fs-&gt;freereg;
      <A HREF="lcode.c.html#luaK_reserveregs">luaK_reserveregs</A>(fs, extra);
      <A HREF="lcode.c.html#luaK_nil">luaK_nil</A>(fs, reg, extra);
    }
  }
}


static void <A NAME="enterlevel"><SPAN CLASS="definition">enterlevel</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls) {
  if (++ls-&gt;L-&gt;nCcalls &gt; <A HREF="luaconf.h.html#LUAI_MAXCCALLS">LUAI_MAXCCALLS</A>)
        <A HREF="llex.c.html#luaX_lexerror">luaX_lexerror</A>(ls, "<A HREF="lparser.c.html#chunk">chunk</A> has too many syntax levels", 0);
}


#define <A NAME="leavelevel"><SPAN CLASS="definition">leavelevel</SPAN></A>(ls)  ((ls)-&gt;L-&gt;nCcalls--)


static void <A NAME="enterblock"><SPAN CLASS="definition">enterblock</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, <A HREF="lparser.c.html#BlockCnt">BlockCnt</A> *bl, <A HREF="llimits.h.html#lu_byte">lu_byte</A> isbreakable) {
  bl-&gt;breaklist = <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;
  bl-&gt;isbreakable = isbreakable;
  bl-&gt;nactvar = fs-&gt;nactvar;
  bl-&gt;upval = 0;
  bl-&gt;previous = fs-&gt;bl;
  fs-&gt;bl = bl;
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(fs-&gt;freereg == fs-&gt;nactvar);
}


static void <A NAME="leaveblock"><SPAN CLASS="definition">leaveblock</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs) {
  <A HREF="lparser.c.html#BlockCnt">BlockCnt</A> *bl = fs-&gt;bl;
  fs-&gt;bl = bl-&gt;previous;
  <A HREF="lparser.c.html#removevars">removevars</A>(fs-&gt;ls, bl-&gt;nactvar);
  if (bl-&gt;upval)
    <A HREF="lcode.c.html#luaK_codeABC">luaK_codeABC</A>(fs, <A HREF="lopcodes.h.html#OP_CLOSE">OP_CLOSE</A>, bl-&gt;nactvar, 0, 0);
  /* a <A HREF="lparser.c.html#block">block</A> either controls scope or breaks (never both) */
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(!bl-&gt;isbreakable || !bl-&gt;upval);
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(bl-&gt;nactvar == fs-&gt;nactvar);
  fs-&gt;freereg = fs-&gt;nactvar;  /* free registers */
  <A HREF="lcode.c.html#luaK_patchtohere">luaK_patchtohere</A>(fs, bl-&gt;breaklist);
}


static void <A NAME="pushclosure"><SPAN CLASS="definition">pushclosure</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, <A HREF="lparser.h.html#FuncState">FuncState</A> *func, <A HREF="lparser.h.html#expdesc">expdesc</A> *v) {
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  <A HREF="lobject.h.html#Proto">Proto</A> *f = fs-&gt;f;
  int oldsize = f-&gt;sizep;
  int i;
  <A HREF="lmem.h.html#luaM_growvector">luaM_growvector</A>(ls-&gt;L, f-&gt;p, fs-&gt;np, f-&gt;sizep, <A HREF="lobject.h.html#Proto">Proto</A> *,
                  <A HREF="lopcodes.h.html#MAXARG_Bx">MAXARG_Bx</A>, "constant table overflow");
  while (oldsize &lt; f-&gt;sizep) f-&gt;p[oldsize++] = NULL;
  f-&gt;p[fs-&gt;np++] = func-&gt;f;
  <A HREF="lgc.h.html#luaC_objbarrier">luaC_objbarrier</A>(ls-&gt;L, f, func-&gt;f);
  <A HREF="lparser.c.html#init_exp">init_exp</A>(v, <A HREF="lparser.h.html#VRELOCABLE">VRELOCABLE</A>, <A HREF="lcode.c.html#luaK_codeABx">luaK_codeABx</A>(fs, <A HREF="lopcodes.h.html#OP_CLOSURE">OP_CLOSURE</A>, 0, fs-&gt;np-1));
  for (i=0; i&lt;func-&gt;f-&gt;nups; i++) {
    <A HREF="lopcodes.h.html#OpCode">OpCode</A> o = (func-&gt;upvalues[i].k == <A HREF="lparser.h.html#VLOCAL">VLOCAL</A>) ? <A HREF="lopcodes.h.html#OP_MOVE">OP_MOVE</A> : <A HREF="lopcodes.h.html#OP_GETUPVAL">OP_GETUPVAL</A>;
    <A HREF="lcode.c.html#luaK_codeABC">luaK_codeABC</A>(fs, o, 0, func-&gt;upvalues[i].info, 0);
  }
}


static void <A NAME="open_func"><SPAN CLASS="definition">open_func</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, <A HREF="lparser.h.html#FuncState">FuncState</A> *fs) {
  <A HREF="lstate.h.html#lua_State">lua_State</A> *L = ls-&gt;L;
  <A HREF="lobject.h.html#Proto">Proto</A> *f = <A HREF="lfunc.c.html#luaF_newproto">luaF_newproto</A>(L);
  fs-&gt;f = f;
  fs-&gt;prev = ls-&gt;fs;  /* linked list of funcstates */
  fs-&gt;ls = ls;
  fs-&gt;L = L;
  ls-&gt;fs = fs;
  fs-&gt;pc = 0;
  fs-&gt;lasttarget = -1;
  fs-&gt;jpc = <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;
  fs-&gt;freereg = 0;
  fs-&gt;nk = 0;
  fs-&gt;np = 0;
  fs-&gt;nlocvars = 0;
  fs-&gt;nactvar = 0;
  fs-&gt;bl = NULL;
  f-&gt;source = ls-&gt;source;
  f-&gt;maxstacksize = 2;  /* registers 0/1 are always valid */
  fs-&gt;h = <A HREF="ltable.c.html#luaH_new">luaH_new</A>(L, 0, 0);
  /* anchor table of constants and prototype (to avoid being collected) */
  <A HREF="lobject.h.html#sethvalue2s">sethvalue2s</A>(L, L-&gt;top, fs-&gt;h);
  <A HREF="ldo.h.html#incr_top">incr_top</A>(L);
  <A HREF="lobject.h.html#setptvalue2s">setptvalue2s</A>(L, L-&gt;top, f);
  <A HREF="ldo.h.html#incr_top">incr_top</A>(L);
}


static void <A NAME="close_func"><SPAN CLASS="definition">close_func</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls) {
  <A HREF="lstate.h.html#lua_State">lua_State</A> *L = ls-&gt;L;
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  <A HREF="lobject.h.html#Proto">Proto</A> *f = fs-&gt;f;
  <A HREF="lparser.c.html#removevars">removevars</A>(ls, 0);
  <A HREF="lcode.c.html#luaK_ret">luaK_ret</A>(fs, 0, 0);  /* final return */
  <A HREF="lmem.h.html#luaM_reallocvector">luaM_reallocvector</A>(L, f-&gt;code, f-&gt;sizecode, fs-&gt;pc, <A HREF="llimits.h.html#Instruction">Instruction</A>);
  f-&gt;sizecode = fs-&gt;pc;
  <A HREF="lmem.h.html#luaM_reallocvector">luaM_reallocvector</A>(L, f-&gt;lineinfo, f-&gt;sizelineinfo, fs-&gt;pc, int);
  f-&gt;sizelineinfo = fs-&gt;pc;
  <A HREF="lmem.h.html#luaM_reallocvector">luaM_reallocvector</A>(L, f-&gt;k, f-&gt;sizek, fs-&gt;nk, <A HREF="lobject.h.html#TValue">TValue</A>);
  f-&gt;sizek = fs-&gt;nk;
  <A HREF="lmem.h.html#luaM_reallocvector">luaM_reallocvector</A>(L, f-&gt;p, f-&gt;sizep, fs-&gt;np, <A HREF="lobject.h.html#Proto">Proto</A> *);
  f-&gt;sizep = fs-&gt;np;
  <A HREF="lmem.h.html#luaM_reallocvector">luaM_reallocvector</A>(L, f-&gt;locvars, f-&gt;sizelocvars, fs-&gt;nlocvars, <A HREF="lobject.h.html#LocVar">LocVar</A>);
  f-&gt;sizelocvars = fs-&gt;nlocvars;
  <A HREF="lmem.h.html#luaM_reallocvector">luaM_reallocvector</A>(L, f-&gt;upvalues, f-&gt;sizeupvalues, f-&gt;nups, <A HREF="lobject.h.html#TString">TString</A> *);
  f-&gt;sizeupvalues = f-&gt;nups;
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(<A HREF="ldebug.c.html#luaG_checkcode">luaG_checkcode</A>(f));
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(fs-&gt;bl == NULL);
  ls-&gt;fs = fs-&gt;prev;
  /* last token read was anchored in defunct function; must reanchor it */
  if (fs) <A HREF="lparser.c.html#anchor_token">anchor_token</A>(ls);
  L-&gt;top -= 2;  /* remove table and prototype from the stack */
}


<A HREF="lobject.h.html#Proto">Proto</A> *<A NAME="luaY_parser"><SPAN CLASS="definition">luaY_parser</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L, <A HREF="lzio.h.html#ZIO">ZIO</A> *z, <A HREF="lzio.h.html#Mbuffer">Mbuffer</A> *buff, const char *name) {
  struct <A HREF="llex.h.html#LexState">LexState</A> lexstate;
  struct <A HREF="lparser.h.html#FuncState">FuncState</A> funcstate;
  lexstate.buff = buff;
  <A HREF="llex.c.html#luaX_setinput">luaX_setinput</A>(L, &amp;lexstate, z, <A HREF="lstring.h.html#luaS_new">luaS_new</A>(L, name));
  <A HREF="lparser.c.html#open_func">open_func</A>(&amp;lexstate, &amp;funcstate);
  funcstate.f-&gt;is_vararg = <A HREF="lobject.h.html#VARARG_ISVARARG">VARARG_ISVARARG</A>;  /* <A HREF="lua.c.html#main">main</A> func. is always vararg */
  <A HREF="llex.c.html#luaX_next">luaX_next</A>(&amp;lexstate);  /* read first token */
  <A HREF="lparser.c.html#chunk">chunk</A>(&amp;lexstate);
  <A HREF="lparser.c.html#check">check</A>(&amp;lexstate, <A HREF="llex.h.html#TK_EOS">TK_EOS</A>);
  <A HREF="lparser.c.html#close_func">close_func</A>(&amp;lexstate);
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(funcstate.prev == NULL);
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(funcstate.f-&gt;nups == 0);
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(lexstate.fs == NULL);
  return funcstate.f;
}



/*============================================================*/
/* GRAMMAR RULES */
/*============================================================*/


static void <A NAME="field"><SPAN CLASS="definition">field</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, <A HREF="lparser.h.html#expdesc">expdesc</A> *v) {
  /* <A HREF="lparser.c.html#field">field</A> -&gt; ['.' | ':'] NAME */
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  <A HREF="lparser.h.html#expdesc">expdesc</A> key;
  <A HREF="lcode.c.html#luaK_exp2anyreg">luaK_exp2anyreg</A>(fs, v);
  <A HREF="llex.c.html#luaX_next">luaX_next</A>(ls);  /* skip the dot or colon */
  <A HREF="lparser.c.html#checkname">checkname</A>(ls, &amp;key);
  <A HREF="lcode.c.html#luaK_indexed">luaK_indexed</A>(fs, v, &amp;key);
}


static void <A NAME="yindex"><SPAN CLASS="definition">yindex</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, <A HREF="lparser.h.html#expdesc">expdesc</A> *v) {
  /* index -&gt; '[' <A HREF="lparser.c.html#expr">expr</A> ']' */
  <A HREF="llex.c.html#luaX_next">luaX_next</A>(ls);  /* skip the '[' */
  <A HREF="lparser.c.html#expr">expr</A>(ls, v);
  <A HREF="lcode.c.html#luaK_exp2val">luaK_exp2val</A>(ls-&gt;fs, v);
  <A HREF="lparser.c.html#checknext">checknext</A>(ls, ']');
}


/*
** {======================================================================
** Rules for Constructors
** =======================================================================
*/


struct <A NAME="ConsControl"><SPAN CLASS="definition">ConsControl</SPAN></A> {
  <A HREF="lparser.h.html#expdesc">expdesc</A> v;  /* last list item read */
  <A HREF="lparser.h.html#expdesc">expdesc</A> *t;  /* table descriptor */
  int nh;  /* total number of `record' elements */
  int na;  /* total number of array elements */
  int tostore;  /* number of array elements pending to be stored */
};


static void <A NAME="recfield"><SPAN CLASS="definition">recfield</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, struct <A HREF="lparser.c.html#ConsControl">ConsControl</A> *cc) {
  /* <A HREF="lparser.c.html#recfield">recfield</A> -&gt; (NAME | `['<A HREF="lparser.c.html#exp1">exp1</A>`]') = <A HREF="lparser.c.html#exp1">exp1</A> */
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  int reg = ls-&gt;fs-&gt;freereg;
  <A HREF="lparser.h.html#expdesc">expdesc</A> key, val;
  int rkkey;
  if (ls-&gt;t.token == <A HREF="llex.h.html#TK_NAME">TK_NAME</A>) {
    <A HREF="lparser.c.html#luaY_checklimit">luaY_checklimit</A>(fs, cc-&gt;nh, <A HREF="llimits.h.html#MAX_INT">MAX_INT</A>, "items in a <A HREF="lparser.c.html#constructor">constructor</A>");
    <A HREF="lparser.c.html#checkname">checkname</A>(ls, &amp;key);
  }
  else  /* ls-&gt;t.token == '[' */
    <A HREF="lparser.c.html#yindex">yindex</A>(ls, &amp;key);
  cc-&gt;nh++;
  <A HREF="lparser.c.html#checknext">checknext</A>(ls, '=');
  rkkey = <A HREF="lcode.c.html#luaK_exp2RK">luaK_exp2RK</A>(fs, &amp;key);
  <A HREF="lparser.c.html#expr">expr</A>(ls, &amp;val);
  <A HREF="lcode.c.html#luaK_codeABC">luaK_codeABC</A>(fs, <A HREF="lopcodes.h.html#OP_SETTABLE">OP_SETTABLE</A>, cc-&gt;t-&gt;u.s.info, rkkey, <A HREF="lcode.c.html#luaK_exp2RK">luaK_exp2RK</A>(fs, &amp;val));
  fs-&gt;freereg = reg;  /* free registers */
}


static void <A NAME="closelistfield"><SPAN CLASS="definition">closelistfield</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, struct <A HREF="lparser.c.html#ConsControl">ConsControl</A> *cc) {
  if (cc-&gt;v.k == <A HREF="lparser.h.html#VVOID">VVOID</A>) return;  /* there is no list item */
  <A HREF="lcode.c.html#luaK_exp2nextreg">luaK_exp2nextreg</A>(fs, &amp;cc-&gt;v);
  cc-&gt;v.k = <A HREF="lparser.h.html#VVOID">VVOID</A>;
  if (cc-&gt;tostore == <A HREF="lopcodes.h.html#LFIELDS_PER_FLUSH">LFIELDS_PER_FLUSH</A>) {
    <A HREF="lcode.c.html#luaK_setlist">luaK_setlist</A>(fs, cc-&gt;t-&gt;u.s.info, cc-&gt;na, cc-&gt;tostore);  /* flush */
    cc-&gt;tostore = 0;  /* no more items pending */
  }
}


static void <A NAME="lastlistfield"><SPAN CLASS="definition">lastlistfield</SPAN></A> (<A HREF="lparser.h.html#FuncState">FuncState</A> *fs, struct <A HREF="lparser.c.html#ConsControl">ConsControl</A> *cc) {
  if (cc-&gt;tostore == 0) return;
  if (<A HREF="lparser.c.html#hasmultret">hasmultret</A>(cc-&gt;v.k)) {
    <A HREF="lcode.h.html#luaK_setmultret">luaK_setmultret</A>(fs, &amp;cc-&gt;v);
    <A HREF="lcode.c.html#luaK_setlist">luaK_setlist</A>(fs, cc-&gt;t-&gt;u.s.info, cc-&gt;na, <A HREF="lua.h.html#LUA_MULTRET">LUA_MULTRET</A>);
    cc-&gt;na--;  /* do not count last expression (unknown number of elements) */
  }
  else {
    if (cc-&gt;v.k != <A HREF="lparser.h.html#VVOID">VVOID</A>)
      <A HREF="lcode.c.html#luaK_exp2nextreg">luaK_exp2nextreg</A>(fs, &amp;cc-&gt;v);
    <A HREF="lcode.c.html#luaK_setlist">luaK_setlist</A>(fs, cc-&gt;t-&gt;u.s.info, cc-&gt;na, cc-&gt;tostore);
  }
}


static void <A NAME="listfield"><SPAN CLASS="definition">listfield</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, struct <A HREF="lparser.c.html#ConsControl">ConsControl</A> *cc) {
  <A HREF="lparser.c.html#expr">expr</A>(ls, &amp;cc-&gt;v);
  <A HREF="lparser.c.html#luaY_checklimit">luaY_checklimit</A>(ls-&gt;fs, cc-&gt;na, <A HREF="llimits.h.html#MAX_INT">MAX_INT</A>, "items in a <A HREF="lparser.c.html#constructor">constructor</A>");
  cc-&gt;na++;
  cc-&gt;tostore++;
}


static void <A NAME="constructor"><SPAN CLASS="definition">constructor</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, <A HREF="lparser.h.html#expdesc">expdesc</A> *t) {
  /* <A HREF="lparser.c.html#constructor">constructor</A> -&gt; ?? */
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  int line = ls-&gt;linenumber;
  int pc = <A HREF="lcode.c.html#luaK_codeABC">luaK_codeABC</A>(fs, <A HREF="lopcodes.h.html#OP_NEWTABLE">OP_NEWTABLE</A>, 0, 0, 0);
  struct <A HREF="lparser.c.html#ConsControl">ConsControl</A> cc;
  cc.na = cc.nh = cc.tostore = 0;
  cc.t = t;
  <A HREF="lparser.c.html#init_exp">init_exp</A>(t, <A HREF="lparser.h.html#VRELOCABLE">VRELOCABLE</A>, pc);
  <A HREF="lparser.c.html#init_exp">init_exp</A>(&amp;cc.v, <A HREF="lparser.h.html#VVOID">VVOID</A>, 0);  /* no value (yet) */
  <A HREF="lcode.c.html#luaK_exp2nextreg">luaK_exp2nextreg</A>(ls-&gt;fs, t);  /* fix it at stack top (for gc) */
  <A HREF="lparser.c.html#checknext">checknext</A>(ls, '{');
  do {
    <A HREF="llimits.h.html#lua_assert">lua_assert</A>(cc.v.k == <A HREF="lparser.h.html#VVOID">VVOID</A> || cc.tostore &gt; 0);
    if (ls-&gt;t.token == '}') break;
    <A HREF="lparser.c.html#closelistfield">closelistfield</A>(fs, &amp;cc);
    switch(ls-&gt;t.token) {
      case <A HREF="llex.h.html#TK_NAME">TK_NAME</A>: {  /* may be listfields or recfields */
        <A HREF="llex.c.html#luaX_lookahead">luaX_lookahead</A>(ls);
        if (ls-&gt;lookahead.token != '=')  /* expression? */
          <A HREF="lparser.c.html#listfield">listfield</A>(ls, &amp;cc);
        else
          <A HREF="lparser.c.html#recfield">recfield</A>(ls, &amp;cc);
        break;
      }
      case '[': {  /* constructor_item -&gt; <A HREF="lparser.c.html#recfield">recfield</A> */
        <A HREF="lparser.c.html#recfield">recfield</A>(ls, &amp;cc);
        break;
      }
      default: {  /* constructor_part -&gt; <A HREF="lparser.c.html#listfield">listfield</A> */
        <A HREF="lparser.c.html#listfield">listfield</A>(ls, &amp;cc);
        break;
      }
    }
  } while (<A HREF="lparser.c.html#testnext">testnext</A>(ls, ',') || <A HREF="lparser.c.html#testnext">testnext</A>(ls, ';'));
  <A HREF="lparser.c.html#check_match">check_match</A>(ls, '}', '{', line);
  <A HREF="lparser.c.html#lastlistfield">lastlistfield</A>(fs, &amp;cc);
  <A HREF="lopcodes.h.html#SETARG_B">SETARG_B</A>(fs-&gt;f-&gt;code[pc], <A HREF="lobject.c.html#luaO_int2fb">luaO_int2fb</A>(cc.na)); /* set initial array size */
  <A HREF="lopcodes.h.html#SETARG_C">SETARG_C</A>(fs-&gt;f-&gt;code[pc], <A HREF="lobject.c.html#luaO_int2fb">luaO_int2fb</A>(cc.nh));  /* set initial table size */
}

/* }====================================================================== */



static void <A NAME="parlist"><SPAN CLASS="definition">parlist</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls) {
  /* <A HREF="lparser.c.html#parlist">parlist</A> -&gt; [ param { `,' param } ] */
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  <A HREF="lobject.h.html#Proto">Proto</A> *f = fs-&gt;f;
  int nparams = 0;
  f-&gt;is_vararg = 0;
  if (ls-&gt;t.token != ')') {  /* is `<A HREF="lparser.c.html#parlist">parlist</A>' not empty? */
    do {
      switch (ls-&gt;t.token) {
        case <A HREF="llex.h.html#TK_NAME">TK_NAME</A>: {  /* param -&gt; NAME */
          <A HREF="lparser.c.html#new_localvar">new_localvar</A>(ls, <A HREF="lparser.c.html#str_checkname">str_checkname</A>(ls), nparams++);
          break;
        }
        case <A HREF="llex.h.html#TK_DOTS">TK_DOTS</A>: {  /* param -&gt; `...' */
          <A HREF="llex.c.html#luaX_next">luaX_next</A>(ls);
#if defined(<A HREF="luaconf.h.html#LUA_COMPAT_VARARG">LUA_COMPAT_VARARG</A>)
          /* use `arg' as default name */
          <A HREF="lparser.c.html#new_localvarliteral">new_localvarliteral</A>(ls, "arg", nparams++);
          f-&gt;is_vararg = <A HREF="lobject.h.html#VARARG_HASARG">VARARG_HASARG</A> | <A HREF="lobject.h.html#VARARG_NEEDSARG">VARARG_NEEDSARG</A>;
#endif
          f-&gt;is_vararg |= <A HREF="lobject.h.html#VARARG_ISVARARG">VARARG_ISVARARG</A>;
          break;
        }
        default: <A HREF="llex.c.html#luaX_syntaxerror">luaX_syntaxerror</A>(ls, "&lt;name&gt; or " <A HREF="luaconf.h.html#LUA_QL">LUA_QL</A>("...") " expected");
      }
    } while (!f-&gt;is_vararg &amp;&amp; <A HREF="lparser.c.html#testnext">testnext</A>(ls, ','));
  }
  <A HREF="lparser.c.html#adjustlocalvars">adjustlocalvars</A>(ls, nparams);
  f-&gt;numparams = <A HREF="llimits.h.html#cast_byte">cast_byte</A>(fs-&gt;nactvar - (f-&gt;is_vararg &amp; <A HREF="lobject.h.html#VARARG_HASARG">VARARG_HASARG</A>));
  <A HREF="lcode.c.html#luaK_reserveregs">luaK_reserveregs</A>(fs, fs-&gt;nactvar);  /* reserve register for parameters */
}


static void <A NAME="body"><SPAN CLASS="definition">body</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, <A HREF="lparser.h.html#expdesc">expdesc</A> *e, int needself, int line) {
  /* <A HREF="lparser.c.html#body">body</A> -&gt;  `(' <A HREF="lparser.c.html#parlist">parlist</A> `)' <A HREF="lparser.c.html#chunk">chunk</A> END */
  <A HREF="lparser.h.html#FuncState">FuncState</A> new_fs;
  <A HREF="lparser.c.html#open_func">open_func</A>(ls, &amp;new_fs);
  new_fs.f-&gt;linedefined = line;
  <A HREF="lparser.c.html#checknext">checknext</A>(ls, '(');
  if (needself) {
    <A HREF="lparser.c.html#new_localvarliteral">new_localvarliteral</A>(ls, "self", 0);
    <A HREF="lparser.c.html#adjustlocalvars">adjustlocalvars</A>(ls, 1);
  }
  <A HREF="lparser.c.html#parlist">parlist</A>(ls);
  <A HREF="lparser.c.html#checknext">checknext</A>(ls, ')');
  <A HREF="lparser.c.html#chunk">chunk</A>(ls);
  new_fs.f-&gt;lastlinedefined = ls-&gt;linenumber;
  <A HREF="lparser.c.html#check_match">check_match</A>(ls, <A HREF="llex.h.html#TK_END">TK_END</A>, <A HREF="llex.h.html#TK_FUNCTION">TK_FUNCTION</A>, line);
  <A HREF="lparser.c.html#close_func">close_func</A>(ls);
  <A HREF="lparser.c.html#pushclosure">pushclosure</A>(ls, &amp;new_fs, e);
}


static int <A NAME="explist1"><SPAN CLASS="definition">explist1</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, <A HREF="lparser.h.html#expdesc">expdesc</A> *v) {
  /* <A HREF="lparser.c.html#explist1">explist1</A> -&gt; <A HREF="lparser.c.html#expr">expr</A> { `,' <A HREF="lparser.c.html#expr">expr</A> } */
  int n = 1;  /* at least one expression */
  <A HREF="lparser.c.html#expr">expr</A>(ls, v);
  while (<A HREF="lparser.c.html#testnext">testnext</A>(ls, ',')) {
    <A HREF="lcode.c.html#luaK_exp2nextreg">luaK_exp2nextreg</A>(ls-&gt;fs, v);
    <A HREF="lparser.c.html#expr">expr</A>(ls, v);
    n++;
  }
  return n;
}


static void <A NAME="funcargs"><SPAN CLASS="definition">funcargs</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, <A HREF="lparser.h.html#expdesc">expdesc</A> *f) {
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  <A HREF="lparser.h.html#expdesc">expdesc</A> args;
  int base, nparams;
  int line = ls-&gt;linenumber;
  switch (ls-&gt;t.token) {
    case '(': {  /* <A HREF="lparser.c.html#funcargs">funcargs</A> -&gt; `(' [ <A HREF="lparser.c.html#explist1">explist1</A> ] `)' */
      if (line != ls-&gt;lastline)
        <A HREF="llex.c.html#luaX_syntaxerror">luaX_syntaxerror</A>(ls,"ambiguous syntax (function call x new <A HREF="lparser.c.html#statement">statement</A>)");
      <A HREF="llex.c.html#luaX_next">luaX_next</A>(ls);
      if (ls-&gt;t.token == ')')  /* arg list is empty? */
        args.k = <A HREF="lparser.h.html#VVOID">VVOID</A>;
      else {
        <A HREF="lparser.c.html#explist1">explist1</A>(ls, &amp;args);
        <A HREF="lcode.h.html#luaK_setmultret">luaK_setmultret</A>(fs, &amp;args);
      }
      <A HREF="lparser.c.html#check_match">check_match</A>(ls, ')', '(', line);
      break;
    }
    case '{': {  /* <A HREF="lparser.c.html#funcargs">funcargs</A> -&gt; <A HREF="lparser.c.html#constructor">constructor</A> */
      <A HREF="lparser.c.html#constructor">constructor</A>(ls, &amp;args);
      break;
    }
    case <A HREF="llex.h.html#TK_STRING">TK_STRING</A>: {  /* <A HREF="lparser.c.html#funcargs">funcargs</A> -&gt; STRING */
      <A HREF="lparser.c.html#codestring">codestring</A>(ls, &amp;args, ls-&gt;t.seminfo.ts);
      <A HREF="llex.c.html#luaX_next">luaX_next</A>(ls);  /* must use `seminfo' before `next' */
      break;
    }
    default: {
      <A HREF="llex.c.html#luaX_syntaxerror">luaX_syntaxerror</A>(ls, "function arguments expected");
      return;
    }
  }
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(f-&gt;k == <A HREF="lparser.h.html#VNONRELOC">VNONRELOC</A>);
  base = f-&gt;u.s.info;  /* base register for call */
  if (<A HREF="lparser.c.html#hasmultret">hasmultret</A>(args.k))
    nparams = <A HREF="lua.h.html#LUA_MULTRET">LUA_MULTRET</A>;  /* open call */
  else {
    if (args.k != <A HREF="lparser.h.html#VVOID">VVOID</A>)
      <A HREF="lcode.c.html#luaK_exp2nextreg">luaK_exp2nextreg</A>(fs, &amp;args);  /* close last argument */
    nparams = fs-&gt;freereg - (base+1);
  }
  <A HREF="lparser.c.html#init_exp">init_exp</A>(f, <A HREF="lparser.h.html#VCALL">VCALL</A>, <A HREF="lcode.c.html#luaK_codeABC">luaK_codeABC</A>(fs, <A HREF="lopcodes.h.html#OP_CALL">OP_CALL</A>, base, nparams+1, 2));
  <A HREF="lcode.c.html#luaK_fixline">luaK_fixline</A>(fs, line);
  fs-&gt;freereg = base+1;  /* call remove function and arguments and leaves
                            (unless changed) one result */
}




/*
** {======================================================================
** Expression parsing
** =======================================================================
*/


static void <A NAME="prefixexp"><SPAN CLASS="definition">prefixexp</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, <A HREF="lparser.h.html#expdesc">expdesc</A> *v) {
  /* <A HREF="lparser.c.html#prefixexp">prefixexp</A> -&gt; NAME | '(' <A HREF="lparser.c.html#expr">expr</A> ')' */
  switch (ls-&gt;t.token) {
    case '(': {
      int line = ls-&gt;linenumber;
      <A HREF="llex.c.html#luaX_next">luaX_next</A>(ls);
      <A HREF="lparser.c.html#expr">expr</A>(ls, v);
      <A HREF="lparser.c.html#check_match">check_match</A>(ls, ')', '(', line);
      <A HREF="lcode.c.html#luaK_dischargevars">luaK_dischargevars</A>(ls-&gt;fs, v);
      return;
    }
    case <A HREF="llex.h.html#TK_NAME">TK_NAME</A>: {
      <A HREF="lparser.c.html#singlevar">singlevar</A>(ls, v);
      return;
    }
    default: {
      <A HREF="llex.c.html#luaX_syntaxerror">luaX_syntaxerror</A>(ls, "unexpected symbol");
      return;
    }
  }
}


static void <A NAME="primaryexp"><SPAN CLASS="definition">primaryexp</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, <A HREF="lparser.h.html#expdesc">expdesc</A> *v) {
  /* <A HREF="lparser.c.html#primaryexp">primaryexp</A> -&gt;
        <A HREF="lparser.c.html#prefixexp">prefixexp</A> { `.' NAME | `[' exp `]' | `:' NAME <A HREF="lparser.c.html#funcargs">funcargs</A> | <A HREF="lparser.c.html#funcargs">funcargs</A> } */
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  <A HREF="lparser.c.html#prefixexp">prefixexp</A>(ls, v);
  for (;;) {
    switch (ls-&gt;t.token) {
      case '.': {  /* <A HREF="lparser.c.html#field">field</A> */
        <A HREF="lparser.c.html#field">field</A>(ls, v);
        break;
      }
      case '[': {  /* `[' <A HREF="lparser.c.html#exp1">exp1</A> `]' */
        <A HREF="lparser.h.html#expdesc">expdesc</A> key;
        <A HREF="lcode.c.html#luaK_exp2anyreg">luaK_exp2anyreg</A>(fs, v);
        <A HREF="lparser.c.html#yindex">yindex</A>(ls, &amp;key);
        <A HREF="lcode.c.html#luaK_indexed">luaK_indexed</A>(fs, v, &amp;key);
        break;
      }
      case ':': {  /* `:' NAME <A HREF="lparser.c.html#funcargs">funcargs</A> */
        <A HREF="lparser.h.html#expdesc">expdesc</A> key;
        <A HREF="llex.c.html#luaX_next">luaX_next</A>(ls);
        <A HREF="lparser.c.html#checkname">checkname</A>(ls, &amp;key);
        <A HREF="lcode.c.html#luaK_self">luaK_self</A>(fs, v, &amp;key);
        <A HREF="lparser.c.html#funcargs">funcargs</A>(ls, v);
        break;
      }
      case '(': case <A HREF="llex.h.html#TK_STRING">TK_STRING</A>: case '{': {  /* <A HREF="lparser.c.html#funcargs">funcargs</A> */
        <A HREF="lcode.c.html#luaK_exp2nextreg">luaK_exp2nextreg</A>(fs, v);
        <A HREF="lparser.c.html#funcargs">funcargs</A>(ls, v);
        break;
      }
      default: return;
    }
  }
}


static void <A NAME="simpleexp"><SPAN CLASS="definition">simpleexp</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, <A HREF="lparser.h.html#expdesc">expdesc</A> *v) {
  /* <A HREF="lparser.c.html#simpleexp">simpleexp</A> -&gt; NUMBER | STRING | NIL | true | false | ... |
                  <A HREF="lparser.c.html#constructor">constructor</A> | FUNCTION <A HREF="lparser.c.html#body">body</A> | <A HREF="lparser.c.html#primaryexp">primaryexp</A> */
  switch (ls-&gt;t.token) {
    case <A HREF="llex.h.html#TK_NUMBER">TK_NUMBER</A>: {
      <A HREF="lparser.c.html#init_exp">init_exp</A>(v, <A HREF="lparser.h.html#VKNUM">VKNUM</A>, 0);
      v-&gt;u.nval = ls-&gt;t.seminfo.r;
      break;
    }
    case <A HREF="llex.h.html#TK_STRING">TK_STRING</A>: {
      <A HREF="lparser.c.html#codestring">codestring</A>(ls, v, ls-&gt;t.seminfo.ts);
      break;
    }
    case <A HREF="llex.h.html#TK_NIL">TK_NIL</A>: {
      <A HREF="lparser.c.html#init_exp">init_exp</A>(v, <A HREF="lparser.h.html#VNIL">VNIL</A>, 0);
      break;
    }
    case <A HREF="llex.h.html#TK_TRUE">TK_TRUE</A>: {
      <A HREF="lparser.c.html#init_exp">init_exp</A>(v, <A HREF="lparser.h.html#VTRUE">VTRUE</A>, 0);
      break;
    }
    case <A HREF="llex.h.html#TK_FALSE">TK_FALSE</A>: {
      <A HREF="lparser.c.html#init_exp">init_exp</A>(v, <A HREF="lparser.h.html#VFALSE">VFALSE</A>, 0);
      break;
    }
    case <A HREF="llex.h.html#TK_DOTS">TK_DOTS</A>: {  /* vararg */
      <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
      <A HREF="lparser.c.html#check_condition">check_condition</A>(ls, fs-&gt;f-&gt;is_vararg,
                      "cannot use " <A HREF="luaconf.h.html#LUA_QL">LUA_QL</A>("...") " outside a vararg function");
      fs-&gt;f-&gt;is_vararg &amp;= ~<A HREF="lobject.h.html#VARARG_NEEDSARG">VARARG_NEEDSARG</A>;  /* don't need 'arg' */
      <A HREF="lparser.c.html#init_exp">init_exp</A>(v, <A HREF="lparser.h.html#VVARARG">VVARARG</A>, <A HREF="lcode.c.html#luaK_codeABC">luaK_codeABC</A>(fs, <A HREF="lopcodes.h.html#OP_VARARG">OP_VARARG</A>, 0, 1, 0));
      break;
    }
    case '{': {  /* <A HREF="lparser.c.html#constructor">constructor</A> */
      <A HREF="lparser.c.html#constructor">constructor</A>(ls, v);
      return;
    }
    case <A HREF="llex.h.html#TK_FUNCTION">TK_FUNCTION</A>: {
      <A HREF="llex.c.html#luaX_next">luaX_next</A>(ls);
      <A HREF="lparser.c.html#body">body</A>(ls, v, 0, ls-&gt;linenumber);
      return;
    }
    default: {
      <A HREF="lparser.c.html#primaryexp">primaryexp</A>(ls, v);
      return;
    }
  }
  <A HREF="llex.c.html#luaX_next">luaX_next</A>(ls);
}


static <A HREF="lcode.h.html#UnOpr">UnOpr</A> <A NAME="getunopr"><SPAN CLASS="definition">getunopr</SPAN></A> (int op) {
  switch (op) {
    case <A HREF="llex.h.html#TK_NOT">TK_NOT</A>: return <A HREF="lcode.h.html#OPR_NOT">OPR_NOT</A>;
    case '-': return <A HREF="lcode.h.html#OPR_MINUS">OPR_MINUS</A>;
    case '#': return <A HREF="lcode.h.html#OPR_LEN">OPR_LEN</A>;
    default: return <A HREF="lcode.h.html#OPR_NOUNOPR">OPR_NOUNOPR</A>;
  }
}


static <A HREF="lcode.h.html#BinOpr">BinOpr</A> <A NAME="getbinopr"><SPAN CLASS="definition">getbinopr</SPAN></A> (int op) {
  switch (op) {
    case '+': return <A HREF="lcode.h.html#OPR_ADD">OPR_ADD</A>;
    case '-': return <A HREF="lcode.h.html#OPR_SUB">OPR_SUB</A>;
    case '*': return <A HREF="lcode.h.html#OPR_MUL">OPR_MUL</A>;
    case '/': return <A HREF="lcode.h.html#OPR_DIV">OPR_DIV</A>;
    case '%': return <A HREF="lcode.h.html#OPR_MOD">OPR_MOD</A>;
    case '^': return <A HREF="lcode.h.html#OPR_POW">OPR_POW</A>;
    case <A HREF="llex.h.html#TK_CONCAT">TK_CONCAT</A>: return <A HREF="lcode.h.html#OPR_CONCAT">OPR_CONCAT</A>;
    case <A HREF="llex.h.html#TK_NE">TK_NE</A>: return <A HREF="lcode.h.html#OPR_NE">OPR_NE</A>;
    case <A HREF="llex.h.html#TK_EQ">TK_EQ</A>: return <A HREF="lcode.h.html#OPR_EQ">OPR_EQ</A>;
    case '&lt;': return <A HREF="lcode.h.html#OPR_LT">OPR_LT</A>;
    case <A HREF="llex.h.html#TK_LE">TK_LE</A>: return <A HREF="lcode.h.html#OPR_LE">OPR_LE</A>;
    case '&gt;': return <A HREF="lcode.h.html#OPR_GT">OPR_GT</A>;
    case <A HREF="llex.h.html#TK_GE">TK_GE</A>: return <A HREF="lcode.h.html#OPR_GE">OPR_GE</A>;
    case <A HREF="llex.h.html#TK_AND">TK_AND</A>: return <A HREF="lcode.h.html#OPR_AND">OPR_AND</A>;
    case <A HREF="llex.h.html#TK_OR">TK_OR</A>: return <A HREF="lcode.h.html#OPR_OR">OPR_OR</A>;
    default: return <A HREF="lcode.h.html#OPR_NOBINOPR">OPR_NOBINOPR</A>;
  }
}


static const struct {
  <A HREF="llimits.h.html#lu_byte">lu_byte</A> left;  /* left <A HREF="lparser.c.html#priority">priority</A> for each binary operator */
  <A HREF="llimits.h.html#lu_byte">lu_byte</A> right; /* right <A HREF="lparser.c.html#priority">priority</A> */
} <A NAME="priority"><SPAN CLASS="definition">priority</SPAN></A>[] = {  /* ORDER OPR */
   {6, 6}, {6, 6}, {7, 7}, {7, 7}, {7, 7},  /* `+' `-' `/' `%' */
   {10, 9}, {5, 4},                 /* power and concat (right associative) */
   {3, 3}, {3, 3},                  /* equality and inequality */
   {3, 3}, {3, 3}, {3, 3}, {3, 3},  /* order */
   {2, 2}, {1, 1}                   /* logical (and/or) */
};

#define <A NAME="UNARY_PRIORITY"><SPAN CLASS="definition">UNARY_PRIORITY</SPAN></A>  8  /* <A HREF="lparser.c.html#priority">priority</A> for unary operators */


/*
** <A HREF="lparser.c.html#subexpr">subexpr</A> -&gt; (<A HREF="lparser.c.html#simpleexp">simpleexp</A> | unop <A HREF="lparser.c.html#subexpr">subexpr</A>) { binop <A HREF="lparser.c.html#subexpr">subexpr</A> }
** where `binop' is any binary operator with a <A HREF="lparser.c.html#priority">priority</A> higher than `limit'
*/
static <A HREF="lcode.h.html#BinOpr">BinOpr</A> <A NAME="subexpr"><SPAN CLASS="definition">subexpr</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, <A HREF="lparser.h.html#expdesc">expdesc</A> *v, unsigned int limit) {
  <A HREF="lcode.h.html#BinOpr">BinOpr</A> op;
  <A HREF="lcode.h.html#UnOpr">UnOpr</A> uop;
  <A HREF="lparser.c.html#enterlevel">enterlevel</A>(ls);
  uop = <A HREF="lparser.c.html#getunopr">getunopr</A>(ls-&gt;t.token);
  if (uop != <A HREF="lcode.h.html#OPR_NOUNOPR">OPR_NOUNOPR</A>) {
    <A HREF="llex.c.html#luaX_next">luaX_next</A>(ls);
    <A HREF="lparser.c.html#subexpr">subexpr</A>(ls, v, <A HREF="lparser.c.html#UNARY_PRIORITY">UNARY_PRIORITY</A>);
    <A HREF="lcode.c.html#luaK_prefix">luaK_prefix</A>(ls-&gt;fs, uop, v);
  }
  else <A HREF="lparser.c.html#simpleexp">simpleexp</A>(ls, v);
  /* expand while operators have priorities higher than `limit' */
  op = <A HREF="lparser.c.html#getbinopr">getbinopr</A>(ls-&gt;t.token);
  while (op != <A HREF="lcode.h.html#OPR_NOBINOPR">OPR_NOBINOPR</A> &amp;&amp; <A HREF="lparser.c.html#priority">priority</A>[op].left &gt; limit) {
    <A HREF="lparser.h.html#expdesc">expdesc</A> v2;
    <A HREF="lcode.h.html#BinOpr">BinOpr</A> nextop;
    <A HREF="llex.c.html#luaX_next">luaX_next</A>(ls);
    <A HREF="lcode.c.html#luaK_infix">luaK_infix</A>(ls-&gt;fs, op, v);
    /* read sub-expression with higher <A HREF="lparser.c.html#priority">priority</A> */
    nextop = <A HREF="lparser.c.html#subexpr">subexpr</A>(ls, &amp;v2, <A HREF="lparser.c.html#priority">priority</A>[op].right);
    <A HREF="lcode.c.html#luaK_posfix">luaK_posfix</A>(ls-&gt;fs, op, v, &amp;v2);
    op = nextop;
  }
  <A HREF="lparser.c.html#leavelevel">leavelevel</A>(ls);
  return op;  /* return first untreated operator */
}


static void <A NAME="expr"><SPAN CLASS="definition">expr</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, <A HREF="lparser.h.html#expdesc">expdesc</A> *v) {
  <A HREF="lparser.c.html#subexpr">subexpr</A>(ls, v, 0);
}

/* }==================================================================== */



/*
** {======================================================================
** Rules for Statements
** =======================================================================
*/


static int <A NAME="block_follow"><SPAN CLASS="definition">block_follow</SPAN></A> (int token) {
  switch (token) {
    case <A HREF="llex.h.html#TK_ELSE">TK_ELSE</A>: case <A HREF="llex.h.html#TK_ELSEIF">TK_ELSEIF</A>: case <A HREF="llex.h.html#TK_END">TK_END</A>:
    case <A HREF="llex.h.html#TK_UNTIL">TK_UNTIL</A>: case <A HREF="llex.h.html#TK_EOS">TK_EOS</A>:
      return 1;
    default: return 0;
  }
}


static void <A NAME="block"><SPAN CLASS="definition">block</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls) {
  /* <A HREF="lparser.c.html#block">block</A> -&gt; <A HREF="lparser.c.html#chunk">chunk</A> */
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  <A HREF="lparser.c.html#BlockCnt">BlockCnt</A> bl;
  <A HREF="lparser.c.html#enterblock">enterblock</A>(fs, &amp;bl, 0);
  <A HREF="lparser.c.html#chunk">chunk</A>(ls);
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(bl.breaklist == <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>);
  <A HREF="lparser.c.html#leaveblock">leaveblock</A>(fs);
}


/*
** structure to chain all variables in the left-hand side of an
** <A HREF="lparser.c.html#assignment">assignment</A>
*/
struct <A NAME="LHS_assign"><SPAN CLASS="definition">LHS_assign</SPAN></A> {
  struct <A HREF="lparser.c.html#LHS_assign">LHS_assign</A> *prev;
  <A HREF="lparser.h.html#expdesc">expdesc</A> v;  /* variable (global, local, upvalue, or indexed) */
};


/*
** <A HREF="lparser.c.html#check">check</A> whether, in an <A HREF="lparser.c.html#assignment">assignment</A> to a local variable, the local variable
** is needed in a previous <A HREF="lparser.c.html#assignment">assignment</A> (to a table). If so, save original
** local value in a safe place and use this safe copy in the previous
** <A HREF="lparser.c.html#assignment">assignment</A>.
*/
static void <A NAME="check_conflict"><SPAN CLASS="definition">check_conflict</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, struct <A HREF="lparser.c.html#LHS_assign">LHS_assign</A> *lh, <A HREF="lparser.h.html#expdesc">expdesc</A> *v) {
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  int extra = fs-&gt;freereg;  /* eventual position to save local variable */
  int conflict = 0;
  for (; lh; lh = lh-&gt;prev) {
    if (lh-&gt;v.k == <A HREF="lparser.h.html#VINDEXED">VINDEXED</A>) {
      if (lh-&gt;v.u.s.info == v-&gt;u.s.info) {  /* conflict? */
        conflict = 1;
        lh-&gt;v.u.s.info = extra;  /* previous <A HREF="lparser.c.html#assignment">assignment</A> will use safe copy */
      }
      if (lh-&gt;v.u.s.aux == v-&gt;u.s.info) {  /* conflict? */
        conflict = 1;
        lh-&gt;v.u.s.aux = extra;  /* previous <A HREF="lparser.c.html#assignment">assignment</A> will use safe copy */
      }
    }
  }
  if (conflict) {
    <A HREF="lcode.c.html#luaK_codeABC">luaK_codeABC</A>(fs, <A HREF="lopcodes.h.html#OP_MOVE">OP_MOVE</A>, fs-&gt;freereg, v-&gt;u.s.info, 0);  /* make copy */
    <A HREF="lcode.c.html#luaK_reserveregs">luaK_reserveregs</A>(fs, 1);
  }
}


static void <A NAME="assignment"><SPAN CLASS="definition">assignment</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, struct <A HREF="lparser.c.html#LHS_assign">LHS_assign</A> *lh, int nvars) {
  <A HREF="lparser.h.html#expdesc">expdesc</A> e;
  <A HREF="lparser.c.html#check_condition">check_condition</A>(ls, <A HREF="lparser.h.html#VLOCAL">VLOCAL</A> &lt;= lh-&gt;v.k &amp;&amp; lh-&gt;v.k &lt;= <A HREF="lparser.h.html#VINDEXED">VINDEXED</A>,
                      "syntax error");
  if (<A HREF="lparser.c.html#testnext">testnext</A>(ls, ',')) {  /* <A HREF="lparser.c.html#assignment">assignment</A> -&gt; `,' <A HREF="lparser.c.html#primaryexp">primaryexp</A> <A HREF="lparser.c.html#assignment">assignment</A> */
    struct <A HREF="lparser.c.html#LHS_assign">LHS_assign</A> nv;
    nv.prev = lh;
    <A HREF="lparser.c.html#primaryexp">primaryexp</A>(ls, &amp;nv.v);
    if (nv.v.k == <A HREF="lparser.h.html#VLOCAL">VLOCAL</A>)
      <A HREF="lparser.c.html#check_conflict">check_conflict</A>(ls, lh, &amp;nv.v);
    <A HREF="lparser.c.html#luaY_checklimit">luaY_checklimit</A>(ls-&gt;fs, nvars, <A HREF="luaconf.h.html#LUAI_MAXCCALLS">LUAI_MAXCCALLS</A> - ls-&gt;L-&gt;nCcalls,
                    "variables in <A HREF="lparser.c.html#assignment">assignment</A>");
    <A HREF="lparser.c.html#assignment">assignment</A>(ls, &amp;nv, nvars+1);
  }
  else {  /* <A HREF="lparser.c.html#assignment">assignment</A> -&gt; `=' <A HREF="lparser.c.html#explist1">explist1</A> */
    int nexps;
    <A HREF="lparser.c.html#checknext">checknext</A>(ls, '=');
    nexps = <A HREF="lparser.c.html#explist1">explist1</A>(ls, &amp;e);
    if (nexps != nvars) {
      <A HREF="lparser.c.html#adjust_assign">adjust_assign</A>(ls, nvars, nexps, &amp;e);
      if (nexps &gt; nvars)
        ls-&gt;fs-&gt;freereg -= nexps - nvars;  /* remove extra values */
    }
    else {
      <A HREF="lcode.c.html#luaK_setoneret">luaK_setoneret</A>(ls-&gt;fs, &amp;e);  /* close last expression */
      <A HREF="lcode.c.html#luaK_storevar">luaK_storevar</A>(ls-&gt;fs, &amp;lh-&gt;v, &amp;e);
      return;  /* avoid default */
    }
  }
  <A HREF="lparser.c.html#init_exp">init_exp</A>(&amp;e, <A HREF="lparser.h.html#VNONRELOC">VNONRELOC</A>, ls-&gt;fs-&gt;freereg-1);  /* default <A HREF="lparser.c.html#assignment">assignment</A> */
  <A HREF="lcode.c.html#luaK_storevar">luaK_storevar</A>(ls-&gt;fs, &amp;lh-&gt;v, &amp;e);
}


static int <A NAME="cond"><SPAN CLASS="definition">cond</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls) {
  /* <A HREF="lparser.c.html#cond">cond</A> -&gt; exp */
  <A HREF="lparser.h.html#expdesc">expdesc</A> v;
  <A HREF="lparser.c.html#expr">expr</A>(ls, &amp;v);  /* read condition */
  if (v.k == <A HREF="lparser.h.html#VNIL">VNIL</A>) v.k = <A HREF="lparser.h.html#VFALSE">VFALSE</A>;  /* `falses' are all equal here */
  <A HREF="lcode.c.html#luaK_goiftrue">luaK_goiftrue</A>(ls-&gt;fs, &amp;v);
  return v.f;
}


static void <A NAME="breakstat"><SPAN CLASS="definition">breakstat</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls) {
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  <A HREF="lparser.c.html#BlockCnt">BlockCnt</A> *bl = fs-&gt;bl;
  int upval = 0;
  while (bl &amp;&amp; !bl-&gt;isbreakable) {
    upval |= bl-&gt;upval;
    bl = bl-&gt;previous;
  }
  if (!bl)
    <A HREF="llex.c.html#luaX_syntaxerror">luaX_syntaxerror</A>(ls, "no loop to break");
  if (upval)
    <A HREF="lcode.c.html#luaK_codeABC">luaK_codeABC</A>(fs, <A HREF="lopcodes.h.html#OP_CLOSE">OP_CLOSE</A>, bl-&gt;nactvar, 0, 0);
  <A HREF="lcode.c.html#luaK_concat">luaK_concat</A>(fs, &amp;bl-&gt;breaklist, <A HREF="lcode.c.html#luaK_jump">luaK_jump</A>(fs));
}


static void <A NAME="whilestat"><SPAN CLASS="definition">whilestat</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, int line) {
  /* <A HREF="lparser.c.html#whilestat">whilestat</A> -&gt; WHILE <A HREF="lparser.c.html#cond">cond</A> DO <A HREF="lparser.c.html#block">block</A> END */
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  int whileinit;
  int condexit;
  <A HREF="lparser.c.html#BlockCnt">BlockCnt</A> bl;
  <A HREF="llex.c.html#luaX_next">luaX_next</A>(ls);  /* skip WHILE */
  whileinit = <A HREF="lcode.c.html#luaK_getlabel">luaK_getlabel</A>(fs);
  condexit = <A HREF="lparser.c.html#cond">cond</A>(ls);
  <A HREF="lparser.c.html#enterblock">enterblock</A>(fs, &amp;bl, 1);
  <A HREF="lparser.c.html#checknext">checknext</A>(ls, <A HREF="llex.h.html#TK_DO">TK_DO</A>);
  <A HREF="lparser.c.html#block">block</A>(ls);
  <A HREF="lcode.c.html#luaK_patchlist">luaK_patchlist</A>(fs, <A HREF="lcode.c.html#luaK_jump">luaK_jump</A>(fs), whileinit);
  <A HREF="lparser.c.html#check_match">check_match</A>(ls, <A HREF="llex.h.html#TK_END">TK_END</A>, <A HREF="llex.h.html#TK_WHILE">TK_WHILE</A>, line);
  <A HREF="lparser.c.html#leaveblock">leaveblock</A>(fs);
  <A HREF="lcode.c.html#luaK_patchtohere">luaK_patchtohere</A>(fs, condexit);  /* false conditions finish the loop */
}


static void <A NAME="repeatstat"><SPAN CLASS="definition">repeatstat</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, int line) {
  /* <A HREF="lparser.c.html#repeatstat">repeatstat</A> -&gt; REPEAT <A HREF="lparser.c.html#block">block</A> UNTIL <A HREF="lparser.c.html#cond">cond</A> */
  int condexit;
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  int repeat_init = <A HREF="lcode.c.html#luaK_getlabel">luaK_getlabel</A>(fs);
  <A HREF="lparser.c.html#BlockCnt">BlockCnt</A> bl1, bl2;
  <A HREF="lparser.c.html#enterblock">enterblock</A>(fs, &amp;bl1, 1);  /* loop <A HREF="lparser.c.html#block">block</A> */
  <A HREF="lparser.c.html#enterblock">enterblock</A>(fs, &amp;bl2, 0);  /* scope <A HREF="lparser.c.html#block">block</A> */
  <A HREF="llex.c.html#luaX_next">luaX_next</A>(ls);  /* skip REPEAT */
  <A HREF="lparser.c.html#chunk">chunk</A>(ls);
  <A HREF="lparser.c.html#check_match">check_match</A>(ls, <A HREF="llex.h.html#TK_UNTIL">TK_UNTIL</A>, <A HREF="llex.h.html#TK_REPEAT">TK_REPEAT</A>, line);
  condexit = <A HREF="lparser.c.html#cond">cond</A>(ls);  /* read condition (inside scope <A HREF="lparser.c.html#block">block</A>) */
  if (!bl2.upval) {  /* no upvalues? */
    <A HREF="lparser.c.html#leaveblock">leaveblock</A>(fs);  /* finish scope */
    <A HREF="lcode.c.html#luaK_patchlist">luaK_patchlist</A>(ls-&gt;fs, condexit, repeat_init);  /* close the loop */
  }
  else {  /* complete semantics when there are upvalues */
    <A HREF="lparser.c.html#breakstat">breakstat</A>(ls);  /* if condition then break */
    <A HREF="lcode.c.html#luaK_patchtohere">luaK_patchtohere</A>(ls-&gt;fs, condexit);  /* else... */
    <A HREF="lparser.c.html#leaveblock">leaveblock</A>(fs);  /* finish scope... */
    <A HREF="lcode.c.html#luaK_patchlist">luaK_patchlist</A>(ls-&gt;fs, <A HREF="lcode.c.html#luaK_jump">luaK_jump</A>(fs), repeat_init);  /* and repeat */
  }
  <A HREF="lparser.c.html#leaveblock">leaveblock</A>(fs);  /* finish loop */
}


static int <A NAME="exp1"><SPAN CLASS="definition">exp1</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls) {
  <A HREF="lparser.h.html#expdesc">expdesc</A> e;
  int k;
  <A HREF="lparser.c.html#expr">expr</A>(ls, &amp;e);
  k = e.k;
  <A HREF="lcode.c.html#luaK_exp2nextreg">luaK_exp2nextreg</A>(ls-&gt;fs, &amp;e);
  return k;
}


static void <A NAME="forbody"><SPAN CLASS="definition">forbody</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, int base, int line, int nvars, int isnum) {
  /* <A HREF="lparser.c.html#forbody">forbody</A> -&gt; DO <A HREF="lparser.c.html#block">block</A> */
  <A HREF="lparser.c.html#BlockCnt">BlockCnt</A> bl;
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  int prep, endfor;
  <A HREF="lparser.c.html#adjustlocalvars">adjustlocalvars</A>(ls, 3);  /* control variables */
  <A HREF="lparser.c.html#checknext">checknext</A>(ls, <A HREF="llex.h.html#TK_DO">TK_DO</A>);
  prep = isnum ? <A HREF="lcode.h.html#luaK_codeAsBx">luaK_codeAsBx</A>(fs, <A HREF="lopcodes.h.html#OP_FORPREP">OP_FORPREP</A>, base, <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>) : <A HREF="lcode.c.html#luaK_jump">luaK_jump</A>(fs);
  <A HREF="lparser.c.html#enterblock">enterblock</A>(fs, &amp;bl, 0);  /* scope for declared variables */
  <A HREF="lparser.c.html#adjustlocalvars">adjustlocalvars</A>(ls, nvars);
  <A HREF="lcode.c.html#luaK_reserveregs">luaK_reserveregs</A>(fs, nvars);
  <A HREF="lparser.c.html#block">block</A>(ls);
  <A HREF="lparser.c.html#leaveblock">leaveblock</A>(fs);  /* end of scope for declared variables */
  <A HREF="lcode.c.html#luaK_patchtohere">luaK_patchtohere</A>(fs, prep);
  endfor = (isnum) ? <A HREF="lcode.h.html#luaK_codeAsBx">luaK_codeAsBx</A>(fs, <A HREF="lopcodes.h.html#OP_FORLOOP">OP_FORLOOP</A>, base, <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>) :
                     <A HREF="lcode.c.html#luaK_codeABC">luaK_codeABC</A>(fs, <A HREF="lopcodes.h.html#OP_TFORLOOP">OP_TFORLOOP</A>, base, 0, nvars);
  <A HREF="lcode.c.html#luaK_fixline">luaK_fixline</A>(fs, line);  /* pretend that `OP_FOR' starts the loop */
  <A HREF="lcode.c.html#luaK_patchlist">luaK_patchlist</A>(fs, (isnum ? endfor : <A HREF="lcode.c.html#luaK_jump">luaK_jump</A>(fs)), prep + 1);
}


static void <A NAME="fornum"><SPAN CLASS="definition">fornum</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, <A HREF="lobject.h.html#TString">TString</A> *varname, int line) {
  /* <A HREF="lparser.c.html#fornum">fornum</A> -&gt; NAME = <A HREF="lparser.c.html#exp1">exp1</A>,<A HREF="lparser.c.html#exp1">exp1</A>[,<A HREF="lparser.c.html#exp1">exp1</A>] <A HREF="lparser.c.html#forbody">forbody</A> */
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  int base = fs-&gt;freereg;
  <A HREF="lparser.c.html#new_localvarliteral">new_localvarliteral</A>(ls, "(for index)", 0);
  <A HREF="lparser.c.html#new_localvarliteral">new_localvarliteral</A>(ls, "(for limit)", 1);
  <A HREF="lparser.c.html#new_localvarliteral">new_localvarliteral</A>(ls, "(for step)", 2);
  <A HREF="lparser.c.html#new_localvar">new_localvar</A>(ls, varname, 3);
  <A HREF="lparser.c.html#checknext">checknext</A>(ls, '=');
  <A HREF="lparser.c.html#exp1">exp1</A>(ls);  /* initial value */
  <A HREF="lparser.c.html#checknext">checknext</A>(ls, ',');
  <A HREF="lparser.c.html#exp1">exp1</A>(ls);  /* limit */
  if (<A HREF="lparser.c.html#testnext">testnext</A>(ls, ','))
    <A HREF="lparser.c.html#exp1">exp1</A>(ls);  /* optional step */
  else {  /* default step = 1 */
    <A HREF="lcode.c.html#luaK_codeABx">luaK_codeABx</A>(fs, <A HREF="lopcodes.h.html#OP_LOADK">OP_LOADK</A>, fs-&gt;freereg, <A HREF="lcode.c.html#luaK_numberK">luaK_numberK</A>(fs, 1));
    <A HREF="lcode.c.html#luaK_reserveregs">luaK_reserveregs</A>(fs, 1);
  }
  <A HREF="lparser.c.html#forbody">forbody</A>(ls, base, line, 1, 1);
}


static void <A NAME="forlist"><SPAN CLASS="definition">forlist</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, <A HREF="lobject.h.html#TString">TString</A> *indexname) {
  /* <A HREF="lparser.c.html#forlist">forlist</A> -&gt; NAME {,NAME} IN <A HREF="lparser.c.html#explist1">explist1</A> <A HREF="lparser.c.html#forbody">forbody</A> */
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  <A HREF="lparser.h.html#expdesc">expdesc</A> e;
  int nvars = 0;
  int line;
  int base = fs-&gt;freereg;
  /* create control variables */
  <A HREF="lparser.c.html#new_localvarliteral">new_localvarliteral</A>(ls, "(for generator)", nvars++);
  <A HREF="lparser.c.html#new_localvarliteral">new_localvarliteral</A>(ls, "(for state)", nvars++);
  <A HREF="lparser.c.html#new_localvarliteral">new_localvarliteral</A>(ls, "(for control)", nvars++);
  /* create declared variables */
  <A HREF="lparser.c.html#new_localvar">new_localvar</A>(ls, indexname, nvars++);
  while (<A HREF="lparser.c.html#testnext">testnext</A>(ls, ','))
    <A HREF="lparser.c.html#new_localvar">new_localvar</A>(ls, <A HREF="lparser.c.html#str_checkname">str_checkname</A>(ls), nvars++);
  <A HREF="lparser.c.html#checknext">checknext</A>(ls, <A HREF="llex.h.html#TK_IN">TK_IN</A>);
  line = ls-&gt;linenumber;
  <A HREF="lparser.c.html#adjust_assign">adjust_assign</A>(ls, 3, <A HREF="lparser.c.html#explist1">explist1</A>(ls, &amp;e), &amp;e);
  <A HREF="lcode.c.html#luaK_checkstack">luaK_checkstack</A>(fs, 3);  /* extra space to call generator */
  <A HREF="lparser.c.html#forbody">forbody</A>(ls, base, line, nvars - 3, 0);
}


static void <A NAME="forstat"><SPAN CLASS="definition">forstat</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, int line) {
  /* <A HREF="lparser.c.html#forstat">forstat</A> -&gt; FOR (<A HREF="lparser.c.html#fornum">fornum</A> | <A HREF="lparser.c.html#forlist">forlist</A>) END */
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  <A HREF="lobject.h.html#TString">TString</A> *varname;
  <A HREF="lparser.c.html#BlockCnt">BlockCnt</A> bl;
  <A HREF="lparser.c.html#enterblock">enterblock</A>(fs, &amp;bl, 1);  /* scope for loop and control variables */
  <A HREF="llex.c.html#luaX_next">luaX_next</A>(ls);  /* skip `for' */
  varname = <A HREF="lparser.c.html#str_checkname">str_checkname</A>(ls);  /* first variable name */
  switch (ls-&gt;t.token) {
    case '=': <A HREF="lparser.c.html#fornum">fornum</A>(ls, varname, line); break;
    case ',': case <A HREF="llex.h.html#TK_IN">TK_IN</A>: <A HREF="lparser.c.html#forlist">forlist</A>(ls, varname); break;
    default: <A HREF="llex.c.html#luaX_syntaxerror">luaX_syntaxerror</A>(ls, <A HREF="luaconf.h.html#LUA_QL">LUA_QL</A>("=") " or " <A HREF="luaconf.h.html#LUA_QL">LUA_QL</A>("in") " expected");
  }
  <A HREF="lparser.c.html#check_match">check_match</A>(ls, <A HREF="llex.h.html#TK_END">TK_END</A>, <A HREF="llex.h.html#TK_FOR">TK_FOR</A>, line);
  <A HREF="lparser.c.html#leaveblock">leaveblock</A>(fs);  /* loop scope (`break' jumps to this point) */
}


static int <A NAME="test_then_block"><SPAN CLASS="definition">test_then_block</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls) {
  /* <A HREF="lparser.c.html#test_then_block">test_then_block</A> -&gt; [IF | ELSEIF] <A HREF="lparser.c.html#cond">cond</A> THEN <A HREF="lparser.c.html#block">block</A> */
  int condexit;
  <A HREF="llex.c.html#luaX_next">luaX_next</A>(ls);  /* skip IF or ELSEIF */
  condexit = <A HREF="lparser.c.html#cond">cond</A>(ls);
  <A HREF="lparser.c.html#checknext">checknext</A>(ls, <A HREF="llex.h.html#TK_THEN">TK_THEN</A>);
  <A HREF="lparser.c.html#block">block</A>(ls);  /* `then' part */
  return condexit;
}


static void <A NAME="ifstat"><SPAN CLASS="definition">ifstat</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, int line) {
  /* <A HREF="lparser.c.html#ifstat">ifstat</A> -&gt; IF <A HREF="lparser.c.html#cond">cond</A> THEN <A HREF="lparser.c.html#block">block</A> {ELSEIF <A HREF="lparser.c.html#cond">cond</A> THEN <A HREF="lparser.c.html#block">block</A>} [ELSE <A HREF="lparser.c.html#block">block</A>] END */
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  int flist;
  int escapelist = <A HREF="lcode.h.html#NO_JUMP">NO_JUMP</A>;
  flist = <A HREF="lparser.c.html#test_then_block">test_then_block</A>(ls);  /* IF <A HREF="lparser.c.html#cond">cond</A> THEN <A HREF="lparser.c.html#block">block</A> */
  while (ls-&gt;t.token == <A HREF="llex.h.html#TK_ELSEIF">TK_ELSEIF</A>) {
    <A HREF="lcode.c.html#luaK_concat">luaK_concat</A>(fs, &amp;escapelist, <A HREF="lcode.c.html#luaK_jump">luaK_jump</A>(fs));
    <A HREF="lcode.c.html#luaK_patchtohere">luaK_patchtohere</A>(fs, flist);
    flist = <A HREF="lparser.c.html#test_then_block">test_then_block</A>(ls);  /* ELSEIF <A HREF="lparser.c.html#cond">cond</A> THEN <A HREF="lparser.c.html#block">block</A> */
  }
  if (ls-&gt;t.token == <A HREF="llex.h.html#TK_ELSE">TK_ELSE</A>) {
    <A HREF="lcode.c.html#luaK_concat">luaK_concat</A>(fs, &amp;escapelist, <A HREF="lcode.c.html#luaK_jump">luaK_jump</A>(fs));
    <A HREF="lcode.c.html#luaK_patchtohere">luaK_patchtohere</A>(fs, flist);
    <A HREF="llex.c.html#luaX_next">luaX_next</A>(ls);  /* skip ELSE (after patch, for correct line info) */
    <A HREF="lparser.c.html#block">block</A>(ls);  /* `else' part */
  }
  else
    <A HREF="lcode.c.html#luaK_concat">luaK_concat</A>(fs, &amp;escapelist, flist);
  <A HREF="lcode.c.html#luaK_patchtohere">luaK_patchtohere</A>(fs, escapelist);
  <A HREF="lparser.c.html#check_match">check_match</A>(ls, <A HREF="llex.h.html#TK_END">TK_END</A>, <A HREF="llex.h.html#TK_IF">TK_IF</A>, line);
}


static void <A NAME="localfunc"><SPAN CLASS="definition">localfunc</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls) {
  <A HREF="lparser.h.html#expdesc">expdesc</A> v, b;
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  <A HREF="lparser.c.html#new_localvar">new_localvar</A>(ls, <A HREF="lparser.c.html#str_checkname">str_checkname</A>(ls), 0);
  <A HREF="lparser.c.html#init_exp">init_exp</A>(&amp;v, <A HREF="lparser.h.html#VLOCAL">VLOCAL</A>, fs-&gt;freereg);
  <A HREF="lcode.c.html#luaK_reserveregs">luaK_reserveregs</A>(fs, 1);
  <A HREF="lparser.c.html#adjustlocalvars">adjustlocalvars</A>(ls, 1);
  <A HREF="lparser.c.html#body">body</A>(ls, &amp;b, 0, ls-&gt;linenumber);
  <A HREF="lcode.c.html#luaK_storevar">luaK_storevar</A>(fs, &amp;v, &amp;b);
  /* debug information will only see the variable after this point! */
  <A HREF="lparser.c.html#getlocvar">getlocvar</A>(fs, fs-&gt;nactvar - 1).startpc = fs-&gt;pc;
}


static void <A NAME="localstat"><SPAN CLASS="definition">localstat</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls) {
  /* stat -&gt; LOCAL NAME {`,' NAME} [`=' <A HREF="lparser.c.html#explist1">explist1</A>] */
  int nvars = 0;
  int nexps;
  <A HREF="lparser.h.html#expdesc">expdesc</A> e;
  do {
    <A HREF="lparser.c.html#new_localvar">new_localvar</A>(ls, <A HREF="lparser.c.html#str_checkname">str_checkname</A>(ls), nvars++);
  } while (<A HREF="lparser.c.html#testnext">testnext</A>(ls, ','));
  if (<A HREF="lparser.c.html#testnext">testnext</A>(ls, '='))
    nexps = <A HREF="lparser.c.html#explist1">explist1</A>(ls, &amp;e);
  else {
    e.k = <A HREF="lparser.h.html#VVOID">VVOID</A>;
    nexps = 0;
  }
  <A HREF="lparser.c.html#adjust_assign">adjust_assign</A>(ls, nvars, nexps, &amp;e);
  <A HREF="lparser.c.html#adjustlocalvars">adjustlocalvars</A>(ls, nvars);
}


static int <A NAME="funcname"><SPAN CLASS="definition">funcname</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, <A HREF="lparser.h.html#expdesc">expdesc</A> *v) {
  /* <A HREF="lparser.c.html#funcname">funcname</A> -&gt; NAME {<A HREF="lparser.c.html#field">field</A>} [`:' NAME] */
  int needself = 0;
  <A HREF="lparser.c.html#singlevar">singlevar</A>(ls, v);
  while (ls-&gt;t.token == '.')
    <A HREF="lparser.c.html#field">field</A>(ls, v);
  if (ls-&gt;t.token == ':') {
    needself = 1;
    <A HREF="lparser.c.html#field">field</A>(ls, v);
  }
  return needself;
}


static void <A NAME="funcstat"><SPAN CLASS="definition">funcstat</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls, int line) {
  /* <A HREF="lparser.c.html#funcstat">funcstat</A> -&gt; FUNCTION <A HREF="lparser.c.html#funcname">funcname</A> <A HREF="lparser.c.html#body">body</A> */
  int needself;
  <A HREF="lparser.h.html#expdesc">expdesc</A> v, b;
  <A HREF="llex.c.html#luaX_next">luaX_next</A>(ls);  /* skip FUNCTION */
  needself = <A HREF="lparser.c.html#funcname">funcname</A>(ls, &amp;v);
  <A HREF="lparser.c.html#body">body</A>(ls, &amp;b, needself, line);
  <A HREF="lcode.c.html#luaK_storevar">luaK_storevar</A>(ls-&gt;fs, &amp;v, &amp;b);
  <A HREF="lcode.c.html#luaK_fixline">luaK_fixline</A>(ls-&gt;fs, line);  /* definition `happens' in the first line */
}


static void <A NAME="exprstat"><SPAN CLASS="definition">exprstat</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls) {
  /* stat -&gt; func | <A HREF="lparser.c.html#assignment">assignment</A> */
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  struct <A HREF="lparser.c.html#LHS_assign">LHS_assign</A> v;
  <A HREF="lparser.c.html#primaryexp">primaryexp</A>(ls, &amp;v.v);
  if (v.v.k == <A HREF="lparser.h.html#VCALL">VCALL</A>)  /* stat -&gt; func */
    <A HREF="lopcodes.h.html#SETARG_C">SETARG_C</A>(<A HREF="lcode.h.html#getcode">getcode</A>(fs, &amp;v.v), 1);  /* call <A HREF="lparser.c.html#statement">statement</A> uses no results */
  else {  /* stat -&gt; <A HREF="lparser.c.html#assignment">assignment</A> */
    v.prev = NULL;
    <A HREF="lparser.c.html#assignment">assignment</A>(ls, &amp;v, 1);
  }
}


static void <A NAME="retstat"><SPAN CLASS="definition">retstat</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls) {
  /* stat -&gt; RETURN explist */
  <A HREF="lparser.h.html#FuncState">FuncState</A> *fs = ls-&gt;fs;
  <A HREF="lparser.h.html#expdesc">expdesc</A> e;
  int first, nret;  /* registers with returned values */
  <A HREF="llex.c.html#luaX_next">luaX_next</A>(ls);  /* skip RETURN */
  if (<A HREF="lparser.c.html#block_follow">block_follow</A>(ls-&gt;t.token) || ls-&gt;t.token == ';')
    first = nret = 0;  /* return no values */
  else {
    nret = <A HREF="lparser.c.html#explist1">explist1</A>(ls, &amp;e);  /* optional return values */
    if (<A HREF="lparser.c.html#hasmultret">hasmultret</A>(e.k)) {
      <A HREF="lcode.h.html#luaK_setmultret">luaK_setmultret</A>(fs, &amp;e);
      if (e.k == <A HREF="lparser.h.html#VCALL">VCALL</A> &amp;&amp; nret == 1) {  /* tail call? */
        <A HREF="lopcodes.h.html#SET_OPCODE">SET_OPCODE</A>(<A HREF="lcode.h.html#getcode">getcode</A>(fs,&amp;e), <A HREF="lopcodes.h.html#OP_TAILCALL">OP_TAILCALL</A>);
        <A HREF="llimits.h.html#lua_assert">lua_assert</A>(<A HREF="lopcodes.h.html#GETARG_A">GETARG_A</A>(<A HREF="lcode.h.html#getcode">getcode</A>(fs,&amp;e)) == fs-&gt;nactvar);
      }
      first = fs-&gt;nactvar;
      nret = <A HREF="lua.h.html#LUA_MULTRET">LUA_MULTRET</A>;  /* return all values */
    }
    else {
      if (nret == 1)  /* only one single value? */
        first = <A HREF="lcode.c.html#luaK_exp2anyreg">luaK_exp2anyreg</A>(fs, &amp;e);
      else {
        <A HREF="lcode.c.html#luaK_exp2nextreg">luaK_exp2nextreg</A>(fs, &amp;e);  /* values must go to the `stack' */
        first = fs-&gt;nactvar;  /* return all `active' values */
        <A HREF="llimits.h.html#lua_assert">lua_assert</A>(nret == fs-&gt;freereg - first);
      }
    }
  }
  <A HREF="lcode.c.html#luaK_ret">luaK_ret</A>(fs, first, nret);
}


static int <A NAME="statement"><SPAN CLASS="definition">statement</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls) {
  int line = ls-&gt;linenumber;  /* may be needed for error messages */
  switch (ls-&gt;t.token) {
    case <A HREF="llex.h.html#TK_IF">TK_IF</A>: {  /* stat -&gt; <A HREF="lparser.c.html#ifstat">ifstat</A> */
      <A HREF="lparser.c.html#ifstat">ifstat</A>(ls, line);
      return 0;
    }
    case <A HREF="llex.h.html#TK_WHILE">TK_WHILE</A>: {  /* stat -&gt; <A HREF="lparser.c.html#whilestat">whilestat</A> */
      <A HREF="lparser.c.html#whilestat">whilestat</A>(ls, line);
      return 0;
    }
    case <A HREF="llex.h.html#TK_DO">TK_DO</A>: {  /* stat -&gt; DO <A HREF="lparser.c.html#block">block</A> END */
      <A HREF="llex.c.html#luaX_next">luaX_next</A>(ls);  /* skip DO */
      <A HREF="lparser.c.html#block">block</A>(ls);
      <A HREF="lparser.c.html#check_match">check_match</A>(ls, <A HREF="llex.h.html#TK_END">TK_END</A>, <A HREF="llex.h.html#TK_DO">TK_DO</A>, line);
      return 0;
    }
    case <A HREF="llex.h.html#TK_FOR">TK_FOR</A>: {  /* stat -&gt; <A HREF="lparser.c.html#forstat">forstat</A> */
      <A HREF="lparser.c.html#forstat">forstat</A>(ls, line);
      return 0;
    }
    case <A HREF="llex.h.html#TK_REPEAT">TK_REPEAT</A>: {  /* stat -&gt; <A HREF="lparser.c.html#repeatstat">repeatstat</A> */
      <A HREF="lparser.c.html#repeatstat">repeatstat</A>(ls, line);
      return 0;
    }
    case <A HREF="llex.h.html#TK_FUNCTION">TK_FUNCTION</A>: {
      <A HREF="lparser.c.html#funcstat">funcstat</A>(ls, line);  /* stat -&gt; <A HREF="lparser.c.html#funcstat">funcstat</A> */
      return 0;
    }
    case <A HREF="llex.h.html#TK_LOCAL">TK_LOCAL</A>: {  /* stat -&gt; <A HREF="lparser.c.html#localstat">localstat</A> */
      <A HREF="llex.c.html#luaX_next">luaX_next</A>(ls);  /* skip LOCAL */
      if (<A HREF="lparser.c.html#testnext">testnext</A>(ls, <A HREF="llex.h.html#TK_FUNCTION">TK_FUNCTION</A>))  /* local function? */
        <A HREF="lparser.c.html#localfunc">localfunc</A>(ls);
      else
        <A HREF="lparser.c.html#localstat">localstat</A>(ls);
      return 0;
    }
    case <A HREF="llex.h.html#TK_RETURN">TK_RETURN</A>: {  /* stat -&gt; <A HREF="lparser.c.html#retstat">retstat</A> */
      <A HREF="lparser.c.html#retstat">retstat</A>(ls);
      return 1;  /* must be last <A HREF="lparser.c.html#statement">statement</A> */
    }
    case <A HREF="llex.h.html#TK_BREAK">TK_BREAK</A>: {  /* stat -&gt; <A HREF="lparser.c.html#breakstat">breakstat</A> */
      <A HREF="llex.c.html#luaX_next">luaX_next</A>(ls);  /* skip BREAK */
      <A HREF="lparser.c.html#breakstat">breakstat</A>(ls);
      return 1;  /* must be last <A HREF="lparser.c.html#statement">statement</A> */
    }
    default: {
      <A HREF="lparser.c.html#exprstat">exprstat</A>(ls);
      return 0;  /* to avoid warnings */
    }
  }
}


static void <A NAME="chunk"><SPAN CLASS="definition">chunk</SPAN></A> (<A HREF="llex.h.html#LexState">LexState</A> *ls) {
  /* <A HREF="lparser.c.html#chunk">chunk</A> -&gt; { stat [`;'] } */
  int islast = 0;
  <A HREF="lparser.c.html#enterlevel">enterlevel</A>(ls);
  while (!islast &amp;&amp; !<A HREF="lparser.c.html#block_follow">block_follow</A>(ls-&gt;t.token)) {
    islast = <A HREF="lparser.c.html#statement">statement</A>(ls);
    <A HREF="lparser.c.html#testnext">testnext</A>(ls, ';');
    <A HREF="llimits.h.html#lua_assert">lua_assert</A>(ls-&gt;fs-&gt;f-&gt;maxstacksize &gt;= ls-&gt;fs-&gt;freereg &amp;&amp;
               ls-&gt;fs-&gt;freereg &gt;= ls-&gt;fs-&gt;nactvar);
    ls-&gt;fs-&gt;freereg = ls-&gt;fs-&gt;nactvar;  /* free registers */
  }
  <A HREF="lparser.c.html#leavelevel">leavelevel</A>(ls);
}

/* }====================================================================== */
</PRE>

<P CLASS="footer">
Last update:
Sat Mar  5 09:19:55 2016
</P>

</BODY>
</HTML>
