<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Lua 5.2.4 source code - lgc.c</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../lua.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="../source.css">
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
</HEAD>

<BODY>

<H1>
<A HREF="../../home.html"><IMG SRC="../../images/logo.gif" ALT="Lua"></A>
lgc.c
<SPAN CLASS="note">(5.2.4)</SPAN>
</H1>

<DIV CLASS="menubar">
<A HREF="./">module index</A>
&middot;
<A HREF="idx.html">name index</A>
&middot;
<A HREF="../">other versions</A>
</DIV>

<PRE>
/*
** $Id: lgc.c,v 2.140.1.3 2014/09/01 16:55:08 roberto Exp $
** Garbage Collector
** See Copyright Notice in lua.h
*/

#include &lt;string.h&gt;

#define <A NAME="lgc_c"><SPAN CLASS="definition">lgc_c</SPAN></A>
#define <A NAME="LUA_CORE"><SPAN CLASS="definition">LUA_CORE</SPAN></A>

#include "<A HREF="lua.h.html">lua.h</A>"

#include "<A HREF="ldebug.h.html">ldebug.h</A>"
#include "<A HREF="ldo.h.html">ldo.h</A>"
#include "<A HREF="lfunc.h.html">lfunc.h</A>"
#include "<A HREF="lgc.h.html">lgc.h</A>"
#include "<A HREF="lmem.h.html">lmem.h</A>"
#include "<A HREF="lobject.h.html">lobject.h</A>"
#include "<A HREF="lstate.h.html">lstate.h</A>"
#include "<A HREF="lstring.h.html">lstring.h</A>"
#include "<A HREF="ltable.h.html">ltable.h</A>"
#include "<A HREF="ltm.h.html">ltm.h</A>"



/*
** cost of sweeping one element (the size of a small object divided
** by some adjust for the sweep speed)
*/
#define <A NAME="GCSWEEPCOST"><SPAN CLASS="definition">GCSWEEPCOST</SPAN></A>     ((sizeof(<A HREF="lobject.h.html#TString">TString</A>) + 4) / 4)

/* maximum number of elements to sweep in each single step */
#define <A NAME="GCSWEEPMAX"><SPAN CLASS="definition">GCSWEEPMAX</SPAN></A>      (<A HREF="llimits.h.html#cast_int">cast_int</A>((<A HREF="lgc.h.html#GCSTEPSIZE">GCSTEPSIZE</A> / <A HREF="lgc.c.html#GCSWEEPCOST">GCSWEEPCOST</A>) / 4))

/* maximum number of finalizers to call in each GC step */
#define <A NAME="GCFINALIZENUM"><SPAN CLASS="definition">GCFINALIZENUM</SPAN></A>   4


/*
** macro to adjust 'stepmul': 'stepmul' is actually used like
** 'stepmul / <A HREF="lgc.c.html#STEPMULADJ">STEPMULADJ</A>' (value chosen by tests)
*/
#define <A NAME="STEPMULADJ"><SPAN CLASS="definition">STEPMULADJ</SPAN></A>              200


/*
** macro to adjust 'pause': 'pause' is actually used like
** 'pause / <A HREF="lgc.c.html#PAUSEADJ">PAUSEADJ</A>' (value chosen by tests)
*/
#define <A NAME="PAUSEADJ"><SPAN CLASS="definition">PAUSEADJ</SPAN></A>                100


/*
** '<A HREF="lgc.c.html#makewhite">makewhite</A>' erases all color bits plus the old bit and then
** sets only the current white bit
*/
#define <A NAME="maskcolors"><SPAN CLASS="definition">maskcolors</SPAN></A>      (~(<A HREF="lgc.h.html#bit2mask">bit2mask</A>(<A HREF="lgc.h.html#BLACKBIT">BLACKBIT</A>, <A HREF="lgc.h.html#OLDBIT">OLDBIT</A>) | <A HREF="lgc.h.html#WHITEBITS">WHITEBITS</A>))
#define <A NAME="makewhite"><SPAN CLASS="definition">makewhite</SPAN></A>(g,x)  \
 (<A HREF="lstate.h.html#gch">gch</A>(x)-&gt;marked = <A HREF="llimits.h.html#cast_byte">cast_byte</A>((<A HREF="lstate.h.html#gch">gch</A>(x)-&gt;marked &amp; <A HREF="lgc.c.html#maskcolors">maskcolors</A>) | <A HREF="lgc.h.html#luaC_white">luaC_white</A>(g)))

#define <A NAME="white2gray"><SPAN CLASS="definition">white2gray</SPAN></A>(x)   <A HREF="lgc.h.html#resetbits">resetbits</A>(<A HREF="lstate.h.html#gch">gch</A>(x)-&gt;marked, <A HREF="lgc.h.html#WHITEBITS">WHITEBITS</A>)
#define <A NAME="black2gray"><SPAN CLASS="definition">black2gray</SPAN></A>(x)   <A HREF="lgc.h.html#resetbit">resetbit</A>(<A HREF="lstate.h.html#gch">gch</A>(x)-&gt;marked, <A HREF="lgc.h.html#BLACKBIT">BLACKBIT</A>)


#define <A NAME="isfinalized"><SPAN CLASS="definition">isfinalized</SPAN></A>(x)          <A HREF="lgc.h.html#testbit">testbit</A>(<A HREF="lstate.h.html#gch">gch</A>(x)-&gt;marked, <A HREF="lgc.h.html#FINALIZEDBIT">FINALIZEDBIT</A>)

#define <A NAME="checkdeadkey"><SPAN CLASS="definition">checkdeadkey</SPAN></A>(n) <A HREF="llimits.h.html#lua_assert">lua_assert</A>(!<A HREF="lobject.h.html#ttisdeadkey">ttisdeadkey</A>(<A HREF="ltable.h.html#gkey">gkey</A>(n)) || <A HREF="lobject.h.html#ttisnil">ttisnil</A>(<A HREF="ltable.h.html#gval">gval</A>(n)))


#define <A NAME="checkconsistency"><SPAN CLASS="definition">checkconsistency</SPAN></A>(obj)  \
  <A HREF="llimits.h.html#lua_longassert">lua_longassert</A>(!<A HREF="lobject.h.html#iscollectable">iscollectable</A>(obj) || <A HREF="lobject.h.html#righttt">righttt</A>(obj))


#define <A NAME="markvalue"><SPAN CLASS="definition">markvalue</SPAN></A>(g,o) { <A HREF="lgc.c.html#checkconsistency">checkconsistency</A>(o); \
  if (<A HREF="lgc.h.html#valiswhite">valiswhite</A>(o)) <A HREF="lgc.c.html#reallymarkobject">reallymarkobject</A>(g,<A HREF="lobject.h.html#gcvalue">gcvalue</A>(o)); }

#define <A NAME="markobject"><SPAN CLASS="definition">markobject</SPAN></A>(g,t) { if ((t) &amp;&amp; <A HREF="lgc.h.html#iswhite">iswhite</A>(<A HREF="lstate.h.html#obj2gco">obj2gco</A>(t))) \
                <A HREF="lgc.c.html#reallymarkobject">reallymarkobject</A>(g, <A HREF="lstate.h.html#obj2gco">obj2gco</A>(t)); }

static void <A HREF="lgc.c.html#reallymarkobject">reallymarkobject</A> (<A HREF="lstate.h.html#global_State">global_State</A> *g, <A HREF="lstate.h.html#GCObject">GCObject</A> *o);


/*
** {======================================================
** Generic functions
** =======================================================
*/


/*
** one after last element in a hash array
*/
#define <A NAME="gnodelast"><SPAN CLASS="definition">gnodelast</SPAN></A>(h)    <A HREF="ltable.h.html#gnode">gnode</A>(h, <A HREF="llimits.h.html#cast">cast</A>(size_t, <A HREF="lobject.h.html#sizenode">sizenode</A>(h)))


/*
** link table 'h' into list pointed by 'p'
*/
#define <A NAME="linktable"><SPAN CLASS="definition">linktable</SPAN></A>(h,p)  ((h)-&gt;gclist = *(p), *(p) = <A HREF="lstate.h.html#obj2gco">obj2gco</A>(h))


/*
** if key is not marked, mark its entry as dead (therefore removing it
** from the table)
*/
static void <A NAME="removeentry"><SPAN CLASS="definition">removeentry</SPAN></A> (<A HREF="lobject.h.html#Node">Node</A> *n) {
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(<A HREF="lobject.h.html#ttisnil">ttisnil</A>(<A HREF="ltable.h.html#gval">gval</A>(n)));
  if (<A HREF="lgc.h.html#valiswhite">valiswhite</A>(<A HREF="ltable.h.html#gkey">gkey</A>(n)))
    <A HREF="lobject.h.html#setdeadvalue">setdeadvalue</A>(<A HREF="ltable.h.html#gkey">gkey</A>(n));  /* unused and unmarked key; remove it */
}


/*
** tells whether a key or value can be cleared from a weak
** table. Non-collectable objects are never removed from weak
** tables. Strings behave as `values', so are never removed too. for
** other objects: if really collected, cannot keep them; for objects
** being finalized, keep them in keys, but not in values
*/
static int <A NAME="iscleared"><SPAN CLASS="definition">iscleared</SPAN></A> (<A HREF="lstate.h.html#global_State">global_State</A> *g, const <A HREF="lobject.h.html#TValue">TValue</A> *o) {
  if (!<A HREF="lobject.h.html#iscollectable">iscollectable</A>(o)) return 0;
  else if (<A HREF="lobject.h.html#ttisstring">ttisstring</A>(o)) {
    <A HREF="lgc.c.html#markobject">markobject</A>(g, <A HREF="lobject.h.html#rawtsvalue">rawtsvalue</A>(o));  /* strings are `values', so are never weak */
    return 0;
  }
  else return <A HREF="lgc.h.html#iswhite">iswhite</A>(<A HREF="lobject.h.html#gcvalue">gcvalue</A>(o));
}


/*
** barrier that moves collector forward, that is, mark the white object
** being pointed by a black object.
*/
void <A NAME="luaC_barrier_"><SPAN CLASS="definition">luaC_barrier_</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L, <A HREF="lstate.h.html#GCObject">GCObject</A> *o, <A HREF="lstate.h.html#GCObject">GCObject</A> *v) {
  <A HREF="lstate.h.html#global_State">global_State</A> *g = <A HREF="lstate.h.html#G">G</A>(L);
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(<A HREF="lgc.h.html#isblack">isblack</A>(o) &amp;&amp; <A HREF="lgc.h.html#iswhite">iswhite</A>(v) &amp;&amp; !<A HREF="lgc.h.html#isdead">isdead</A>(g, v) &amp;&amp; !<A HREF="lgc.h.html#isdead">isdead</A>(g, o));
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(g-&gt;gcstate != <A HREF="lgc.h.html#GCSpause">GCSpause</A>);
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(<A HREF="lstate.h.html#gch">gch</A>(o)-&gt;tt != <A HREF="lua.h.html#LUA_TTABLE">LUA_TTABLE</A>);
  if (<A HREF="lgc.h.html#keepinvariantout">keepinvariantout</A>(g))  /* must keep invariant? */
    <A HREF="lgc.c.html#reallymarkobject">reallymarkobject</A>(g, v);  /* restore invariant */
  else {  /* sweep phase */
    <A HREF="llimits.h.html#lua_assert">lua_assert</A>(<A HREF="lgc.h.html#issweepphase">issweepphase</A>(g));
    <A HREF="lgc.c.html#makewhite">makewhite</A>(g, o);  /* mark <A HREF="lua.c.html#main">main</A> obj. as white to avoid other barriers */
  }
}


/*
** barrier that moves collector backward, that is, mark the black object
** pointing to a white object as gray again. (Current implementation
** only works for tables; access to 'gclist' is not uniform across
** different types.)
*/
void <A NAME="luaC_barrierback_"><SPAN CLASS="definition">luaC_barrierback_</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L, <A HREF="lstate.h.html#GCObject">GCObject</A> *o) {
  <A HREF="lstate.h.html#global_State">global_State</A> *g = <A HREF="lstate.h.html#G">G</A>(L);
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(<A HREF="lgc.h.html#isblack">isblack</A>(o) &amp;&amp; !<A HREF="lgc.h.html#isdead">isdead</A>(g, o) &amp;&amp; <A HREF="lstate.h.html#gch">gch</A>(o)-&gt;tt == <A HREF="lua.h.html#LUA_TTABLE">LUA_TTABLE</A>);
  <A HREF="lgc.c.html#black2gray">black2gray</A>(o);  /* make object gray (again) */
  <A HREF="lstate.h.html#gco2t">gco2t</A>(o)-&gt;gclist = g-&gt;grayagain;
  g-&gt;grayagain = o;
}


/*
** barrier for prototypes. When creating first closure (cache is
** NULL), use a forward barrier; this may be the only closure of the
** prototype (if it is a "regular" function, with a single instance)
** and the prototype may be big, so it is better to avoid traversing
** it again. Otherwise, use a backward barrier, to avoid marking all
** possible instances.
*/
<A HREF="luaconf.h.html#LUAI_FUNC">LUAI_FUNC</A> void <A NAME="luaC_barrierproto_"><SPAN CLASS="definition">luaC_barrierproto_</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L, <A HREF="lobject.h.html#Proto">Proto</A> *p, <A HREF="lobject.h.html#Closure">Closure</A> *c) {
  <A HREF="lstate.h.html#global_State">global_State</A> *g = <A HREF="lstate.h.html#G">G</A>(L);
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(<A HREF="lgc.h.html#isblack">isblack</A>(<A HREF="lstate.h.html#obj2gco">obj2gco</A>(p)));
  if (p-&gt;cache == NULL) {  /* first time? */
    <A HREF="lgc.h.html#luaC_objbarrier">luaC_objbarrier</A>(L, p, c);
  }
  else {  /* use a backward barrier */
    <A HREF="lgc.c.html#black2gray">black2gray</A>(<A HREF="lstate.h.html#obj2gco">obj2gco</A>(p));  /* make prototype gray (again) */
    p-&gt;gclist = g-&gt;grayagain;
    g-&gt;grayagain = <A HREF="lstate.h.html#obj2gco">obj2gco</A>(p);
  }
}


/*
** check color (and invariants) for an upvalue that was closed,
** i.e., moved into the 'allgc' list
*/
void <A NAME="luaC_checkupvalcolor"><SPAN CLASS="definition">luaC_checkupvalcolor</SPAN></A> (<A HREF="lstate.h.html#global_State">global_State</A> *g, <A HREF="lobject.h.html#UpVal">UpVal</A> *uv) {
  <A HREF="lstate.h.html#GCObject">GCObject</A> *o = <A HREF="lstate.h.html#obj2gco">obj2gco</A>(uv);
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(!<A HREF="lgc.h.html#isblack">isblack</A>(o));  /* open upvalues are never black */
  if (<A HREF="lgc.h.html#isgray">isgray</A>(o)) {
    if (<A HREF="lgc.h.html#keepinvariant">keepinvariant</A>(g)) {
      <A HREF="lgc.h.html#resetoldbit">resetoldbit</A>(o);  /* see MOVE OLD rule */
      <A HREF="lgc.h.html#gray2black">gray2black</A>(o);  /* it is being visited now */
      <A HREF="lgc.c.html#markvalue">markvalue</A>(g, uv-&gt;v);
    }
    else {
      <A HREF="llimits.h.html#lua_assert">lua_assert</A>(<A HREF="lgc.h.html#issweepphase">issweepphase</A>(g));
      <A HREF="lgc.c.html#makewhite">makewhite</A>(g, o);
    }
  }
}


/*
** create a new collectable object (with given type and size) and link
** it to '*list'. 'offset' tells how many bytes to allocate before the
** object itself (used only by states).
*/
<A HREF="lstate.h.html#GCObject">GCObject</A> *<A NAME="luaC_newobj"><SPAN CLASS="definition">luaC_newobj</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L, int tt, size_t sz, <A HREF="lstate.h.html#GCObject">GCObject</A> **list,
                       int offset) {
  <A HREF="lstate.h.html#global_State">global_State</A> *g = <A HREF="lstate.h.html#G">G</A>(L);
  char *raw = <A HREF="llimits.h.html#cast">cast</A>(char *, <A HREF="lmem.h.html#luaM_newobject">luaM_newobject</A>(L, <A HREF="lobject.h.html#novariant">novariant</A>(tt), sz));
  <A HREF="lstate.h.html#GCObject">GCObject</A> *o = <A HREF="lstate.h.html#obj2gco">obj2gco</A>(raw + offset);
  if (list == NULL)
    list = &amp;g-&gt;allgc;  /* standard list for collectable objects */
  <A HREF="lstate.h.html#gch">gch</A>(o)-&gt;marked = <A HREF="lgc.h.html#luaC_white">luaC_white</A>(g);
  <A HREF="lstate.h.html#gch">gch</A>(o)-&gt;tt = tt;
  <A HREF="lstate.h.html#gch">gch</A>(o)-&gt;next = *list;
  *list = o;
  return o;
}

/* }====================================================== */



/*
** {======================================================
** Mark functions
** =======================================================
*/


/*
** mark an object. Userdata, strings, and closed upvalues are visited
** and turned black here. Other objects are marked gray and added
** to appropriate list to be visited (and turned black) later. (Open
** upvalues are already linked in 'headuv' list.)
*/
static void <A NAME="reallymarkobject"><SPAN CLASS="definition">reallymarkobject</SPAN></A> (<A HREF="lstate.h.html#global_State">global_State</A> *g, <A HREF="lstate.h.html#GCObject">GCObject</A> *o) {
  <A HREF="llimits.h.html#lu_mem">lu_mem</A> size;
  <A HREF="lgc.c.html#white2gray">white2gray</A>(o);
  switch (<A HREF="lstate.h.html#gch">gch</A>(o)-&gt;tt) {
    case <A HREF="lobject.h.html#LUA_TSHRSTR">LUA_TSHRSTR</A>:
    case <A HREF="lobject.h.html#LUA_TLNGSTR">LUA_TLNGSTR</A>: {
      size = <A HREF="lstring.h.html#sizestring">sizestring</A>(<A HREF="lstate.h.html#gco2ts">gco2ts</A>(o));
      break;  /* nothing else to mark; make it black */
    }
    case <A HREF="lua.h.html#LUA_TUSERDATA">LUA_TUSERDATA</A>: {
      <A HREF="lobject.h.html#Table">Table</A> *mt = <A HREF="lstate.h.html#gco2u">gco2u</A>(o)-&gt;metatable;
      <A HREF="lgc.c.html#markobject">markobject</A>(g, mt);
      <A HREF="lgc.c.html#markobject">markobject</A>(g, <A HREF="lstate.h.html#gco2u">gco2u</A>(o)-&gt;env);
      size = <A HREF="lstring.h.html#sizeudata">sizeudata</A>(<A HREF="lstate.h.html#gco2u">gco2u</A>(o));
      break;
    }
    case <A HREF="lobject.h.html#LUA_TUPVAL">LUA_TUPVAL</A>: {
      <A HREF="lobject.h.html#UpVal">UpVal</A> *uv = <A HREF="lstate.h.html#gco2uv">gco2uv</A>(o);
      <A HREF="lgc.c.html#markvalue">markvalue</A>(g, uv-&gt;v);
      if (uv-&gt;v != &amp;uv-&gt;u.value)  /* open? */
        return;  /* open upvalues remain gray */
      size = sizeof(<A HREF="lobject.h.html#UpVal">UpVal</A>);
      break;
    }
    case <A HREF="lobject.h.html#LUA_TLCL">LUA_TLCL</A>: {
      <A HREF="lstate.h.html#gco2lcl">gco2lcl</A>(o)-&gt;gclist = g-&gt;gray;
      g-&gt;gray = o;
      return;
    }
    case <A HREF="lobject.h.html#LUA_TCCL">LUA_TCCL</A>: {
      <A HREF="lstate.h.html#gco2ccl">gco2ccl</A>(o)-&gt;gclist = g-&gt;gray;
      g-&gt;gray = o;
      return;
    }
    case <A HREF="lua.h.html#LUA_TTABLE">LUA_TTABLE</A>: {
      <A HREF="lgc.c.html#linktable">linktable</A>(<A HREF="lstate.h.html#gco2t">gco2t</A>(o), &amp;g-&gt;gray);
      return;
    }
    case <A HREF="lua.h.html#LUA_TTHREAD">LUA_TTHREAD</A>: {
      <A HREF="lstate.h.html#gco2th">gco2th</A>(o)-&gt;gclist = g-&gt;gray;
      g-&gt;gray = o;
      return;
    }
    case <A HREF="lobject.h.html#LUA_TPROTO">LUA_TPROTO</A>: {
      <A HREF="lstate.h.html#gco2p">gco2p</A>(o)-&gt;gclist = g-&gt;gray;
      g-&gt;gray = o;
      return;
    }
    default: <A HREF="llimits.h.html#lua_assert">lua_assert</A>(0); return;
  }
  <A HREF="lgc.h.html#gray2black">gray2black</A>(o);
  g-&gt;GCmemtrav += size;
}


/*
** mark metamethods for basic types
*/
static void <A NAME="markmt"><SPAN CLASS="definition">markmt</SPAN></A> (<A HREF="lstate.h.html#global_State">global_State</A> *g) {
  int i;
  for (i=0; i &lt; <A HREF="lua.h.html#LUA_NUMTAGS">LUA_NUMTAGS</A>; i++)
    <A HREF="lgc.c.html#markobject">markobject</A>(g, g-&gt;mt[i]);
}


/*
** mark all objects in list of being-finalized
*/
static void <A NAME="markbeingfnz"><SPAN CLASS="definition">markbeingfnz</SPAN></A> (<A HREF="lstate.h.html#global_State">global_State</A> *g) {
  <A HREF="lstate.h.html#GCObject">GCObject</A> *o;
  for (o = g-&gt;tobefnz; o != NULL; o = <A HREF="lstate.h.html#gch">gch</A>(o)-&gt;next) {
    <A HREF="lgc.c.html#makewhite">makewhite</A>(g, o);
    <A HREF="lgc.c.html#reallymarkobject">reallymarkobject</A>(g, o);
  }
}


/*
** mark all values stored in marked open upvalues. (See comment in
** 'lstate.h'.)
*/
static void <A NAME="remarkupvals"><SPAN CLASS="definition">remarkupvals</SPAN></A> (<A HREF="lstate.h.html#global_State">global_State</A> *g) {
  <A HREF="lobject.h.html#UpVal">UpVal</A> *uv;
  for (uv = g-&gt;uvhead.u.l.next; uv != &amp;g-&gt;uvhead; uv = uv-&gt;u.l.next) {
    if (<A HREF="lgc.h.html#isgray">isgray</A>(<A HREF="lstate.h.html#obj2gco">obj2gco</A>(uv)))
      <A HREF="lgc.c.html#markvalue">markvalue</A>(g, uv-&gt;v);
  }
}


/*
** mark root set and reset all gray lists, to start a new
** incremental (or full) collection
*/
static void <A NAME="restartcollection"><SPAN CLASS="definition">restartcollection</SPAN></A> (<A HREF="lstate.h.html#global_State">global_State</A> *g) {
  g-&gt;gray = g-&gt;grayagain = NULL;
  g-&gt;weak = g-&gt;allweak = g-&gt;ephemeron = NULL;
  <A HREF="lgc.c.html#markobject">markobject</A>(g, g-&gt;mainthread);
  <A HREF="lgc.c.html#markvalue">markvalue</A>(g, &amp;g-&gt;l_registry);
  <A HREF="lgc.c.html#markmt">markmt</A>(g);
  <A HREF="lgc.c.html#markbeingfnz">markbeingfnz</A>(g);  /* mark any finalizing object left from previous cycle */
}

/* }====================================================== */


/*
** {======================================================
** Traverse functions
** =======================================================
*/

static void <A NAME="traverseweakvalue"><SPAN CLASS="definition">traverseweakvalue</SPAN></A> (<A HREF="lstate.h.html#global_State">global_State</A> *g, <A HREF="lobject.h.html#Table">Table</A> *h) {
  <A HREF="lobject.h.html#Node">Node</A> *n, *limit = <A HREF="lgc.c.html#gnodelast">gnodelast</A>(h);
  /* if there is array part, assume it may have white values (do not
     traverse it just to check) */
  int hasclears = (h-&gt;sizearray &gt; 0);
  for (n = <A HREF="ltable.h.html#gnode">gnode</A>(h, 0); n &lt; limit; n++) {
    <A HREF="lgc.c.html#checkdeadkey">checkdeadkey</A>(n);
    if (<A HREF="lobject.h.html#ttisnil">ttisnil</A>(<A HREF="ltable.h.html#gval">gval</A>(n)))  /* entry is empty? */
      <A HREF="lgc.c.html#removeentry">removeentry</A>(n);  /* remove it */
    else {
      <A HREF="llimits.h.html#lua_assert">lua_assert</A>(!<A HREF="lobject.h.html#ttisnil">ttisnil</A>(<A HREF="ltable.h.html#gkey">gkey</A>(n)));
      <A HREF="lgc.c.html#markvalue">markvalue</A>(g, <A HREF="ltable.h.html#gkey">gkey</A>(n));  /* mark key */
      if (!hasclears &amp;&amp; <A HREF="lgc.c.html#iscleared">iscleared</A>(g, <A HREF="ltable.h.html#gval">gval</A>(n)))  /* is there a white value? */
        hasclears = 1;  /* table will have to be cleared */
    }
  }
  if (hasclears)
    <A HREF="lgc.c.html#linktable">linktable</A>(h, &amp;g-&gt;weak);  /* has to be cleared later */
  else  /* no white values */
    <A HREF="lgc.c.html#linktable">linktable</A>(h, &amp;g-&gt;grayagain);  /* no need to clean */
}


static int <A NAME="traverseephemeron"><SPAN CLASS="definition">traverseephemeron</SPAN></A> (<A HREF="lstate.h.html#global_State">global_State</A> *g, <A HREF="lobject.h.html#Table">Table</A> *h) {
  int marked = 0;  /* true if an object is marked in this traversal */
  int hasclears = 0;  /* true if table has white keys */
  int prop = 0;  /* true if table has entry "white-key -&gt; white-value" */
  <A HREF="lobject.h.html#Node">Node</A> *n, *limit = <A HREF="lgc.c.html#gnodelast">gnodelast</A>(h);
  int i;
  /* traverse array part (numeric keys are 'strong') */
  for (i = 0; i &lt; h-&gt;sizearray; i++) {
    if (<A HREF="lgc.h.html#valiswhite">valiswhite</A>(&amp;h-&gt;array[i])) {
      marked = 1;
      <A HREF="lgc.c.html#reallymarkobject">reallymarkobject</A>(g, <A HREF="lobject.h.html#gcvalue">gcvalue</A>(&amp;h-&gt;array[i]));
    }
  }
  /* traverse hash part */
  for (n = <A HREF="ltable.h.html#gnode">gnode</A>(h, 0); n &lt; limit; n++) {
    <A HREF="lgc.c.html#checkdeadkey">checkdeadkey</A>(n);
    if (<A HREF="lobject.h.html#ttisnil">ttisnil</A>(<A HREF="ltable.h.html#gval">gval</A>(n)))  /* entry is empty? */
      <A HREF="lgc.c.html#removeentry">removeentry</A>(n);  /* remove it */
    else if (<A HREF="lgc.c.html#iscleared">iscleared</A>(g, <A HREF="ltable.h.html#gkey">gkey</A>(n))) {  /* key is not marked (yet)? */
      hasclears = 1;  /* table must be cleared */
      if (<A HREF="lgc.h.html#valiswhite">valiswhite</A>(<A HREF="ltable.h.html#gval">gval</A>(n)))  /* value not marked yet? */
        prop = 1;  /* must propagate again */
    }
    else if (<A HREF="lgc.h.html#valiswhite">valiswhite</A>(<A HREF="ltable.h.html#gval">gval</A>(n))) {  /* value not marked yet? */
      marked = 1;
      <A HREF="lgc.c.html#reallymarkobject">reallymarkobject</A>(g, <A HREF="lobject.h.html#gcvalue">gcvalue</A>(<A HREF="ltable.h.html#gval">gval</A>(n)));  /* mark it now */
    }
  }
  if (g-&gt;gcstate != <A HREF="lgc.h.html#GCSatomic">GCSatomic</A> || prop)
    <A HREF="lgc.c.html#linktable">linktable</A>(h, &amp;g-&gt;ephemeron);  /* have to propagate again */
  else if (hasclears)  /* does table have white keys? */
    <A HREF="lgc.c.html#linktable">linktable</A>(h, &amp;g-&gt;allweak);  /* may have to clean white keys */
  else  /* no white keys */
    <A HREF="lgc.c.html#linktable">linktable</A>(h, &amp;g-&gt;grayagain);  /* no need to clean */
  return marked;
}


static void <A NAME="traversestrongtable"><SPAN CLASS="definition">traversestrongtable</SPAN></A> (<A HREF="lstate.h.html#global_State">global_State</A> *g, <A HREF="lobject.h.html#Table">Table</A> *h) {
  <A HREF="lobject.h.html#Node">Node</A> *n, *limit = <A HREF="lgc.c.html#gnodelast">gnodelast</A>(h);
  int i;
  for (i = 0; i &lt; h-&gt;sizearray; i++)  /* traverse array part */
    <A HREF="lgc.c.html#markvalue">markvalue</A>(g, &amp;h-&gt;array[i]);
  for (n = <A HREF="ltable.h.html#gnode">gnode</A>(h, 0); n &lt; limit; n++) {  /* traverse hash part */
    <A HREF="lgc.c.html#checkdeadkey">checkdeadkey</A>(n);
    if (<A HREF="lobject.h.html#ttisnil">ttisnil</A>(<A HREF="ltable.h.html#gval">gval</A>(n)))  /* entry is empty? */
      <A HREF="lgc.c.html#removeentry">removeentry</A>(n);  /* remove it */
    else {
      <A HREF="llimits.h.html#lua_assert">lua_assert</A>(!<A HREF="lobject.h.html#ttisnil">ttisnil</A>(<A HREF="ltable.h.html#gkey">gkey</A>(n)));
      <A HREF="lgc.c.html#markvalue">markvalue</A>(g, <A HREF="ltable.h.html#gkey">gkey</A>(n));  /* mark key */
      <A HREF="lgc.c.html#markvalue">markvalue</A>(g, <A HREF="ltable.h.html#gval">gval</A>(n));  /* mark value */
    }
  }
}


static <A HREF="llimits.h.html#lu_mem">lu_mem</A> <A NAME="traversetable"><SPAN CLASS="definition">traversetable</SPAN></A> (<A HREF="lstate.h.html#global_State">global_State</A> *g, <A HREF="lobject.h.html#Table">Table</A> *h) {
  const char *weakkey, *weakvalue;
  const <A HREF="lobject.h.html#TValue">TValue</A> *mode = <A HREF="ltm.h.html#gfasttm">gfasttm</A>(g, h-&gt;metatable, <A HREF="ltm.h.html#TM_MODE">TM_MODE</A>);
  <A HREF="lgc.c.html#markobject">markobject</A>(g, h-&gt;metatable);
  if (mode &amp;&amp; <A HREF="lobject.h.html#ttisstring">ttisstring</A>(mode) &amp;&amp;  /* is there a weak mode? */
      ((weakkey = strchr(<A HREF="lobject.h.html#svalue">svalue</A>(mode), 'k')),
       (weakvalue = strchr(<A HREF="lobject.h.html#svalue">svalue</A>(mode), 'v')),
       (weakkey || weakvalue))) {  /* is really weak? */
    <A HREF="lgc.c.html#black2gray">black2gray</A>(<A HREF="lstate.h.html#obj2gco">obj2gco</A>(h));  /* keep table gray */
    if (!weakkey)  /* strong keys? */
      <A HREF="lgc.c.html#traverseweakvalue">traverseweakvalue</A>(g, h);
    else if (!weakvalue)  /* strong values? */
      <A HREF="lgc.c.html#traverseephemeron">traverseephemeron</A>(g, h);
    else  /* all weak */
      <A HREF="lgc.c.html#linktable">linktable</A>(h, &amp;g-&gt;allweak);  /* nothing to traverse now */
  }
  else  /* not weak */
    <A HREF="lgc.c.html#traversestrongtable">traversestrongtable</A>(g, h);
  return sizeof(<A HREF="lobject.h.html#Table">Table</A>) + sizeof(<A HREF="lobject.h.html#TValue">TValue</A>) * h-&gt;sizearray +
                         sizeof(<A HREF="lobject.h.html#Node">Node</A>) * <A HREF="llimits.h.html#cast">cast</A>(size_t, <A HREF="lobject.h.html#sizenode">sizenode</A>(h));
}


static int <A NAME="traverseproto"><SPAN CLASS="definition">traverseproto</SPAN></A> (<A HREF="lstate.h.html#global_State">global_State</A> *g, <A HREF="lobject.h.html#Proto">Proto</A> *f) {
  int i;
  if (f-&gt;cache &amp;&amp; <A HREF="lgc.h.html#iswhite">iswhite</A>(<A HREF="lstate.h.html#obj2gco">obj2gco</A>(f-&gt;cache)))
    f-&gt;cache = NULL;  /* allow cache to be collected */
  <A HREF="lgc.c.html#markobject">markobject</A>(g, f-&gt;source);
  for (i = 0; i &lt; f-&gt;sizek; i++)  /* mark literals */
    <A HREF="lgc.c.html#markvalue">markvalue</A>(g, &amp;f-&gt;k[i]);
  for (i = 0; i &lt; f-&gt;sizeupvalues; i++)  /* mark upvalue names */
    <A HREF="lgc.c.html#markobject">markobject</A>(g, f-&gt;upvalues[i].name);
  for (i = 0; i &lt; f-&gt;sizep; i++)  /* mark nested protos */
    <A HREF="lgc.c.html#markobject">markobject</A>(g, f-&gt;p[i]);
  for (i = 0; i &lt; f-&gt;sizelocvars; i++)  /* mark local-variable names */
    <A HREF="lgc.c.html#markobject">markobject</A>(g, f-&gt;locvars[i].varname);
  return sizeof(<A HREF="lobject.h.html#Proto">Proto</A>) + sizeof(<A HREF="llimits.h.html#Instruction">Instruction</A>) * f-&gt;sizecode +
                         sizeof(<A HREF="lobject.h.html#Proto">Proto</A> *) * f-&gt;sizep +
                         sizeof(<A HREF="lobject.h.html#TValue">TValue</A>) * f-&gt;sizek +
                         sizeof(int) * f-&gt;sizelineinfo +
                         sizeof(<A HREF="lobject.h.html#LocVar">LocVar</A>) * f-&gt;sizelocvars +
                         sizeof(<A HREF="lobject.h.html#Upvaldesc">Upvaldesc</A>) * f-&gt;sizeupvalues;
}


static <A HREF="llimits.h.html#lu_mem">lu_mem</A> <A NAME="traverseCclosure"><SPAN CLASS="definition">traverseCclosure</SPAN></A> (<A HREF="lstate.h.html#global_State">global_State</A> *g, <A HREF="lobject.h.html#CClosure">CClosure</A> *cl) {
  int i;
  for (i = 0; i &lt; cl-&gt;nupvalues; i++)  /* mark its upvalues */
    <A HREF="lgc.c.html#markvalue">markvalue</A>(g, &amp;cl-&gt;upvalue[i]);
  return <A HREF="lfunc.h.html#sizeCclosure">sizeCclosure</A>(cl-&gt;nupvalues);
}

static <A HREF="llimits.h.html#lu_mem">lu_mem</A> <A NAME="traverseLclosure"><SPAN CLASS="definition">traverseLclosure</SPAN></A> (<A HREF="lstate.h.html#global_State">global_State</A> *g, <A HREF="lobject.h.html#LClosure">LClosure</A> *cl) {
  int i;
  <A HREF="lgc.c.html#markobject">markobject</A>(g, cl-&gt;p);  /* mark its prototype */
  for (i = 0; i &lt; cl-&gt;nupvalues; i++)  /* mark its upvalues */
    <A HREF="lgc.c.html#markobject">markobject</A>(g, cl-&gt;upvals[i]);
  return <A HREF="lfunc.h.html#sizeLclosure">sizeLclosure</A>(cl-&gt;nupvalues);
}


static <A HREF="llimits.h.html#lu_mem">lu_mem</A> <A NAME="traversestack"><SPAN CLASS="definition">traversestack</SPAN></A> (<A HREF="lstate.h.html#global_State">global_State</A> *g, <A HREF="lstate.h.html#lua_State">lua_State</A> *th) {
  int n = 0;
  <A HREF="lobject.h.html#StkId">StkId</A> o = th-&gt;stack;
  if (o == NULL)
    return 1;  /* stack not completely built yet */
  for (; o &lt; th-&gt;top; o++)  /* mark live elements in the stack */
    <A HREF="lgc.c.html#markvalue">markvalue</A>(g, o);
  if (g-&gt;gcstate == <A HREF="lgc.h.html#GCSatomic">GCSatomic</A>) {  /* final traversal? */
    <A HREF="lobject.h.html#StkId">StkId</A> lim = th-&gt;stack + th-&gt;stacksize;  /* real end of stack */
    for (; o &lt; lim; o++)  /* clear not-marked stack slice */
      <A HREF="lobject.h.html#setnilvalue">setnilvalue</A>(o);
  }
  else {  /* count call infos to compute size */
    <A HREF="lstate.h.html#CallInfo">CallInfo</A> *ci;
    for (ci = &amp;th-&gt;base_ci; ci != th-&gt;ci; ci = ci-&gt;next)
      n++;
  }
  return sizeof(<A HREF="lstate.h.html#lua_State">lua_State</A>) + sizeof(<A HREF="lobject.h.html#TValue">TValue</A>) * th-&gt;stacksize +
         sizeof(<A HREF="lstate.h.html#CallInfo">CallInfo</A>) * n;
}


/*
** traverse one gray object, turning it to black (except for threads,
** which are always gray).
*/
static void <A NAME="propagatemark"><SPAN CLASS="definition">propagatemark</SPAN></A> (<A HREF="lstate.h.html#global_State">global_State</A> *g) {
  <A HREF="llimits.h.html#lu_mem">lu_mem</A> size;
  <A HREF="lstate.h.html#GCObject">GCObject</A> *o = g-&gt;gray;
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(<A HREF="lgc.h.html#isgray">isgray</A>(o));
  <A HREF="lgc.h.html#gray2black">gray2black</A>(o);
  switch (<A HREF="lstate.h.html#gch">gch</A>(o)-&gt;tt) {
    case <A HREF="lua.h.html#LUA_TTABLE">LUA_TTABLE</A>: {
      <A HREF="lobject.h.html#Table">Table</A> *h = <A HREF="lstate.h.html#gco2t">gco2t</A>(o);
      g-&gt;gray = h-&gt;gclist;  /* remove from 'gray' list */
      size = <A HREF="lgc.c.html#traversetable">traversetable</A>(g, h);
      break;
    }
    case <A HREF="lobject.h.html#LUA_TLCL">LUA_TLCL</A>: {
      <A HREF="lobject.h.html#LClosure">LClosure</A> *cl = <A HREF="lstate.h.html#gco2lcl">gco2lcl</A>(o);
      g-&gt;gray = cl-&gt;gclist;  /* remove from 'gray' list */
      size = <A HREF="lgc.c.html#traverseLclosure">traverseLclosure</A>(g, cl);
      break;
    }
    case <A HREF="lobject.h.html#LUA_TCCL">LUA_TCCL</A>: {
      <A HREF="lobject.h.html#CClosure">CClosure</A> *cl = <A HREF="lstate.h.html#gco2ccl">gco2ccl</A>(o);
      g-&gt;gray = cl-&gt;gclist;  /* remove from 'gray' list */
      size = <A HREF="lgc.c.html#traverseCclosure">traverseCclosure</A>(g, cl);
      break;
    }
    case <A HREF="lua.h.html#LUA_TTHREAD">LUA_TTHREAD</A>: {
      <A HREF="lstate.h.html#lua_State">lua_State</A> *th = <A HREF="lstate.h.html#gco2th">gco2th</A>(o);
      g-&gt;gray = th-&gt;gclist;  /* remove from 'gray' list */
      th-&gt;gclist = g-&gt;grayagain;
      g-&gt;grayagain = o;  /* insert into 'grayagain' list */
      <A HREF="lgc.c.html#black2gray">black2gray</A>(o);
      size = <A HREF="lgc.c.html#traversestack">traversestack</A>(g, th);
      break;
    }
    case <A HREF="lobject.h.html#LUA_TPROTO">LUA_TPROTO</A>: {
      <A HREF="lobject.h.html#Proto">Proto</A> *p = <A HREF="lstate.h.html#gco2p">gco2p</A>(o);
      g-&gt;gray = p-&gt;gclist;  /* remove from 'gray' list */
      size = <A HREF="lgc.c.html#traverseproto">traverseproto</A>(g, p);
      break;
    }
    default: <A HREF="llimits.h.html#lua_assert">lua_assert</A>(0); return;
  }
  g-&gt;GCmemtrav += size;
}


static void <A NAME="propagateall"><SPAN CLASS="definition">propagateall</SPAN></A> (<A HREF="lstate.h.html#global_State">global_State</A> *g) {
  while (g-&gt;gray) <A HREF="lgc.c.html#propagatemark">propagatemark</A>(g);
}


static void <A NAME="propagatelist"><SPAN CLASS="definition">propagatelist</SPAN></A> (<A HREF="lstate.h.html#global_State">global_State</A> *g, <A HREF="lstate.h.html#GCObject">GCObject</A> *l) {
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(g-&gt;gray == NULL);  /* no grays left */
  g-&gt;gray = l;
  <A HREF="lgc.c.html#propagateall">propagateall</A>(g);  /* traverse all elements from 'l' */
}

/*
** retraverse all gray lists. Because tables may be reinserted in other
** lists when traversed, traverse the original lists to avoid traversing
** twice the same table (which is not wrong, but inefficient)
*/
static void <A NAME="retraversegrays"><SPAN CLASS="definition">retraversegrays</SPAN></A> (<A HREF="lstate.h.html#global_State">global_State</A> *g) {
  <A HREF="lstate.h.html#GCObject">GCObject</A> *weak = g-&gt;weak;  /* save original lists */
  <A HREF="lstate.h.html#GCObject">GCObject</A> *grayagain = g-&gt;grayagain;
  <A HREF="lstate.h.html#GCObject">GCObject</A> *ephemeron = g-&gt;ephemeron;
  g-&gt;weak = g-&gt;grayagain = g-&gt;ephemeron = NULL;
  <A HREF="lgc.c.html#propagateall">propagateall</A>(g);  /* traverse <A HREF="lua.c.html#main">main</A> gray list */
  <A HREF="lgc.c.html#propagatelist">propagatelist</A>(g, grayagain);
  <A HREF="lgc.c.html#propagatelist">propagatelist</A>(g, weak);
  <A HREF="lgc.c.html#propagatelist">propagatelist</A>(g, ephemeron);
}


static void <A NAME="convergeephemerons"><SPAN CLASS="definition">convergeephemerons</SPAN></A> (<A HREF="lstate.h.html#global_State">global_State</A> *g) {
  int changed;
  do {
    <A HREF="lstate.h.html#GCObject">GCObject</A> *w;
    <A HREF="lstate.h.html#GCObject">GCObject</A> *next = g-&gt;ephemeron;  /* get ephemeron list */
    g-&gt;ephemeron = NULL;  /* tables will return to this list when traversed */
    changed = 0;
    while ((w = next) != NULL) {
      next = <A HREF="lstate.h.html#gco2t">gco2t</A>(w)-&gt;gclist;
      if (<A HREF="lgc.c.html#traverseephemeron">traverseephemeron</A>(g, <A HREF="lstate.h.html#gco2t">gco2t</A>(w))) {  /* traverse marked some value? */
        <A HREF="lgc.c.html#propagateall">propagateall</A>(g);  /* propagate changes */
        changed = 1;  /* will have to revisit all ephemeron tables */
      }
    }
  } while (changed);
}

/* }====================================================== */


/*
** {======================================================
** Sweep Functions
** =======================================================
*/


/*
** clear entries with unmarked keys from all weaktables in list 'l' up
** to element 'f'
*/
static void <A NAME="clearkeys"><SPAN CLASS="definition">clearkeys</SPAN></A> (<A HREF="lstate.h.html#global_State">global_State</A> *g, <A HREF="lstate.h.html#GCObject">GCObject</A> *l, <A HREF="lstate.h.html#GCObject">GCObject</A> *f) {
  for (; l != f; l = <A HREF="lstate.h.html#gco2t">gco2t</A>(l)-&gt;gclist) {
    <A HREF="lobject.h.html#Table">Table</A> *h = <A HREF="lstate.h.html#gco2t">gco2t</A>(l);
    <A HREF="lobject.h.html#Node">Node</A> *n, *limit = <A HREF="lgc.c.html#gnodelast">gnodelast</A>(h);
    for (n = <A HREF="ltable.h.html#gnode">gnode</A>(h, 0); n &lt; limit; n++) {
      if (!<A HREF="lobject.h.html#ttisnil">ttisnil</A>(<A HREF="ltable.h.html#gval">gval</A>(n)) &amp;&amp; (<A HREF="lgc.c.html#iscleared">iscleared</A>(g, <A HREF="ltable.h.html#gkey">gkey</A>(n)))) {
        <A HREF="lobject.h.html#setnilvalue">setnilvalue</A>(<A HREF="ltable.h.html#gval">gval</A>(n));  /* remove value ... */
        <A HREF="lgc.c.html#removeentry">removeentry</A>(n);  /* and remove entry from table */
      }
    }
  }
}


/*
** clear entries with unmarked values from all weaktables in list 'l' up
** to element 'f'
*/
static void <A NAME="clearvalues"><SPAN CLASS="definition">clearvalues</SPAN></A> (<A HREF="lstate.h.html#global_State">global_State</A> *g, <A HREF="lstate.h.html#GCObject">GCObject</A> *l, <A HREF="lstate.h.html#GCObject">GCObject</A> *f) {
  for (; l != f; l = <A HREF="lstate.h.html#gco2t">gco2t</A>(l)-&gt;gclist) {
    <A HREF="lobject.h.html#Table">Table</A> *h = <A HREF="lstate.h.html#gco2t">gco2t</A>(l);
    <A HREF="lobject.h.html#Node">Node</A> *n, *limit = <A HREF="lgc.c.html#gnodelast">gnodelast</A>(h);
    int i;
    for (i = 0; i &lt; h-&gt;sizearray; i++) {
      <A HREF="lobject.h.html#TValue">TValue</A> *o = &amp;h-&gt;array[i];
      if (<A HREF="lgc.c.html#iscleared">iscleared</A>(g, o))  /* value was collected? */
        <A HREF="lobject.h.html#setnilvalue">setnilvalue</A>(o);  /* remove value */
    }
    for (n = <A HREF="ltable.h.html#gnode">gnode</A>(h, 0); n &lt; limit; n++) {
      if (!<A HREF="lobject.h.html#ttisnil">ttisnil</A>(<A HREF="ltable.h.html#gval">gval</A>(n)) &amp;&amp; <A HREF="lgc.c.html#iscleared">iscleared</A>(g, <A HREF="ltable.h.html#gval">gval</A>(n))) {
        <A HREF="lobject.h.html#setnilvalue">setnilvalue</A>(<A HREF="ltable.h.html#gval">gval</A>(n));  /* remove value ... */
        <A HREF="lgc.c.html#removeentry">removeentry</A>(n);  /* and remove entry from table */
      }
    }
  }
}


static void <A NAME="freeobj"><SPAN CLASS="definition">freeobj</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L, <A HREF="lstate.h.html#GCObject">GCObject</A> *o) {
  switch (<A HREF="lstate.h.html#gch">gch</A>(o)-&gt;tt) {
    case <A HREF="lobject.h.html#LUA_TPROTO">LUA_TPROTO</A>: <A HREF="lfunc.c.html#luaF_freeproto">luaF_freeproto</A>(L, <A HREF="lstate.h.html#gco2p">gco2p</A>(o)); break;
    case <A HREF="lobject.h.html#LUA_TLCL">LUA_TLCL</A>: {
      <A HREF="lmem.h.html#luaM_freemem">luaM_freemem</A>(L, o, <A HREF="lfunc.h.html#sizeLclosure">sizeLclosure</A>(<A HREF="lstate.h.html#gco2lcl">gco2lcl</A>(o)-&gt;nupvalues));
      break;
    }
    case <A HREF="lobject.h.html#LUA_TCCL">LUA_TCCL</A>: {
      <A HREF="lmem.h.html#luaM_freemem">luaM_freemem</A>(L, o, <A HREF="lfunc.h.html#sizeCclosure">sizeCclosure</A>(<A HREF="lstate.h.html#gco2ccl">gco2ccl</A>(o)-&gt;nupvalues));
      break;
    }
    case <A HREF="lobject.h.html#LUA_TUPVAL">LUA_TUPVAL</A>: <A HREF="lfunc.c.html#luaF_freeupval">luaF_freeupval</A>(L, <A HREF="lstate.h.html#gco2uv">gco2uv</A>(o)); break;
    case <A HREF="lua.h.html#LUA_TTABLE">LUA_TTABLE</A>: <A HREF="ltable.c.html#luaH_free">luaH_free</A>(L, <A HREF="lstate.h.html#gco2t">gco2t</A>(o)); break;
    case <A HREF="lua.h.html#LUA_TTHREAD">LUA_TTHREAD</A>: <A HREF="lstate.c.html#luaE_freethread">luaE_freethread</A>(L, <A HREF="lstate.h.html#gco2th">gco2th</A>(o)); break;
    case <A HREF="lua.h.html#LUA_TUSERDATA">LUA_TUSERDATA</A>: <A HREF="lmem.h.html#luaM_freemem">luaM_freemem</A>(L, o, <A HREF="lstring.h.html#sizeudata">sizeudata</A>(<A HREF="lstate.h.html#gco2u">gco2u</A>(o))); break;
    case <A HREF="lobject.h.html#LUA_TSHRSTR">LUA_TSHRSTR</A>:
      <A HREF="lstate.h.html#G">G</A>(L)-&gt;strt.nuse--;
      /* go through */
    case <A HREF="lobject.h.html#LUA_TLNGSTR">LUA_TLNGSTR</A>: {
      <A HREF="lmem.h.html#luaM_freemem">luaM_freemem</A>(L, o, <A HREF="lstring.h.html#sizestring">sizestring</A>(<A HREF="lstate.h.html#gco2ts">gco2ts</A>(o)));
      break;
    }
    default: <A HREF="llimits.h.html#lua_assert">lua_assert</A>(0);
  }
}


#define <A NAME="sweepwholelist"><SPAN CLASS="definition">sweepwholelist</SPAN></A>(L,p)     <A HREF="lgc.c.html#sweeplist">sweeplist</A>(L,p,<A HREF="llimits.h.html#MAX_LUMEM">MAX_LUMEM</A>)
static <A HREF="lstate.h.html#GCObject">GCObject</A> **<A HREF="lgc.c.html#sweeplist">sweeplist</A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L, <A HREF="lstate.h.html#GCObject">GCObject</A> **p, <A HREF="llimits.h.html#lu_mem">lu_mem</A> count);


/*
** sweep the (open) upvalues of a thread and resize its stack and
** list of call-info structures.
*/
static void <A NAME="sweepthread"><SPAN CLASS="definition">sweepthread</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L, <A HREF="lstate.h.html#lua_State">lua_State</A> *L1) {
  if (L1-&gt;stack == NULL) return;  /* stack not completely built yet */
  <A HREF="lgc.c.html#sweepwholelist">sweepwholelist</A>(L, &amp;L1-&gt;openupval);  /* sweep open upvalues */
  <A HREF="lstate.c.html#luaE_freeCI">luaE_freeCI</A>(L1);  /* free extra <A HREF="lstate.h.html#CallInfo">CallInfo</A> slots */
  /* should not change the stack during an emergency gc cycle */
  if (<A HREF="lstate.h.html#G">G</A>(L)-&gt;gckind != <A HREF="lstate.h.html#KGC_EMERGENCY">KGC_EMERGENCY</A>)
    <A HREF="ldo.c.html#luaD_shrinkstack">luaD_shrinkstack</A>(L1);
}


/*
** sweep at most 'count' elements from a list of GCObjects erasing dead
** objects, where a dead (not alive) object is one marked with the "old"
** (non current) white and not fixed.
** In non-generational mode, change all non-dead objects back to white,
** preparing for next collection cycle.
** In generational mode, keep black objects black, and also mark them as
** old; stop when hitting an old object, as all objects after that
** one will be old too.
** When object is a thread, sweep its list of open upvalues too.
*/
static <A HREF="lstate.h.html#GCObject">GCObject</A> **<A NAME="sweeplist"><SPAN CLASS="definition">sweeplist</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L, <A HREF="lstate.h.html#GCObject">GCObject</A> **p, <A HREF="llimits.h.html#lu_mem">lu_mem</A> count) {
  <A HREF="lstate.h.html#global_State">global_State</A> *g = <A HREF="lstate.h.html#G">G</A>(L);
  int ow = <A HREF="lgc.h.html#otherwhite">otherwhite</A>(g);
  int toclear, toset;  /* bits to clear and to set in all live objects */
  int tostop;  /* stop sweep when this is true */
  if (<A HREF="lgc.h.html#isgenerational">isgenerational</A>(g)) {  /* generational mode? */
    toclear = ~0;  /* clear nothing */
    toset = <A HREF="lgc.h.html#bitmask">bitmask</A>(<A HREF="lgc.h.html#OLDBIT">OLDBIT</A>);  /* set the old bit of all surviving objects */
    tostop = <A HREF="lgc.h.html#bitmask">bitmask</A>(<A HREF="lgc.h.html#OLDBIT">OLDBIT</A>);  /* do not sweep old generation */
  }
  else {  /* normal mode */
    toclear = <A HREF="lgc.c.html#maskcolors">maskcolors</A>;  /* clear all color bits + old bit */
    toset = <A HREF="lgc.h.html#luaC_white">luaC_white</A>(g);  /* make object white */
    tostop = 0;  /* do not stop */
  }
  while (*p != NULL &amp;&amp; count-- &gt; 0) {
    <A HREF="lstate.h.html#GCObject">GCObject</A> *curr = *p;
    int marked = <A HREF="lstate.h.html#gch">gch</A>(curr)-&gt;marked;
    if (<A HREF="lgc.h.html#isdeadm">isdeadm</A>(ow, marked)) {  /* is 'curr' dead? */
      *p = <A HREF="lstate.h.html#gch">gch</A>(curr)-&gt;next;  /* remove 'curr' from list */
      <A HREF="lgc.c.html#freeobj">freeobj</A>(L, curr);  /* erase 'curr' */
    }
    else {
      if (<A HREF="lgc.h.html#testbits">testbits</A>(marked, tostop))
        return NULL;  /* stop sweeping this list */
      if (<A HREF="lstate.h.html#gch">gch</A>(curr)-&gt;tt == <A HREF="lua.h.html#LUA_TTHREAD">LUA_TTHREAD</A>)
        <A HREF="lgc.c.html#sweepthread">sweepthread</A>(L, <A HREF="lstate.h.html#gco2th">gco2th</A>(curr));  /* sweep thread's upvalues */
      /* update marks */
      <A HREF="lstate.h.html#gch">gch</A>(curr)-&gt;marked = <A HREF="llimits.h.html#cast_byte">cast_byte</A>((marked &amp; toclear) | toset);
      p = &amp;<A HREF="lstate.h.html#gch">gch</A>(curr)-&gt;next;  /* go to next element */
    }
  }
  return (*p == NULL) ? NULL : p;
}


/*
** sweep a list until a live object (or end of list)
*/
static <A HREF="lstate.h.html#GCObject">GCObject</A> **<A NAME="sweeptolive"><SPAN CLASS="definition">sweeptolive</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L, <A HREF="lstate.h.html#GCObject">GCObject</A> **p, int *n) {
  <A HREF="lstate.h.html#GCObject">GCObject</A> ** old = p;
  int i = 0;
  do {
    i++;
    p = <A HREF="lgc.c.html#sweeplist">sweeplist</A>(L, p, 1);
  } while (p == old);
  if (n) *n += i;
  return p;
}

/* }====================================================== */


/*
** {======================================================
** Finalization
** =======================================================
*/

static void <A NAME="checkSizes"><SPAN CLASS="definition">checkSizes</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  <A HREF="lstate.h.html#global_State">global_State</A> *g = <A HREF="lstate.h.html#G">G</A>(L);
  if (g-&gt;gckind != <A HREF="lstate.h.html#KGC_EMERGENCY">KGC_EMERGENCY</A>) {  /* do not change sizes in emergency */
    int hs = g-&gt;strt.size / 2;  /* half the size of the string table */
    if (g-&gt;strt.nuse &lt; <A HREF="llimits.h.html#cast">cast</A>(<A HREF="llimits.h.html#lu_int32">lu_int32</A>, hs))  /* using less than that half? */
      <A HREF="lstring.c.html#luaS_resize">luaS_resize</A>(L, hs);  /* halve its size */
    <A HREF="lzio.h.html#luaZ_freebuffer">luaZ_freebuffer</A>(L, &amp;g-&gt;buff);  /* free concatenation buffer */
  }
}


static <A HREF="lstate.h.html#GCObject">GCObject</A> *<A NAME="udata2finalize"><SPAN CLASS="definition">udata2finalize</SPAN></A> (<A HREF="lstate.h.html#global_State">global_State</A> *g) {
  <A HREF="lstate.h.html#GCObject">GCObject</A> *o = g-&gt;tobefnz;  /* get first element */
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(<A HREF="lgc.c.html#isfinalized">isfinalized</A>(o));
  g-&gt;tobefnz = <A HREF="lstate.h.html#gch">gch</A>(o)-&gt;next;  /* remove it from 'tobefnz' list */
  <A HREF="lstate.h.html#gch">gch</A>(o)-&gt;next = g-&gt;allgc;  /* return it to 'allgc' list */
  g-&gt;allgc = o;
  <A HREF="lgc.h.html#resetbit">resetbit</A>(<A HREF="lstate.h.html#gch">gch</A>(o)-&gt;marked, <A HREF="lgc.h.html#SEPARATED">SEPARATED</A>);  /* mark that it is not in 'tobefnz' */
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(!<A HREF="lgc.h.html#isold">isold</A>(o));  /* see MOVE OLD rule */
  if (!<A HREF="lgc.h.html#keepinvariantout">keepinvariantout</A>(g))  /* not keeping invariant? */
    <A HREF="lgc.c.html#makewhite">makewhite</A>(g, o);  /* "sweep" object */
  return o;
}


static void <A NAME="dothecall"><SPAN CLASS="definition">dothecall</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L, void *ud) {
  <A HREF="llimits.h.html#UNUSED">UNUSED</A>(ud);
  <A HREF="ldo.c.html#luaD_call">luaD_call</A>(L, L-&gt;top - 2, 0, 0);
}


static void <A NAME="GCTM"><SPAN CLASS="definition">GCTM</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L, int propagateerrors) {
  <A HREF="lstate.h.html#global_State">global_State</A> *g = <A HREF="lstate.h.html#G">G</A>(L);
  const <A HREF="lobject.h.html#TValue">TValue</A> *tm;
  <A HREF="lobject.h.html#TValue">TValue</A> v;
  <A HREF="lobject.h.html#setgcovalue">setgcovalue</A>(L, &amp;v, <A HREF="lgc.c.html#udata2finalize">udata2finalize</A>(g));
  tm = <A HREF="ltm.c.html#luaT_gettmbyobj">luaT_gettmbyobj</A>(L, &amp;v, <A HREF="ltm.h.html#TM_GC">TM_GC</A>);
  if (tm != NULL &amp;&amp; <A HREF="lobject.h.html#ttisfunction">ttisfunction</A>(tm)) {  /* is there a finalizer? */
    int status;
    <A HREF="llimits.h.html#lu_byte">lu_byte</A> oldah = L-&gt;allowhook;
    int running  = g-&gt;gcrunning;
    L-&gt;allowhook = 0;  /* stop debug hooks during GC metamethod */
    g-&gt;gcrunning = 0;  /* avoid GC steps */
    <A HREF="lobject.h.html#setobj2s">setobj2s</A>(L, L-&gt;top, tm);  /* push finalizer... */
    <A HREF="lobject.h.html#setobj2s">setobj2s</A>(L, L-&gt;top + 1, &amp;v);  /* ... and its argument */
    L-&gt;top += 2;  /* and (next line) call the finalizer */
    status = <A HREF="ldo.c.html#luaD_pcall">luaD_pcall</A>(L, <A HREF="lgc.c.html#dothecall">dothecall</A>, NULL, <A HREF="ldo.h.html#savestack">savestack</A>(L, L-&gt;top - 2), 0);
    L-&gt;allowhook = oldah;  /* restore hooks */
    g-&gt;gcrunning = running;  /* restore state */
    if (status != <A HREF="lua.h.html#LUA_OK">LUA_OK</A> &amp;&amp; propagateerrors) {  /* error while running __gc? */
      if (status == <A HREF="lua.h.html#LUA_ERRRUN">LUA_ERRRUN</A>) {  /* is there an error object? */
        const char *msg = (<A HREF="lobject.h.html#ttisstring">ttisstring</A>(L-&gt;top - 1))
                            ? <A HREF="lobject.h.html#svalue">svalue</A>(L-&gt;top - 1)
                            : "no message";
        <A HREF="lobject.c.html#luaO_pushfstring">luaO_pushfstring</A>(L, "error in __gc metamethod (%s)", msg);
        status = <A HREF="lua.h.html#LUA_ERRGCMM">LUA_ERRGCMM</A>;  /* error in __gc metamethod */
      }
      <A HREF="ldo.c.html#luaD_throw">luaD_throw</A>(L, status);  /* re-throw error */
    }
  }
}


/*
** move all unreachable objects (or 'all' objects) that need
** finalization from list 'finobj' to list 'tobefnz' (to be finalized)
*/
static void <A NAME="separatetobefnz"><SPAN CLASS="definition">separatetobefnz</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L, int all) {
  <A HREF="lstate.h.html#global_State">global_State</A> *g = <A HREF="lstate.h.html#G">G</A>(L);
  <A HREF="lstate.h.html#GCObject">GCObject</A> **p = &amp;g-&gt;finobj;
  <A HREF="lstate.h.html#GCObject">GCObject</A> *curr;
  <A HREF="lstate.h.html#GCObject">GCObject</A> **lastnext = &amp;g-&gt;tobefnz;
  /* find last 'next' field in 'tobefnz' list (to add elements in its end) */
  while (*lastnext != NULL)
    lastnext = &amp;<A HREF="lstate.h.html#gch">gch</A>(*lastnext)-&gt;next;
  while ((curr = *p) != NULL) {  /* traverse all finalizable objects */
    <A HREF="llimits.h.html#lua_assert">lua_assert</A>(!<A HREF="lgc.c.html#isfinalized">isfinalized</A>(curr));
    <A HREF="llimits.h.html#lua_assert">lua_assert</A>(<A HREF="lgc.h.html#testbit">testbit</A>(<A HREF="lstate.h.html#gch">gch</A>(curr)-&gt;marked, <A HREF="lgc.h.html#SEPARATED">SEPARATED</A>));
    if (!(<A HREF="lgc.h.html#iswhite">iswhite</A>(curr) || all))  /* not being collected? */
      p = &amp;<A HREF="lstate.h.html#gch">gch</A>(curr)-&gt;next;  /* don't bother with it */
    else {
      <A HREF="lgc.h.html#l_setbit">l_setbit</A>(<A HREF="lstate.h.html#gch">gch</A>(curr)-&gt;marked, <A HREF="lgc.h.html#FINALIZEDBIT">FINALIZEDBIT</A>); /* won't be finalized again */
      *p = <A HREF="lstate.h.html#gch">gch</A>(curr)-&gt;next;  /* remove 'curr' from 'finobj' list */
      <A HREF="lstate.h.html#gch">gch</A>(curr)-&gt;next = *lastnext;  /* link at the end of 'tobefnz' list */
      *lastnext = curr;
      lastnext = &amp;<A HREF="lstate.h.html#gch">gch</A>(curr)-&gt;next;
    }
  }
}


/*
** if object 'o' has a finalizer, remove it from 'allgc' list (must
** search the list to find it) and link it in 'finobj' list.
*/
void <A NAME="luaC_checkfinalizer"><SPAN CLASS="definition">luaC_checkfinalizer</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L, <A HREF="lstate.h.html#GCObject">GCObject</A> *o, <A HREF="lobject.h.html#Table">Table</A> *mt) {
  <A HREF="lstate.h.html#global_State">global_State</A> *g = <A HREF="lstate.h.html#G">G</A>(L);
  if (<A HREF="lgc.h.html#testbit">testbit</A>(<A HREF="lstate.h.html#gch">gch</A>(o)-&gt;marked, <A HREF="lgc.h.html#SEPARATED">SEPARATED</A>) || /* obj. is already separated... */
      <A HREF="lgc.c.html#isfinalized">isfinalized</A>(o) ||                           /* ... or is finalized... */
      <A HREF="ltm.h.html#gfasttm">gfasttm</A>(g, mt, <A HREF="ltm.h.html#TM_GC">TM_GC</A>) == NULL)                /* or has no finalizer? */
    return;  /* nothing to be done */
  else {  /* move 'o' to 'finobj' list */
    <A HREF="lstate.h.html#GCObject">GCObject</A> **p;
    <A HREF="lobject.h.html#GCheader">GCheader</A> *ho = <A HREF="lstate.h.html#gch">gch</A>(o);
    if (g-&gt;sweepgc == &amp;ho-&gt;next) {  /* avoid removing current sweep object */
      <A HREF="llimits.h.html#lua_assert">lua_assert</A>(<A HREF="lgc.h.html#issweepphase">issweepphase</A>(g));
      g-&gt;sweepgc = <A HREF="lgc.c.html#sweeptolive">sweeptolive</A>(L, g-&gt;sweepgc, NULL);
    }
    /* search for pointer pointing to 'o' */
    for (p = &amp;g-&gt;allgc; *p != o; p = &amp;<A HREF="lstate.h.html#gch">gch</A>(*p)-&gt;next) { /* empty */ }
    *p = ho-&gt;next;  /* remove 'o' from root list */
    ho-&gt;next = g-&gt;finobj;  /* link it in list 'finobj' */
    g-&gt;finobj = o;
    <A HREF="lgc.h.html#l_setbit">l_setbit</A>(ho-&gt;marked, <A HREF="lgc.h.html#SEPARATED">SEPARATED</A>);  /* mark it as such */
    if (!<A HREF="lgc.h.html#keepinvariantout">keepinvariantout</A>(g))  /* not keeping invariant? */
      <A HREF="lgc.c.html#makewhite">makewhite</A>(g, o);  /* "sweep" object */
    else
      <A HREF="lgc.h.html#resetoldbit">resetoldbit</A>(o);  /* see MOVE OLD rule */
  }
}

/* }====================================================== */


/*
** {======================================================
** GC control
** =======================================================
*/


/*
** set a reasonable "time" to wait before starting a new GC cycle;
** cycle will start when memory use hits threshold
*/
static void <A NAME="setpause"><SPAN CLASS="definition">setpause</SPAN></A> (<A HREF="lstate.h.html#global_State">global_State</A> *g, <A HREF="llimits.h.html#l_mem">l_mem</A> estimate) {
  <A HREF="llimits.h.html#l_mem">l_mem</A> debt, threshold;
  estimate = estimate / <A HREF="lgc.c.html#PAUSEADJ">PAUSEADJ</A>;  /* adjust 'estimate' */
  threshold = (g-&gt;gcpause &lt; <A HREF="llimits.h.html#MAX_LMEM">MAX_LMEM</A> / estimate)  /* overflow? */
            ? estimate * g-&gt;gcpause  /* no overflow */
            : <A HREF="llimits.h.html#MAX_LMEM">MAX_LMEM</A>;  /* overflow; truncate to maximum */
  debt = -<A HREF="llimits.h.html#cast">cast</A>(<A HREF="llimits.h.html#l_mem">l_mem</A>, threshold - <A HREF="lstate.h.html#gettotalbytes">gettotalbytes</A>(g));
  <A HREF="lstate.c.html#luaE_setdebt">luaE_setdebt</A>(g, debt);
}


#define <A NAME="sweepphases"><SPAN CLASS="definition">sweepphases</SPAN></A>  \
        (<A HREF="lgc.h.html#bitmask">bitmask</A>(<A HREF="lgc.h.html#GCSsweepstring">GCSsweepstring</A>) | <A HREF="lgc.h.html#bitmask">bitmask</A>(<A HREF="lgc.h.html#GCSsweepudata">GCSsweepudata</A>) | <A HREF="lgc.h.html#bitmask">bitmask</A>(<A HREF="lgc.h.html#GCSsweep">GCSsweep</A>))


/*
** enter first sweep phase (strings) and prepare pointers for other
** sweep phases.  The calls to '<A HREF="lgc.c.html#sweeptolive">sweeptolive</A>' make pointers point to an
** object inside the list (instead of to the header), so that the real
** sweep do not need to skip objects created between "now" and the start
** of the real sweep.
** Returns how many objects it swept.
*/
static int <A NAME="entersweep"><SPAN CLASS="definition">entersweep</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  <A HREF="lstate.h.html#global_State">global_State</A> *g = <A HREF="lstate.h.html#G">G</A>(L);
  int n = 0;
  g-&gt;gcstate = <A HREF="lgc.h.html#GCSsweepstring">GCSsweepstring</A>;
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(g-&gt;sweepgc == NULL &amp;&amp; g-&gt;sweepfin == NULL);
  /* prepare to sweep strings, finalizable objects, and regular objects */
  g-&gt;sweepstrgc = 0;
  g-&gt;sweepfin = <A HREF="lgc.c.html#sweeptolive">sweeptolive</A>(L, &amp;g-&gt;finobj, &amp;n);
  g-&gt;sweepgc = <A HREF="lgc.c.html#sweeptolive">sweeptolive</A>(L, &amp;g-&gt;allgc, &amp;n);
  return n;
}


/*
** change GC mode
*/
void <A NAME="luaC_changemode"><SPAN CLASS="definition">luaC_changemode</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L, int mode) {
  <A HREF="lstate.h.html#global_State">global_State</A> *g = <A HREF="lstate.h.html#G">G</A>(L);
  if (mode == g-&gt;gckind) return;  /* nothing to change */
  if (mode == <A HREF="lstate.h.html#KGC_GEN">KGC_GEN</A>) {  /* change to generational mode */
    /* make sure gray lists are consistent */
    <A HREF="lgc.c.html#luaC_runtilstate">luaC_runtilstate</A>(L, <A HREF="lgc.h.html#bitmask">bitmask</A>(<A HREF="lgc.h.html#GCSpropagate">GCSpropagate</A>));
    g-&gt;GCestimate = <A HREF="lstate.h.html#gettotalbytes">gettotalbytes</A>(g);
    g-&gt;gckind = <A HREF="lstate.h.html#KGC_GEN">KGC_GEN</A>;
  }
  else {  /* change to incremental mode */
    /* sweep all objects to turn them back to white
       (as white has not changed, nothing extra will be collected) */
    g-&gt;gckind = <A HREF="lstate.h.html#KGC_NORMAL">KGC_NORMAL</A>;
    <A HREF="lgc.c.html#entersweep">entersweep</A>(L);
    <A HREF="lgc.c.html#luaC_runtilstate">luaC_runtilstate</A>(L, ~<A HREF="lgc.c.html#sweepphases">sweepphases</A>);
  }
}


/*
** call all pending finalizers
*/
static void <A NAME="callallpendingfinalizers"><SPAN CLASS="definition">callallpendingfinalizers</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L, int propagateerrors) {
  <A HREF="lstate.h.html#global_State">global_State</A> *g = <A HREF="lstate.h.html#G">G</A>(L);
  while (g-&gt;tobefnz) {
    <A HREF="lgc.h.html#resetoldbit">resetoldbit</A>(g-&gt;tobefnz);
    <A HREF="lgc.c.html#GCTM">GCTM</A>(L, propagateerrors);
  }
}


void <A NAME="luaC_freeallobjects"><SPAN CLASS="definition">luaC_freeallobjects</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  <A HREF="lstate.h.html#global_State">global_State</A> *g = <A HREF="lstate.h.html#G">G</A>(L);
  int i;
  <A HREF="lgc.c.html#separatetobefnz">separatetobefnz</A>(L, 1);  /* separate all objects with finalizers */
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(g-&gt;finobj == NULL);
  <A HREF="lgc.c.html#callallpendingfinalizers">callallpendingfinalizers</A>(L, 0);
  g-&gt;currentwhite = <A HREF="lgc.h.html#WHITEBITS">WHITEBITS</A>; /* this "white" makes all objects look dead */
  g-&gt;gckind = <A HREF="lstate.h.html#KGC_NORMAL">KGC_NORMAL</A>;
  <A HREF="lgc.c.html#sweepwholelist">sweepwholelist</A>(L, &amp;g-&gt;finobj);  /* finalizers can create objs. in 'finobj' */
  <A HREF="lgc.c.html#sweepwholelist">sweepwholelist</A>(L, &amp;g-&gt;allgc);
  for (i = 0; i &lt; g-&gt;strt.size; i++)  /* free all string lists */
    <A HREF="lgc.c.html#sweepwholelist">sweepwholelist</A>(L, &amp;g-&gt;strt.hash[i]);
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(g-&gt;strt.nuse == 0);
}


static <A HREF="llimits.h.html#l_mem">l_mem</A> <A NAME="atomic"><SPAN CLASS="definition">atomic</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  <A HREF="lstate.h.html#global_State">global_State</A> *g = <A HREF="lstate.h.html#G">G</A>(L);
  <A HREF="llimits.h.html#l_mem">l_mem</A> work = -<A HREF="llimits.h.html#cast">cast</A>(<A HREF="llimits.h.html#l_mem">l_mem</A>, g-&gt;GCmemtrav);  /* start counting work */
  <A HREF="lstate.h.html#GCObject">GCObject</A> *origweak, *origall;
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(!<A HREF="lgc.h.html#iswhite">iswhite</A>(<A HREF="lstate.h.html#obj2gco">obj2gco</A>(g-&gt;mainthread)));
  <A HREF="lgc.c.html#markobject">markobject</A>(g, L);  /* mark running thread */
  /* registry and global metatables may be changed by API */
  <A HREF="lgc.c.html#markvalue">markvalue</A>(g, &amp;g-&gt;l_registry);
  <A HREF="lgc.c.html#markmt">markmt</A>(g);  /* mark basic metatables */
  /* remark occasional upvalues of (maybe) dead threads */
  <A HREF="lgc.c.html#remarkupvals">remarkupvals</A>(g);
  <A HREF="lgc.c.html#propagateall">propagateall</A>(g);  /* propagate changes */
  work += g-&gt;GCmemtrav;  /* stop counting (do not (re)count grays) */
  /* traverse objects caught by write barrier and by '<A HREF="lgc.c.html#remarkupvals">remarkupvals</A>' */
  <A HREF="lgc.c.html#retraversegrays">retraversegrays</A>(g);
  work -= g-&gt;GCmemtrav;  /* restart counting */
  <A HREF="lgc.c.html#convergeephemerons">convergeephemerons</A>(g);
  /* at this point, all strongly accessible objects are marked. */
  /* clear values from weak tables, before checking finalizers */
  <A HREF="lgc.c.html#clearvalues">clearvalues</A>(g, g-&gt;weak, NULL);
  <A HREF="lgc.c.html#clearvalues">clearvalues</A>(g, g-&gt;allweak, NULL);
  origweak = g-&gt;weak; origall = g-&gt;allweak;
  work += g-&gt;GCmemtrav;  /* stop counting (objects being finalized) */
  <A HREF="lgc.c.html#separatetobefnz">separatetobefnz</A>(L, 0);  /* separate objects to be finalized */
  <A HREF="lgc.c.html#markbeingfnz">markbeingfnz</A>(g);  /* mark objects that will be finalized */
  <A HREF="lgc.c.html#propagateall">propagateall</A>(g);  /* remark, to propagate `preserveness' */
  work -= g-&gt;GCmemtrav;  /* restart counting */
  <A HREF="lgc.c.html#convergeephemerons">convergeephemerons</A>(g);
  /* at this point, all resurrected objects are marked. */
  /* remove dead objects from weak tables */
  <A HREF="lgc.c.html#clearkeys">clearkeys</A>(g, g-&gt;ephemeron, NULL);  /* clear keys from all ephemeron tables */
  <A HREF="lgc.c.html#clearkeys">clearkeys</A>(g, g-&gt;allweak, NULL);  /* clear keys from all allweak tables */
  /* clear values from resurrected weak tables */
  <A HREF="lgc.c.html#clearvalues">clearvalues</A>(g, g-&gt;weak, origweak);
  <A HREF="lgc.c.html#clearvalues">clearvalues</A>(g, g-&gt;allweak, origall);
  g-&gt;currentwhite = <A HREF="llimits.h.html#cast_byte">cast_byte</A>(<A HREF="lgc.h.html#otherwhite">otherwhite</A>(g));  /* flip current white */
  work += g-&gt;GCmemtrav;  /* complete counting */
  return work;  /* estimate of memory marked by '<A HREF="lgc.c.html#atomic">atomic</A>' */
}


static <A HREF="llimits.h.html#lu_mem">lu_mem</A> <A NAME="singlestep"><SPAN CLASS="definition">singlestep</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  <A HREF="lstate.h.html#global_State">global_State</A> *g = <A HREF="lstate.h.html#G">G</A>(L);
  switch (g-&gt;gcstate) {
    case <A HREF="lgc.h.html#GCSpause">GCSpause</A>: {
      /* start to count memory traversed */
      g-&gt;GCmemtrav = g-&gt;strt.size * sizeof(<A HREF="lstate.h.html#GCObject">GCObject</A>*);
      <A HREF="llimits.h.html#lua_assert">lua_assert</A>(!<A HREF="lgc.h.html#isgenerational">isgenerational</A>(g));
      <A HREF="lgc.c.html#restartcollection">restartcollection</A>(g);
      g-&gt;gcstate = <A HREF="lgc.h.html#GCSpropagate">GCSpropagate</A>;
      return g-&gt;GCmemtrav;
    }
    case <A HREF="lgc.h.html#GCSpropagate">GCSpropagate</A>: {
      if (g-&gt;gray) {
        <A HREF="llimits.h.html#lu_mem">lu_mem</A> oldtrav = g-&gt;GCmemtrav;
        <A HREF="lgc.c.html#propagatemark">propagatemark</A>(g);
        return g-&gt;GCmemtrav - oldtrav;  /* memory traversed in this step */
      }
      else {  /* no more `gray' objects */
        <A HREF="llimits.h.html#lu_mem">lu_mem</A> work;
        int sw;
        g-&gt;gcstate = <A HREF="lgc.h.html#GCSatomic">GCSatomic</A>;  /* finish mark phase */
        g-&gt;GCestimate = g-&gt;GCmemtrav;  /* save what was counted */;
        work = <A HREF="lgc.c.html#atomic">atomic</A>(L);  /* add what was traversed by '<A HREF="lgc.c.html#atomic">atomic</A>' */
        g-&gt;GCestimate += work;  /* estimate of total memory traversed */ 
        sw = <A HREF="lgc.c.html#entersweep">entersweep</A>(L);
        return work + sw * <A HREF="lgc.c.html#GCSWEEPCOST">GCSWEEPCOST</A>;
      }
    }
    case <A HREF="lgc.h.html#GCSsweepstring">GCSsweepstring</A>: {
      int i;
      for (i = 0; i &lt; <A HREF="lgc.c.html#GCSWEEPMAX">GCSWEEPMAX</A> &amp;&amp; g-&gt;sweepstrgc + i &lt; g-&gt;strt.size; i++)
        <A HREF="lgc.c.html#sweepwholelist">sweepwholelist</A>(L, &amp;g-&gt;strt.hash[g-&gt;sweepstrgc + i]);
      g-&gt;sweepstrgc += i;
      if (g-&gt;sweepstrgc &gt;= g-&gt;strt.size)  /* no more strings to sweep? */
        g-&gt;gcstate = <A HREF="lgc.h.html#GCSsweepudata">GCSsweepudata</A>;
      return i * <A HREF="lgc.c.html#GCSWEEPCOST">GCSWEEPCOST</A>;
    }
    case <A HREF="lgc.h.html#GCSsweepudata">GCSsweepudata</A>: {
      if (g-&gt;sweepfin) {
        g-&gt;sweepfin = <A HREF="lgc.c.html#sweeplist">sweeplist</A>(L, g-&gt;sweepfin, <A HREF="lgc.c.html#GCSWEEPMAX">GCSWEEPMAX</A>);
        return <A HREF="lgc.c.html#GCSWEEPMAX">GCSWEEPMAX</A>*<A HREF="lgc.c.html#GCSWEEPCOST">GCSWEEPCOST</A>;
      }
      else {
        g-&gt;gcstate = <A HREF="lgc.h.html#GCSsweep">GCSsweep</A>;
        return 0;
      }
    }
    case <A HREF="lgc.h.html#GCSsweep">GCSsweep</A>: {
      if (g-&gt;sweepgc) {
        g-&gt;sweepgc = <A HREF="lgc.c.html#sweeplist">sweeplist</A>(L, g-&gt;sweepgc, <A HREF="lgc.c.html#GCSWEEPMAX">GCSWEEPMAX</A>);
        return <A HREF="lgc.c.html#GCSWEEPMAX">GCSWEEPMAX</A>*<A HREF="lgc.c.html#GCSWEEPCOST">GCSWEEPCOST</A>;
      }
      else {
        /* sweep <A HREF="lua.c.html#main">main</A> thread */
        <A HREF="lstate.h.html#GCObject">GCObject</A> *mt = <A HREF="lstate.h.html#obj2gco">obj2gco</A>(g-&gt;mainthread);
        <A HREF="lgc.c.html#sweeplist">sweeplist</A>(L, &amp;mt, 1);
        <A HREF="lgc.c.html#checkSizes">checkSizes</A>(L);
        g-&gt;gcstate = <A HREF="lgc.h.html#GCSpause">GCSpause</A>;  /* finish collection */
        return <A HREF="lgc.c.html#GCSWEEPCOST">GCSWEEPCOST</A>;
      }
    }
    default: <A HREF="llimits.h.html#lua_assert">lua_assert</A>(0); return 0;
  }
}


/*
** advances the garbage collector until it reaches a state allowed
** by 'statemask'
*/
void <A NAME="luaC_runtilstate"><SPAN CLASS="definition">luaC_runtilstate</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L, int statesmask) {
  <A HREF="lstate.h.html#global_State">global_State</A> *g = <A HREF="lstate.h.html#G">G</A>(L);
  while (!<A HREF="lgc.h.html#testbit">testbit</A>(statesmask, g-&gt;gcstate))
    <A HREF="lgc.c.html#singlestep">singlestep</A>(L);
}


static void <A NAME="generationalcollection"><SPAN CLASS="definition">generationalcollection</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  <A HREF="lstate.h.html#global_State">global_State</A> *g = <A HREF="lstate.h.html#G">G</A>(L);
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(g-&gt;gcstate == <A HREF="lgc.h.html#GCSpropagate">GCSpropagate</A>);
  if (g-&gt;GCestimate == 0) {  /* signal for another major collection? */
    <A HREF="lgc.c.html#luaC_fullgc">luaC_fullgc</A>(L, 0);  /* perform a full regular collection */
    g-&gt;GCestimate = <A HREF="lstate.h.html#gettotalbytes">gettotalbytes</A>(g);  /* update control */
  }
  else {
    <A HREF="llimits.h.html#lu_mem">lu_mem</A> estimate = g-&gt;GCestimate;
    <A HREF="lgc.c.html#luaC_runtilstate">luaC_runtilstate</A>(L, <A HREF="lgc.h.html#bitmask">bitmask</A>(<A HREF="lgc.h.html#GCSpause">GCSpause</A>));  /* run complete (minor) cycle */
    g-&gt;gcstate = <A HREF="lgc.h.html#GCSpropagate">GCSpropagate</A>;  /* skip restart */
    if (<A HREF="lstate.h.html#gettotalbytes">gettotalbytes</A>(g) &gt; (estimate / 100) * g-&gt;gcmajorinc)
      g-&gt;GCestimate = 0;  /* signal for a major collection */
    else
      g-&gt;GCestimate = estimate;  /* keep estimate from last major coll. */

  }
  <A HREF="lgc.c.html#setpause">setpause</A>(g, <A HREF="lstate.h.html#gettotalbytes">gettotalbytes</A>(g));
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(g-&gt;gcstate == <A HREF="lgc.h.html#GCSpropagate">GCSpropagate</A>);
}


static void <A NAME="incstep"><SPAN CLASS="definition">incstep</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  <A HREF="lstate.h.html#global_State">global_State</A> *g = <A HREF="lstate.h.html#G">G</A>(L);
  <A HREF="llimits.h.html#l_mem">l_mem</A> debt = g-&gt;GCdebt;
  int stepmul = g-&gt;gcstepmul;
  if (stepmul &lt; 40) stepmul = 40;  /* avoid ridiculous low values (and 0) */
  /* convert debt from Kb to 'work units' (avoid zero debt and overflows) */
  debt = (debt / <A HREF="lgc.c.html#STEPMULADJ">STEPMULADJ</A>) + 1;
  debt = (debt &lt; <A HREF="llimits.h.html#MAX_LMEM">MAX_LMEM</A> / stepmul) ? debt * stepmul : <A HREF="llimits.h.html#MAX_LMEM">MAX_LMEM</A>;
  do {  /* always perform at least one single step */
    <A HREF="llimits.h.html#lu_mem">lu_mem</A> work = <A HREF="lgc.c.html#singlestep">singlestep</A>(L);  /* do some work */
    debt -= work;
  } while (debt &gt; -<A HREF="lgc.h.html#GCSTEPSIZE">GCSTEPSIZE</A> &amp;&amp; g-&gt;gcstate != <A HREF="lgc.h.html#GCSpause">GCSpause</A>);
  if (g-&gt;gcstate == <A HREF="lgc.h.html#GCSpause">GCSpause</A>)
    <A HREF="lgc.c.html#setpause">setpause</A>(g, g-&gt;GCestimate);  /* pause until next cycle */
  else {
    debt = (debt / stepmul) * <A HREF="lgc.c.html#STEPMULADJ">STEPMULADJ</A>;  /* convert 'work units' to Kb */
    <A HREF="lstate.c.html#luaE_setdebt">luaE_setdebt</A>(g, debt);
  }
}


/*
** performs a basic GC step
*/
void <A NAME="luaC_forcestep"><SPAN CLASS="definition">luaC_forcestep</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  <A HREF="lstate.h.html#global_State">global_State</A> *g = <A HREF="lstate.h.html#G">G</A>(L);
  int i;
  if (<A HREF="lgc.h.html#isgenerational">isgenerational</A>(g)) <A HREF="lgc.c.html#generationalcollection">generationalcollection</A>(L);
  else <A HREF="lgc.c.html#incstep">incstep</A>(L);
  /* run a few finalizers (or all of them at the end of a collect cycle) */
  for (i = 0; g-&gt;tobefnz &amp;&amp; (i &lt; <A HREF="lgc.c.html#GCFINALIZENUM">GCFINALIZENUM</A> || g-&gt;gcstate == <A HREF="lgc.h.html#GCSpause">GCSpause</A>); i++)
    <A HREF="lgc.c.html#GCTM">GCTM</A>(L, 1);  /* call one finalizer */
}


/*
** performs a basic GC step only if collector is running
*/
void <A NAME="luaC_step"><SPAN CLASS="definition">luaC_step</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L) {
  <A HREF="lstate.h.html#global_State">global_State</A> *g = <A HREF="lstate.h.html#G">G</A>(L);
  if (g-&gt;gcrunning) <A HREF="lgc.c.html#luaC_forcestep">luaC_forcestep</A>(L);
  else <A HREF="lstate.c.html#luaE_setdebt">luaE_setdebt</A>(g, -<A HREF="lgc.h.html#GCSTEPSIZE">GCSTEPSIZE</A>);  /* avoid being called too often */
}



/*
** performs a full GC cycle; if "isemergency", does not call
** finalizers (which could change stack positions)
*/
void <A NAME="luaC_fullgc"><SPAN CLASS="definition">luaC_fullgc</SPAN></A> (<A HREF="lstate.h.html#lua_State">lua_State</A> *L, int isemergency) {
  <A HREF="lstate.h.html#global_State">global_State</A> *g = <A HREF="lstate.h.html#G">G</A>(L);
  int origkind = g-&gt;gckind;
  <A HREF="llimits.h.html#lua_assert">lua_assert</A>(origkind != <A HREF="lstate.h.html#KGC_EMERGENCY">KGC_EMERGENCY</A>);
  if (isemergency)  /* do not run finalizers during emergency GC */
    g-&gt;gckind = <A HREF="lstate.h.html#KGC_EMERGENCY">KGC_EMERGENCY</A>;
  else {
    g-&gt;gckind = <A HREF="lstate.h.html#KGC_NORMAL">KGC_NORMAL</A>;
    <A HREF="lgc.c.html#callallpendingfinalizers">callallpendingfinalizers</A>(L, 1);
  }
  if (<A HREF="lgc.h.html#keepinvariant">keepinvariant</A>(g)) {  /* may there be some black objects? */
    /* must sweep all objects to turn them back to white
       (as white has not changed, nothing will be collected) */
    <A HREF="lgc.c.html#entersweep">entersweep</A>(L);
  }
  /* finish any pending sweep phase to start a new cycle */
  <A HREF="lgc.c.html#luaC_runtilstate">luaC_runtilstate</A>(L, <A HREF="lgc.h.html#bitmask">bitmask</A>(<A HREF="lgc.h.html#GCSpause">GCSpause</A>));
  <A HREF="lgc.c.html#luaC_runtilstate">luaC_runtilstate</A>(L, ~<A HREF="lgc.h.html#bitmask">bitmask</A>(<A HREF="lgc.h.html#GCSpause">GCSpause</A>));  /* start new collection */
  <A HREF="lgc.c.html#luaC_runtilstate">luaC_runtilstate</A>(L, <A HREF="lgc.h.html#bitmask">bitmask</A>(<A HREF="lgc.h.html#GCSpause">GCSpause</A>));  /* run entire collection */
  if (origkind == <A HREF="lstate.h.html#KGC_GEN">KGC_GEN</A>) {  /* generational mode? */
    /* generational mode must be kept in propagate phase */
    <A HREF="lgc.c.html#luaC_runtilstate">luaC_runtilstate</A>(L, <A HREF="lgc.h.html#bitmask">bitmask</A>(<A HREF="lgc.h.html#GCSpropagate">GCSpropagate</A>));
  }
  g-&gt;gckind = origkind;
  <A HREF="lgc.c.html#setpause">setpause</A>(g, <A HREF="lstate.h.html#gettotalbytes">gettotalbytes</A>(g));
  if (!isemergency)   /* do not run finalizers during emergency GC */
    <A HREF="lgc.c.html#callallpendingfinalizers">callallpendingfinalizers</A>(L, 1);
}

/* }====================================================== */


</PRE>

<P CLASS="footer">
Last update:
Sat Mar  5 09:15:40 2016
</P>

</BODY>
</HTML>
