<HEAD>
<TITLE>Lua 2.5 Reference Manual</TITLE>
</HEAD>
<BODY>
<h1>Lua 2.5 Reference Manual</h1>

<!-- ====================================================================== -->
<HR>
<A NAME="1."></A>
<H1>1 - Introduction</H1>
<P>
Lua is an extension programming language designed to support
general procedural programming features with data description
facilities.
It is intended to be used as a
light-weight, but powerful, configuration language for any
program that needs one.
Lua has been designed and implemented by
W.&nbsp;Celes,
R.&nbsp;Ierusalimschy and
L.&nbsp;H.&nbsp;de Figueiredo.
<P>
Lua is implemented as a library, written in C.
Being an extension language, Lua has no notion of a ``main'' program:
it only works <EM>embedded</EM> in a host client,
called the <EM>embedding</EM> program.
This host program can invoke functions to execute a piece of
code in Lua, can write and read Lua variables,
and can register C functions to be called by Lua code.
Through the use of C functions, Lua can be augmented to cope with
many, completely different domains,
thus creating customized programming languages sharing a syntactical framework.
<P>
Lua is free-distribution software,
and provided as usual with no guarantees.
The implementation described in this manual is available
at the following URL's:
<LISTING>
   <A HREF="http://www.inf.puc-rio.br/~roberto/lua.html">http://www.inf.puc-rio.br/~roberto/lua.html</A>
   <A HREF="ftp://ftp.icad.puc-rio.br/pub/lua/lua.tar.gz">ftp://ftp.icad.puc-rio.br/pub/lua/lua.tar.gz</A>
</LISTING>
<P>
<P>
<!-- ====================================================================== -->
<HR>
<A NAME="2."></A>
<H1>2 - Environment and Chunks</H1>
<P>
All statements in Lua are executed in a <A NAME="global environment"><EM>global environment</EM></A>.
This environment, which keeps all global variables and functions,
is initialized at the beginning of the embedding program and
persists until its end.
<P>
The global environment can be manipulated by Lua code or
by the embedding program,
which can read and write global variables
using functions in the library that implements Lua.
<P>
<A NAME="Global variables">Global variables</A> do not need declaration.
Any variable is assumed to be global unless explicitly declared local
(see Section&nbsp;<A HREF="#localvar">4.4.5</A>).
Before the first assignment, the value of a global variable is <B>nil</B>.
<P>
The unit of execution of Lua is called a <A NAME="chunk"><EM>chunk</EM></A>.
The syntax
for chunks is:
<LISTING>
chunk := {stat | function} [ret]
</LISTING>
A chunk may contain statements and function definitions,
and may be in a file or in a string inside the host program.
A chunk may optionally end with a <CODE>return</CODE> statement (see Section&nbsp;<A HREF="#return">4.4.3</A>).
When a chunk is executed, first all its functions and statements are compiled,
then the statements are executed in sequential order.
All modifications a chunk effects on the global environment persist
after its end.
Those include modifications to global variables and definitions
of new functions
<P>
Chunks may be pre-compiled; see program <A NAME="luac"><TT>luac</TT></A> for details.
Text files with chunks and their binary pre-compiled forms
are interchangeable.
Lua automatically detects the file type and acts accordingly.
<A NAME="pre-compilation"></A>
<P>
<A NAME="TypesSec"></A>
<!-- ====================================================================== -->
<HR>
<A NAME="3."></A>
<H1>3 - Types</H1> 
<P>
Lua is a dynamically typed language.
Variables do not have types; only values do.
All values carry their own type.
Therefore, there are no type definitions in the language.
<P>
There are seven <A NAME="basic types">basic types</A> in Lua: <A NAME="nil"><EM>nil</EM></A>, <A NAME="number"><EM>number</EM></A>,
<A NAME="string"><EM>string</EM></A>, <A NAME="function"><EM>function</EM></A>, <A NAME="CFunction"><EM>CFunction</EM></A>, <A NAME="userdata"><EM>userdata</EM></A>,
and <A NAME="table"><EM>table</EM></A>.
<EM>Nil</EM> is the type of the value <B>nil</B>,
whose main property is to be different from any other value.
<EM>Number</EM> represents real (floating point) numbers,
while <EM>string</EM> has the usual meaning.
<P>
Functions are considered first-class values in Lua.
This means that functions can be stored in variables,
passed as arguments to other functions and returned as results.
When a function is defined in Lua, its body is compiled and stored
in a given variable.
Lua can call (and manipulate) functions written in Lua and
functions written in C; the latter have type <EM>CFunction</EM>.
<P>
The type <EM>userdata</EM> is provided to allow
arbitrary <A NAME="C pointers">C pointers</A> to be stored in Lua variables.
It corresponds to <CODE>void*</CODE> and has no pre-defined operations in Lua,
besides assignment and equality test.
However, by using fallbacks, the programmer may define operations
for <EM>userdata</EM> values; (see Section&nbsp;<A HREF="#fallback">4.7</A>).
<P>
The type <EM>table</EM> implements <A NAME="associative arrays">associative arrays</A>,
that is, <A NAME="arrays">arrays</A> that can be indexed not only with numbers,
but with any value (except <B>nil</B>).
Therefore, this type may be used not only to represent ordinary arrays,
but also symbol tables, sets, records, etc.
To represent <A NAME="records">records</A>, Lua uses the field name as an index.
The language supports this representation by
providing <CODE>a.name</CODE> as syntactic sugar for <CODE>a["name"]</CODE>.
Tables may also carry methods.
Because functions are first class values,
table fields may contain functions.
The form <CODE>t:f(x)</CODE> is syntactic sugar for <CODE>t.f(t,x)</CODE>,
which calls the method <CODE>f</CODE> from the table <CODE>t</CODE> passing
itself as the first parameter.
<P>
It is important to notice that tables are <EM>objects</EM>, and not values.
Variables cannot contain tables, only <EM>references</EM> to them.
Assignment, parameter passing and returns always manipulate references
to tables, and do not imply any kind of copy.
Moreover, tables must be explicitly created before used
(see Section&nbsp;<A HREF="#tableconstructor">4.5.7</A>).
<P>
<P>
<P>
<!-- ====================================================================== -->
<HR>
<A NAME="4."></A>
<H1>4 - The Language</H1>
<P>
This section describes the lexis, the syntax and the semantics of Lua.
<P>
<P>
<A NAME="lexical"></A>
<A NAME="4.1"></A>
<H2>4.1 - Lexical Conventions</H2> 
<P>
Lua is a case sensitive language.
<A NAME="Identifiers">Identifiers</A> can be any string of letters, digits, and underscores,
not beginning with a digit.
The following words are reserved, and cannot be used as identifiers:
<A NAME="reserved words"></A>
<LISTING>
      and       do        else      elseif
      end       function  if        local
      nil       not       or        repeat
      return    then      until     while
</LISTING>
<P>
The following strings denote other <A NAME="tokens">tokens</A>:
<LISTING>
         ~=  &lt;=  &gt;=  &lt;   &gt;   ==  =   ..  +   -   *   /
         %   (   )   {   }   [   ]   ;   ,   .
</LISTING>
<P>
<A NAME="Literal strings">Literal strings</A> can be delimited by matching single or double quotes,
and can contain the C-like escape sequences
<CODE>'\n'</CODE>, <CODE>'\t'</CODE> and <CODE>'\r'</CODE>.
Literal strings can also be delimited by matching <CODE>[[ ... ]]</CODE>.
Literals in this bracketed form may run for several lines,
may contain nested <CODE>[[ ... ]]</CODE> pairs,
and do not interpret escape sequences.
This form is specially convenient for
handling text that has quoted strings in it.
<P>
<A NAME="Comments">Comments</A> start anywhere outside a string with a
double hyphen (<CODE>--</CODE>) and run until the end of the line.
Moreover, if the first line of a chunk file starts with <CODE>#</CODE>,
this line is skipped
<P>
<A NAME="Numerical constants">Numerical constants</A> may be written with an optional decimal part,
and an optional decimal exponent.
Examples of valid numerical constants are:
<LISTING>
       4     4.0     0.4     4.57e-3     0.3e12
</LISTING>
<P>
<P>
<A NAME="coercion"></A>
<A NAME="4.2"></A>
<H2>4.2 - Coercion</H2> 
<P>
Lua provides some automatic conversions between values.
Any arithmetic operation applied to a string tries to convert
that string to a number, following the usual rules.
Conversely, whenever a number is used when a string is expected,
that number is converted to a string, according to the following rule:
if the number is an integer, it is written without exponent or decimal point;
otherwise, it is formatted following the <CODE>%g</CODE>
conversion specification of the <CODE>printf</CODE> function in the
standard C library.
For complete control on how numbers are converted to strings,
use the <CODE>format</CODE> function (see Section&nbsp;<A HREF="#format">6.2</A>).
<P>
<P>
<A NAME="adjust"></A>
<A NAME="4.3"></A>
<H2>4.3 - Adjustment</H2> 
<P>
Functions in Lua can return many values.
Because there are no type declarations,
the system does not know how many values a function will return,
or how many parameters it needs.
Therefore, sometimes, a list of values must be <EM>adjusted</EM>, at run time,
to a given length.
If there are more values than are needed, then the last values are thrown away.
If there are more needs than values, then the list is extended with as
many  <B>nil</B>'s as needed.
Adjustment occurs in multiple assignment and function calls.
<P>
<P>
<A NAME="4.4"></A>
<H2>4.4 - Statements</H2>
<P>
Lua supports an almost conventional set of <A NAME="statements">statements</A>,
similar to those in Pascal or C.
The conventional commands include
assignment, control structures and procedure calls.
Non-conventional commands include table constructors
(see Section&nbsp;<A HREF="#tableconstructor">4.5.7</A>),
and local variable declarations (see Section&nbsp;<A HREF="#localvar">4.4.5</A>).
<P>
<H3>4.4.1 - Blocks</H3>
A <A NAME="block">block</A> is a list of statements, which are executed sequentially.
Any statement can be optionally followed by a semicolon:
<LISTING>
block := {stat sc} [ret]
sc := ['<B>;</B>']
</LISTING>
For syntactic reasons, a <A NAME="return"><TT>return</TT></A> statement can only be written
as the last statement of a block.
This restriction also avoids some ``statement not reached'' errors.
<P>
<A NAME="assignment"></A>
<H3>4.4.2 - <A NAME="Assignment</H3>">Assignment</H3></A> 
The language allows <A NAME="multiple assignment">multiple assignment</A>.
Therefore, the syntax defines a list of variables on the left side,
and a list of expressions on the right side.
Both lists have their elements separated by commas:
<LISTING>
stat := varlist1 '<B>=</B>' explist1
varlist1 := var {'<B>,</B>' var}
</LISTING>
This statement first evaluates all values on the right side
and eventual indices on the left side,
and then makes the assignments.
Therefore, it can be used to exchange two values, as in
<LISTING>
   x, y = y, x
</LISTING>
Before the assignment, the list of values is <EM>adjusted</EM> to
the length of the list of variables (see Section&nbsp;<A HREF="#adjust">4.3</A>).
<P>
A single name can denote a global or a local variable,
or a formal parameter:
<LISTING>
var := name
</LISTING>
Square brackets are used to index a table:
<LISTING>
var := var '<B>[</B>' exp1 '<B>]</B>'
</LISTING>
If <CODE>var</CODE> results in a table value,
the field indexed by the expression value gets the assigned value.
Otherwise, the fallback <EM>settable</EM> is called,
with three parameters: the value of <CODE>var</CODE>,
the value of expression, and the value being assigned to it;
(see Section&nbsp;<A HREF="#fallback">4.7</A>).
<P>
The syntax <CODE>var.NAME</CODE> is just syntactic sugar for
<CODE>var["NAME"]</CODE>:
<LISTING>
var := var '<B>.</B>' name
</LISTING>
<P>
<H3>4.4.3 - Control Structures</H3>
The <A NAME="condition expression">condition expression</A> of a control structure may return any value.
All values different from <B>nil</B> are considered true;
only <B>nil</B> is considered false.
<TT>if</TT>'s, <TT>while</TT>'s and <TT>repeat</TT>'s have the usual meaning.
<P>
<A NAME="while-do"></A><A NAME="repeat-until"></A><A NAME="if-then-else"></A>
<LISTING>
stat := <B>while</B> exp1 <B>do</B> block <B>end</B> <BR>	| <B>repeat</B> block <B>until</B> exp1 <BR>	| <B>if</B> exp1 <B>then</B> block {elseif} [<B>else</B> block] <B>end</B>
elseif := <B>elseif</B> exp1 <B>then</B> block
</LISTING>
<P>
A <TT>return</TT> is used to return values from a function or a chunk.
<A NAME="return"></A>

Because they may return more than one value,
the syntax for a <A NAME="return statement">return statement</A> is:
<LISTING>
ret := <B>return</B> [explist1] [sc]
</LISTING>
<P>
<A NAME="funcstat"></A>
<H3>4.4.4 - Function Calls as Statements</H3> 
Because of possible side-effects,
function calls can be executed as statements:
<LISTING>
stat := functioncall
</LISTING>
In this case, returned values are thrown away.
Function calls are explained in Section&nbsp;<A HREF="#functioncall">4.5.8</A>.
<P>
<A NAME="localvar"></A>
<H3>4.4.5 - Local Declarations</H3> 
<A NAME="Local variables">Local variables</A> may be declared anywhere inside a block.
Their scope begins after the declaration and lasts until the
end of the block.
The declaration may include an initial assignment:
<LISTING>
stat := <B>local</B> declist [init]
declist := name {'<B>,</B>' name}
init := '<B>=</B>' explist1
</LISTING>
If present, an initial assignment has the same semantics
of a multiple assignment.
Otherwise, all variables are initialized with <B>nil</B>.
<P>
<P>
<A NAME="4.5"></A>
<H2>4.5 - Expressions</H2>
<P>
<H3>4.5.1 - <A NAME="Simple Expressions</H3>">Simple Expressions</H3></A>
Simple expressions are:
<LISTING>
exp := '<B>(</B>' exp '<B>)</B>'
exp := <B>nil</B>
exp := '<B>number</B>'
exp := '<B>literal</B>'
exp := var
</LISTING>
Numbers (numerical constants) and
string literals are explained in Section&nbsp;<A HREF="#lexical">4.1</A>.
Variables are explained in Section&nbsp;<A HREF="#assignment">4.4.2</A>.
<P>
The non-terminal <CODE>exp1</CODE> is used to indicate that the values
returned by an expression must be adjusted to one single value:
<LISTING>
exp1 := exp
</LISTING>
<P>
<H3>4.5.2 - Arithmetic Operators</H3>
Lua supports the usual <A NAME="arithmetic operators">arithmetic operators</A>.
These operators are the binary
<CODE>+</CODE> (addition),
<CODE>-</CODE> (subtraction),
<CODE>*</CODE> (multiplication),
<CODE>/</CODE> (division) and <CODE>^</CODE> (exponentiation),
and the unary <CODE>-</CODE> (negation).
If the operands are numbers, or strings that can be converted to
numbers, according to the rules given in Section&nbsp;<A HREF="#coercion">4.2</A>,
then all operations except exponentiation have the usual meaning.
Otherwise, the fallback ``arith'' is called (see Section&nbsp;<A HREF="#fallback">4.7</A>).
An exponentiation always calls this fallback.
The standard mathematical library redefines this fallback,
giving the expected meaning to <A NAME="exponentiation">exponentiation</A>
(see Section&nbsp;<A HREF="#mathlib">6.3</A>).
<P>
<H3>4.5.3 - Relational Operators</H3>
Lua provides the following <A NAME="relational operators">relational operators</A>:
<LISTING>
       &lt;   &gt;   &lt;=  &gt;=  ~=  ==
</LISTING>
All these return <B>nil</B> as false and a value different from <B>nil</B>\
(actually the number 1) as true.
<P>
Equality first compares the types of its operands.
If they are different, then the result is <B>nil</B>.
Otherwise, their values are compared.
Numbers and strings are compared in the usual way.
Tables, CFunctions, and functions are compared by reference,
that is, two tables are considered equal only if they are the same table.
The operator <CODE>~=</CODE> is exactly the negation of equality (<CODE>==</CODE>).
Note that the conversion rules of Section&nbsp;<A HREF="#coercion">4.2</A>
do not apply to equality comparisons.
Thus, <CODE>"0"==0</CODE> evaluates to false.
<P>
The other operators work as follows.
If both arguments are numbers, then they are compared as such.
Otherwise, if both arguments can be converted to strings,
their values are compared using lexicographical order.
Otherwise, the ``order'' fallback is called (see Section&nbsp;<A HREF="#fallback">4.7</A>).
<P>
<H3>4.5.4 - Logical Operators</H3>
Like control structures, all logical operators
consider <B>nil</B> as false and anything else as true.
The <A NAME="logical operators">logical operators</A> are:
<A NAME="and"></A><A NAME="or"></A><A NAME="not"></A>
<LISTING>
             and   or   not
</LISTING>
The operator <CODE>and</CODE> returns <B>nil</B> if its first argument is <B>nil</B>;
otherwise it returns its second argument.
The operator <CODE>or</CODE> returns its first argument
if it is different from <B>nil</B>;
otherwise it returns its second argument.
Both <CODE>and</CODE> and <CODE>or</CODE> use <A NAME="short-cut evaluation">short-cut evaluation</A>,
that is,
the second operand is evaluated only if necessary.
<P>
<H3>4.5.5 - Concatenation</H3>
Lua offers a string <A NAME="concatenation">concatenation</A> operator,
denoted by ``<A NAME=".."><TT>..</TT></A>''.
If operands are strings or numbers, then they are converted to
strings according to the rules in Section&nbsp;<A HREF="#coercion">4.2</A>.
Otherwise, the fallback ``concat'' is called (see Section&nbsp;<A HREF="#fallback">4.7</A>).
<P>
<H3>4.5.6 - Precedence</H3>
<A NAME="Operator precedence">Operator precedence</A> follows the table below,
from the lower to the higher priority:
<LISTING>
             and   or
             &lt;   &gt;   &lt;=  &gt;=  ~=  ==
             ..
             +   -
             *   /
             not  - (unary)
             ^
</LISTING>
All binary operators are left associative,
except for <CODE>^</CODE> (exponentiation),
which is right associative.
<P>
<A NAME="tableconstructor"></A>
<H3>4.5.7 - Table Constructors</H3> 
Table <A NAME="constructors">constructors</A> are expressions that create tables;
every time a constructor is evaluated, a new table is created.
Constructors can be used to create empty tables,
or to create a table and initialize some fields.
<P>
The general syntax for constructors is:
<LISTING>
tableconstructor := '<B>{</B>' fieldlist '<B>}</B>'
fieldlist := lfieldlist | ffieldlist | lfieldlist '<B>;</B>' ffieldlist
lfieldlist := [lfieldlist1]
ffieldlist := [ffieldlist1]
</LISTING>
<P>
The form <EM>lfieldlist1</EM> is used to initialize lists.
<LISTING>
lfieldlist1 := exp {'<B>,</B>' exp} ['<B>,</B>']
</LISTING>
The expressions in the list are assigned to consecutive numerical indices,
starting with 1.
For example:
<LISTING>
   a = {"v1", "v2", 34}
</LISTING>
is essentialy equivalent to:
<LISTING>
   temp = {}
   temp[1] = "v1"
   temp[2] = "v2"
   temp[3] = 34
   a = temp
</LISTING>
<P>
The next form initializes named fields in a table:
<LISTING>
ffieldlist1 := ffield {'<B>,</B>' ffield} ['<B>,</B>']
ffield := name '<B>=</B>' exp
</LISTING>
For example:
<LISTING>
   a = {x = 1, y = 3}
</LISTING>
is essentialy equivalent to:
<LISTING>
   temp = {}
   temp.x = 1    -- or temp["x"] = 1
   temp.y = 3    -- or temp["y"] = 3
   a = temp
</LISTING>
<P>
<P>
<A NAME="functioncall"></A>
<H3>4.5.8 - Function Calls</H3>  
A <A NAME="function call">function call</A> has the following syntax:
<LISTING>
functioncall := var realParams
</LISTING>
Here, <CODE>var</CODE> can be any variable (global, local, indexed, etc).
If its value has type <EM>function</EM> or <EM>CFunction</EM>,
then this function is called.
Otherwise, the ``function'' fallback is called,
having as first parameter the value of <CODE>var</CODE>,
and then the original call parameters.
<P>
The form:
<LISTING>
functioncall := var '<B>:</B>' name realParams
</LISTING>
can be used to call ``methods''.
A call <CODE>var:name(...)</CODE>
is syntactic sugar for
<LISTING>
  var.name(var, ...)
</LISTING>
except that <CODE>var</CODE> is evaluated only once.
<P>
<LISTING>
realParams := '<B>(</B>' [explist1] '<B>)</B>'
realParams := tableconstructor
explist1 := exp1 {'<B>,</B>' exp1}
</LISTING>
All argument expressions are evaluated before the call;
then the list of <A NAME="arguments">arguments</A> is adjusted to
the length of the list of parameters (see Section&nbsp;<A HREF="#adjust">4.3</A>);
finally, this list is assigned to the formal parameters.
A call of the form <CODE>f{...}</CODE> is syntactic sugar for
<CODE>f({...})</CODE>, that is,
the parameter list is a single new table.
<P>
Because a function can return any number of results
(see Section&nbsp;<A HREF="#return">4.4.3</A>),
the number of results must be adjusted before used.
If the function is called as a statement (see Section&nbsp;<A HREF="#funcstat">4.4.4</A>),
its return list is adjusted to 0,
thus discarding all returned values.
If the function is called in a place that needs a single value
(syntactically denoted by the non-terminal <CODE>exp1</CODE>),
then its return list is adjusted to 1,
thus discarding all returned values,
except the first one.
If the function is called in a place that can hold many values
(syntactically denoted by the non-terminal <CODE>exp</CODE>),
then no adjustment is made.
<P>
<P>
<A NAME="4.6"></A>
<H2>4.6 - Function Definitions</H2>
<P>
Functions in Lua can be defined anywhere in the global level of a chunk.
The syntax for function definition is:
<LISTING>
function := <B>function</B> var '<B>(</B>' [parlist1] '<B>)</B>' block <B>end</B>
</LISTING>
<P>
When Lua pre-compiles a chunk,
all its function bodies are pre-compiled, too.
Then, when Lua ``executes'' the function definition,
its body is stored, with type <EM>function</EM>,
into the variable <CODE>var</CODE>.
It is in this sense that
a function definition is an assignment to a global variable.
<P>
Parameters act as local variables,
initialized with the argument values.
<LISTING>
parlist1 := name {'<B>,</B>' name}
</LISTING>
<P>
Results are returned using the <CODE>return</CODE> statement (see Section&nbsp;<A HREF="#return">4.4.3</A>).
If control reaches the end of a function without a return instruction,
then the function returns with no results.
<P>
There is a special syntax for defining <A NAME="methods">methods</A>,
that is, functions that have an extra parameter <A NAME="self"><EM>self</EM></A>.
<LISTING>
function := <B>function</B> var '<B>:</B>' name '<B>(</B>' [parlist1] '<B>)</B>' block <B>end</B>
</LISTING>
Thus, a declaration like
<LISTING>
function v:f (...)
  ...
end
</LISTING>
is equivalent to
<LISTING>
function v.f (self, ...)
  ...
end
</LISTING>
that is, the function gets an extra formal parameter called <CODE>self</CODE>.
Notice that
the variable <CODE>v</CODE> must have been previously initialized with a table value.
<P>
<P>
<A NAME="fallback"></A>
<A NAME="4.7"></A>
<H2>4.7 - Fallbacks</H2> 
<P>
Lua provides a powerful mechanism to extend its semantics,
called <A NAME="fallbacks"><EM>fallbacks</EM></A>.
A fallback is a programmer defined function
that is called whenever Lua does not know how to proceed.
<P>
Lua supports the following fallbacks,
identified by the given strings:
<DL>
<DT><B>``arith'':</B><DD><A NAME="arithmetic fallback"></A>
called when an arithmetic operation is applied to non numerical operands,
or when the binary <CODE>^</CODE> operation (exponentiation) is called.
It receives three arguments:
the two operands (the second one is <B>nil</B> when the operation is unary minus)
and one of the following strings describing the offended operator:
<LISTING>
  add  sub  mul  div  pow  unm
</LISTING>
Its return value is the final result of the arithmetic operation.
The default handler issues an error.
<DT><B>``order'':</B><DD><A NAME="order fallback"></A>
called when an order comparison is applied to non numerical or
non string operands.
It receives three arguments:
the two operands and
one of the following strings describing the offended operator:
<LISTING>
  lt gt le ge
</LISTING>
Its return value is the final result of the comparison operation.
The default handler issues an error.
<DT><B>``concat'':</B><DD><A NAME="concatenation fallback"></A>
called when a concatenation is applied to non string operands.
It receives the two operands as arguments.
Its return value is the final result of the concatenation operation.
The default handler issues an error.
<DT><B>``index'':</B><DD><A NAME="index fallback"></A>
called when Lua tries to retrieve the value of an index
not present in a table.
It receives as arguments the table and the index.
Its return value is the final result of the indexing operation.
The default handler returns <B>nil</B>.
<DT><B>``getglobal'':</B><DD><A NAME="index getglobal"></A>
called when Lua tries to retrieve the value of a global variable
which has a <B>nil</B> value (or which has not been initialized).
It receives as argument the name of the variable.
Its return value is the final result of the expression.
The default handler returns <B>nil</B>.
<DT><B>``gettable'':</B><DD><A NAME="gettable fallback"></A>
called when Lua tries to index a non table value.
It receives as arguments the non table value and the index.
Its return value is the final result of the indexing operation.
The default handler issues an error.
<DT><B>``settable'':</B><DD><A NAME="settable fallback"></A>
called when Lua tries to assign to an index in a non table value.
It receives as arguments the non table value,
the index, and the assigned value.
The default handler issues an error.
<DT><B>``function'':</B><DD><A NAME="function fallback"></A>
called when Lua tries to call a non function value.
It receives as arguments the non function value and the
arguments given in the original call.
Its return values are the final results of the call operation.
The default handler issues an error.
<DT><B>``gc'':</B><DD>
called during garbage collection.
It receives as argument the table being collected.
After each run of the collector this function is called with argument <B>nil</B>,
to signal the completion of the garbage collection.
Because this function operates during garbage collection,
it must be used with great care,
and programmers should avoid the creation of new objects
(tables or strings) in this function.
The default handler does nothing.
<DT><B>``error'':</B><DD><A NAME="error fallback"></A>
called when an error occurs.
It receives as argument a string describing the error.
The default handler prints the message on the standard error output
(<CODE>stderr</CODE>).
</DL>
<P>
The function <A NAME="setfallback"><TT>setfallback</TT></A> is used to change a fallback handler.
Its first argument is the name of a fallback condition,
and the second argument is the new function to be called.
It returns the old handler function for the given fallback.
<P>
<P>
<A NAME="error"></A>
<A NAME="4.8"></A>
<H2>4.8 - Error Handling</H2> 
<P>
Because Lua is an extension language,
all Lua actions start from C code calling a function from the Lua library.
Whenever an error occurs during Lua compilation or execution,
the ``error'' fallback function is called,
and then the corresponding function from the library
(<CODE>lua_dofile</CODE>, <CODE>lua_dostring</CODE>,
<CODE>lua_call</CODE>, or <CODE>lua_callfunction</CODE>)
is terminated returning an error condition.
<P>
The only argument to the ``error'' fallback function is a string
describing the error.
The standard I/O library redefines this fallback,
using the debug facilities (see Section&nbsp;<A HREF="#debugI">7</A>),
in order to print some extra information,
like the call stack.
To provide more information about errors,
Lua programs can include the compilation pragma <CODE>$debug</CODE>.
<A NAME="pragma"></A>
<A NAME="debug pragma"></A>
This pragma must be written in a line by itself.
When an error occurs in a program compiled with this option,
the error routine is able to print the number of the lines where the calls
(and the error) were made.
If needed, it is possible to change the ``error'' fallback handler
(see Section&nbsp;<A HREF="#fallback">4.7</A>).
<P>
Lua code can explicitly generate an error by calling the built-in
function <CODE>error</CODE> (see Section&nbsp;<A HREF="#pdf-error">6.1</A>).
<P>
<P>
<!-- ====================================================================== -->
<HR>
<A NAME="5."></A>
<H1>5 - The Application Program Interface</H1>
<P>
This section describes the API for Lua, that is,
the set of C functions available to the host program to communicate
with the library.
The API functions can be classified in the following categories:
<OL>
<LI>exchanging values between C and Lua;
<LI>executing Lua code;
<LI>manipulating (reading and writing) Lua objects;
<LI>calling Lua functions;
<LI>C functions to be called by Lua;
<LI>manipulating references to Lua Objects.
</OL>
All API functions and related types and constants
are declared in the header file <CODE>lua.h</CODE>.
<P>
<A NAME="valuesCLua"></A>
<A NAME="5.1"></A>
<H2>5.1 - Exchanging Values between C and Lua</H2> 
Because Lua has no static type system,
all values passed between Lua and C have type
<CODE>lua_Object</CODE><A NAME="lua_Object"></A>,
which works like an abstract type in C that can hold any Lua value.
Values of type <CODE>lua_Object</CODE> have no meaning outside Lua;
for instance,
the comparisson of two <CODE>lua_Object's</CODE> is undefined.
<P>
To check the type of a <CODE>lua_Object</CODE>,
the following function is available:
<A NAME="lua_type"></A>
<LISTING>
int            lua_type                 (lua_Object object);
</LISTING>
plus the following functions:
<A NAME="lua_isnil"></A><A NAME="lua_isnumber"></A><A NAME="lua_isstring"></A>
<A NAME="lua_istable"></A><A NAME="lua_iscfunction"></A><A NAME="lua_isuserdata"></A>
<A NAME="lua_isfunction"></A>
<LISTING>
int            lua_isnil                (lua_Object object);
int            lua_isnumber             (lua_Object object);
int            lua_isstring             (lua_Object object);
int            lua_istable              (lua_Object object);
int            lua_isfunction           (lua_Object object);
int            lua_iscfunction          (lua_Object object);
int            lua_isuserdata           (lua_Object object);
</LISTING>
All macros return 1 if the object is compatible with the given type,
and 0 otherwise.
The function <CODE>lua_isnumber</CODE> accepts numbers and numerical strings,
whereas
<CODE>lua_isstring</CODE> accepts strings and numbers (see Section&nbsp;<A HREF="#coercion">4.2</A>),
and <CODE>lua_isfunction</CODE> accepts Lua and C functions.
The function <CODE>lua_type</CODE> can be used to distinguish between
different kinds of user data.
<P>
To translate a value from type <CODE>lua_Object</CODE> to a specific C type,
the programmer can use:
<A NAME="lua_getnumber"></A><A NAME="lua_getstring"></A>
<A NAME="lua_getcfunction"></A><A NAME="lua_getuserdata"></A>
<LISTING>
double         lua_getnumber            (lua_Object object);
char          *lua_getstring            (lua_Object object);
lua_CFunction  lua_getcfunction         (lua_Object object);
void          *lua_getuserdata          (lua_Object object);
</LISTING>
<CODE>lua_getnumber</CODE> converts a <CODE>lua_Object</CODE> to a floating-point number.
This <CODE>lua_Object</CODE> must be a number or a string convertible to number
(see Section&nbsp;<A HREF="#coercion">4.2</A>); otherwise, the function returns 0.
<P>
<CODE>lua_getstring</CODE> converts a <CODE>lua_Object</CODE> to a string (<CODE>char *</CODE>).
This <CODE>lua_Object</CODE> must be a string or a number;
otherwise, the function returns 0 (the <CODE>NULL</CODE> pointer).
This function does not create a new string, but returns a pointer to
a string inside the Lua environment.
Because Lua has garbage collection, there is no guarantee that such
pointer will be valid after the block ends.
<P>
<CODE>lua_getcfunction</CODE> converts a <CODE>lua_Object</CODE> to a C function.
This <CODE>lua_Object</CODE> must have type <EM>CFunction</EM>;
otherwise, the function returns 0 (the <CODE>NULL</CODE> pointer).
The type <CODE>lua_CFunction</CODE> is explained in Section&nbsp;<A HREF="#LuacallC">5.5</A>.
<P>
<CODE>lua_getuserdata</CODE> converts a <CODE>lua_Object</CODE> to <CODE>void*</CODE>.
This <CODE>lua_Object</CODE> must have type <EM>userdata</EM>;
otherwise, the function returns 0 (the <CODE>NULL</CODE> pointer).
<P>
Because Lua has automatic memory management and garbage collection,
a <CODE>lua_Object</CODE> has a limited scope,
and is only valid inside the <EM>block</EM> where it was created.
A C function called from Lua is a block,
and its parameters are valid only until its end.
It is good programming practice to convert Lua objects to C values
as soon as they are available,
and never to store <CODE>lua_Object</CODE>s in C global variables.
<P>
<P>
All comunication between Lua and C is done through two
abstract data types, called <A NAME="lua2C"><EM>lua2C</EM></A> and <A NAME="C2lua"><EM>C2lua</EM></A>.
The first one, as the name implies, is used to pass values
from Lua to C: parameters when Lua calls C and results when C calls Lua.
The structure C2lua is used in the reverse direction:
parameters when C calls Lua and results when Lua calls C.
Notice that the structure lua2C cannot be directly modified by C code,
while the structure C2lua cannot be ``read'' by C code.
<P>
The structure lua2C is an abstract array,
which can be indexed with the function:
<A NAME="lua_lua2C"></A>
<LISTING>
lua_Object lua_lua2C (int number);
</LISTING>
where <CODE>number</CODE> starts with 1.
When called with a number larger than the array size,
this function returns
<CODE>LUA_NOOBJECT</CODE><A NAME="LUA_NOOBJECT"></A>.
In this way, it is possible to write C functions that receive
a variable number of parameters,
and to call Lua functions that return a variable number of results.
<P>
The second structure, C2lua, is a stack.
Pushing elements into this stack
is done by using the following functions:
<A NAME="lua_pushnumber"></A><A NAME="lua_pushstring"></A>
<A NAME="lua_pushcfunction"></A><A NAME="lua_pushusertag"></A>
<A NAME="lua_pushnil"></A><A NAME="lua_pushobject"></A>
<A NAME="pushing"></A>
<A NAME="lua_pushuserdata"></A>
<LISTING>
void           lua_pushnumber           (double n);
void           lua_pushstring           (char *s);
void           lua_pushcfunction        (lua_CFunction f);
void           lua_pushusertag          (void *u, int tag);
void           lua_pushnil              (void);
void           lua_pushobject           (lua_Object object);
</LISTING>
plus the macro:
<LISTING>
void           lua_pushuserdata         (void *u);
</LISTING>
All of them receive a C value,
convert it to a corresponding <CODE>lua_Object</CODE>,
and leave the result on the top of C2lua.
<P>
User data can have different tags,
whose semantics are only known to the host program.
Any positive integer can be used to tag a user datum.
When a user datum is retrieved,
the function <CODE>lua_type</CODE> can be used to get its tag.
<P>
<EM>Please note:</EM> most functions in the Lua API
use the structures lua2C and C2lua,
and therefore change their contents.
Great care must be taken,
specially when pushing a sequence of objects into C2lua,
to avoid using those functions.
The family of functions <CODE>lua_get*</CODE>, <CODE>lua_is*</CODE>,
plus the function <CODE>lua_lua2C</CODE>,
are safe to be called without modifying these structures;
the family <CODE>lua_push*</CODE> does not modify lua2C.
All other functions may change lua2C and C2lua,
unless noticed otherwise.
<P>
When C code calls Lua repeatedly, as in a loop,
objects returned by these calls accumulate,
and may create a memory problem.
To avoid this,
nested blocks can be defined with the functions:
<LISTING>
void           lua_beginblock           (void);
void           lua_endblock             (void);
</LISTING>
After the end of the block,
all <CODE>lua_Object</CODE>'s created inside it are released.
The use of explicit nested blocks is strongly encouraged.
<P>
<A NAME="5.2"></A>
<H2>5.2 - Executing Lua Code</H2>
A host program can execute Lua chunks written in a file or in a string
using the following functions:
<A NAME="lua_dofile"></A><A NAME="lua_dostring"></A>
<LISTING>
int lua_dofile   (char *filename);
int lua_dostring (char *string);
</LISTING>
Both functions return an error code:
0, in case of success; non zero, in case of errors.
More specifically, <CODE>lua_dofile</CODE> returns 2 if for any reason
it could not open the file.
The function <CODE>lua_dofile</CODE>, if called with argument <CODE>NULL</CODE>,
executes the <CODE>stdin</CODE> stream.
Function <CODE>lua_dofile</CODE> is also able to execute pre-compiled chunks.
It automatically detects whether the file is text or binary,
and loads it accordingly (see program <A NAME="luac"><TT>luac</TT></A>).
These functions also return, in structure lua2C,
any values eventually returned by the chunks.
<P>
<P>
<A NAME="5.3"></A>
<H2>5.3 - Manipulating Lua Objects</H2>
To read the value of any global Lua variable,
one uses the function:
<A NAME="lua_getglobal"></A>
<LISTING>
lua_Object     lua_getglobal            (char *varname);
</LISTING>
As in Lua, if the value of the global is <B>nil</B>,
then the ``getglobal'' fallback is called.
<P>
To store a value previously pushed onto C2lua in a global variable,
there is the function:
<A NAME="lua_storeglobal"></A>
<LISTING>
void           lua_storeglobal          (char *varname);
</LISTING>
<P>
Tables can also be manipulated via the API.
The function
<A NAME="lua_getsubscript"></A>
<LISTING>
lua_Object     lua_getsubscript         (void);
</LISTING>
expects on the stack C2lua a table and an index,
and returns the contents of the table at that index.
As in Lua, if the first object is not a table,
or the index is not present in the table,
the corresponding fallback is called.
<P>
To store a value in an index,
the program must push the table, the index,
and the value onto C2lua,
and then call the function:
<A NAME="lua_storesubscript"></A>
<LISTING>
void lua_storesubscript (void);
</LISTING>
Again, the ``settable'' fallback is called if a non-table value is used.
<P>
Finally, the function
<A NAME="lua_createtable"></A>
<LISTING>
lua_Object     lua_createtable          (void);
</LISTING>
creates and returns a new, empty table.
<P>
As already noted,
most functions from the Lua library receive parameters through C2lua.
Because other functions also use this stack,
it is important that these
parameters be pushed just before the corresponding call,
without intermediate calls to the Lua library.
For instance, suppose the user wants the value of <CODE>a[i]</CODE>,
where <CODE>a</CODE> and <CODE>i</CODE> are global Lua variables.
A simplistic solution would be:
<LISTING>
  /* Warning: WRONG CODE */
  lua_Object result;
  lua_pushobject(lua_getglobal("a"));  /* push table */
  lua_pushobject(lua_getglobal("i"));  /* push index */
  result = lua_getsubscript();
</LISTING>
This code is incorrect because
the call <CODE>lua_getglobal("i")</CODE> modifies the stack,
and invalidates the previous pushed value.
A correct solution could be:
<LISTING>
  lua_Object result;
  lua_Object index = lua_getglobal("i");
  lua_pushobject(lua_getglobal("a"));  /* push table */
  lua_pushobject(index);               /* push index */
  result = lua_getsubscript();
</LISTING>
<P>
<A NAME="5.4"></A>
<H2>5.4 - Calling Lua Functions</H2>
Functions defined in Lua by a chunk executed with
<CODE>dofile</CODE> or <CODE>dostring</CODE> can be called from the host program.
This is done using the following protocol:
first, the arguments to the function are pushed onto C2lua
(see Section&nbsp;<A HREF="#pushing">5.1</A>), in direct order, i.e., the first argument is pushed first.
Again, it is important to emphasize that, during this phase,
most other Lua functions cannot be called.
<P>
Then, the function is called using
<A NAME="lua_call"></A><A NAME="lua_callfunction"></A>
<LISTING>
int            lua_call                 (char *functionname);
</LISTING>
or
<LISTING>
int            lua_callfunction         (lua_Object function);
</LISTING>
Both functions return an error code:
0, in case of success; non zero, in case of errors.
Finally, the results (a Lua function may return many values)
are returned in structure lua2C,
and can be retrieved with the macro <CODE>lua_getresult</CODE>,
<A NAME="lua_getresult"></A>
which is just another name to the function <CODE>lua_lua2C</CODE>.
<P>
The following example shows how a C program may call the
<CODE>strsub</CODE> function in Lua to extract a piece of a string:
<LISTING>
  /* assume that 's' and 'r' are strings (char *), 'i' and 'j' integers */
  lua_pushstring(s);  /* 1st argument */
  lua_pushnumber(i);  /* 2nd argument */
  lua_pushnumber(j);  /* 3rd argument */
  lua_call("strsub");  /* call Lua function */
  r = lua_getstring(lua_getresult(1));  /* r = strsub(s, i, j) */
</LISTING>
<P>
Two special Lua functions have exclusive interfaces:
<CODE>error</CODE> and <CODE>setfallback</CODE>.
A C function can generate a Lua error calling the function
<A NAME="lua_error"></A>
<LISTING>
void lua_error (char *message);
</LISTING>
This function never returns.
If the C function has been called from Lua,
then the corresponding Lua execution terminates,
as if an error had occurred inside Lua code.
Otherwise, the whole program terminates with a call to <CODE>exit(1)</CODE>.
<P>
Fallbacks can be changed with:
<A NAME="lua_setfallback"></A>
<LISTING>
lua_Object lua_setfallback (char *name, lua_CFunction fallback);
</LISTING>
The first parameter is the fallback name (see Section&nbsp;<A HREF="#fallback">4.7</A>),
and the second is a CFunction to be used as the new fallback.
This function returns a <CODE>lua_Object</CODE>,
which is the old fallback value,
or <B>nil</B> on failure (invalid fallback name).
This old value can be used for chaining fallbacks.
<P>
<P>
<A NAME="LuacallC"></A>
<A NAME="5.5"></A>
<H2>5.5 - C Functions</H2> 
To register a C function to Lua,
there is the following macro:
<A NAME="lua_register"></A>
<LISTING>
#define lua_register(n,f)       (lua_pushcfunction(f), lua_storeglobal(n))
/* char *n;         */
/* lua_CFunction f; */
</LISTING>
which receives the name the function will have in Lua,
and a pointer to the function.
This pointer must have type <CODE>lua_CFunction</CODE>,
which is defined as
<A NAME="lua_CFunction"></A>
<LISTING>
typedef void (*lua_CFunction) (void);
</LISTING>
that is, a pointer to a function with no parameters and no results.
<P>
In order to communicate properly with Lua,
a C function must follow a protocol,
which defines the way parameters and results are passed.
<P>
A C function receives its arguments in structure lua2C;
to access them, it uses the macro <CODE>lua_getparam</CODE>, <A NAME="lua_getparam"></A>
again just another name to <CODE>lua_lua2C</CODE>.
To return values, a C function just pushes them onto the stack C2lua,
in direct order (see Section&nbsp;<A HREF="#valuesCLua">5.1</A>).
Like a Lua function, a C function called by Lua can also return
many results.
<P>
As an example,
the code below shows a CFunction to compute the maximum of
a variable number of arguments:
<LISTING>
void math_max (void)
{
  int i=1;   /* argument count */
  double d, dmax;
  lua_Object o;
  /* the function must get at least one argument */
  if ((o = lua_getparam(i++)) == LUA_NOOBJECT)
    lua_error("too few arguments to function `max'");
  /* and this argument must be a number */
  if (!lua_isnumber(o))
    lua_error("incorrect argument to function `max'");
  dmax = lua_getnumber(o);
  /* loops until there is no more arguments */
  while ((o = lua_getparam(i++)) != LUA_NOOBJECT) {
    if (!lua_isnumber(o))
      lua_error("incorrect argument to function `max'");
    d = lua_getnumber(o);
    if (d &gt; dmax) dmax = d;
  }
  /* push the result to be returned */
  lua_pushnumber(dmax);
}
</LISTING>
To be available in Lua, this function must be registered:
<LISTING>
lua_register ("max", math_max);
</LISTING>
<P>
For more examples, see files <CODE>strlib.c</CODE>,
<CODE>iolib.c</CODE> and <CODE>mathlib.c</CODE> in Lua distribution.
<P>
<A NAME="5.6"></A>
<H2>5.6 - References to Lua Objects</H2>
<P>
As noted in Section&nbsp;<A HREF="#LuacallC">5.5</A>, <CODE>lua_Object</CODE>s are volatile.
If the C code needs to keep a <CODE>lua_Object</CODE>
outside block boundaries,
it must create a <A NAME="reference"><EM>reference</EM></A> to the object.
The routines to manipulate references are the following:
<A NAME="lua_ref"></A><A NAME="lua_getref"></A>
<A NAME="lua_pushref"></A><A NAME="lua_unref"></A>
<LISTING>
int            lua_ref (int lock);
lua_Object     lua_getref  (int ref);
void           lua_pushref (int ref);
void           lua_unref (int ref);
</LISTING>
The function <CODE>lua_ref</CODE> creates a reference
to the object that is on the top of the stack,
and returns this reference.
If <CODE>lock</CODE> is true, the object is <EM>locked</EM>:
this means the object will not be garbage collected.
Notice that an unlocked reference may be garbage collected.
Whenever the referenced object is needed,
a call to <CODE>lua_getref</CODE>
returns a handle to it,
whereas <CODE>lua_pushref</CODE> pushes the object on the stack.
If the object has been collected,
then <CODE>lua_getref</CODE> returns <CODE>LUA_NOOBJECT</CODE>,
and <CODE>lua_pushobject</CODE> issues an error.
<P>
When a reference is no longer needed,
it can be freed with a call to <CODE>lua_unref</CODE>.
<P>
The function <CODE>lua_pushref</CODE> does not corrupt the
structures lua2C and C2lua, and therefore is safe to
be called when pushing parameters onto C2lua.
<P>
<P>
<P>
<!-- ====================================================================== -->
<HR>
<A NAME="6."></A>
<H1>6 - Predefined Functions and Libraries</H1>
<P>
The set of <A NAME="predefined functions">predefined functions</A> in Lua is small but powerful.
Most of them provide features that allow some degree of
<A NAME="reflexivity">reflexivity</A> in the language.
Some of these features cannot be simulated with the rest of the
Language nor with the standard Lua API.
Others are just convenient interfaces to common API functions.
<P>
The libraries, on the other hand, provide useful routines
that are implemented directly through the standard API.
Therefore, they are not necessary to the language,
and are provided as separate C modules.
Currently there are three standard libraries:
<UL>
<LI>string manipulation;
<LI>mathematical functions (sin, log, etc);
<LI>input and output (plus some system facilities).
</UL>
In order to have access to these libraries,
the host program must call the functions
<CODE>strlib_open</CODE>, <CODE>mathlib_open</CODE>, and <CODE>iolib_open</CODE>,
declared in <CODE>lualib.h</CODE>.
<P>
<P>
<A NAME="6.1"></A>
<H2>6.1 - Predefined Functions</H2>
<P>
<h3><TT>dofile (filename)</TT></h3><A NAME="dofile"></A>
This function receives a file name,
opens it, and executes its contents as a Lua chunk,
or as pre-compiled chunks.
When called without arguments,
it executes the contents of the standard input (<CODE>stdin</CODE>).
If there is any error executing the file, it returns <B>nil</B>.
Otherwise, it returns the values returned by the chunk,
or a non <B>nil</B> value if the chunk returns no values.
It issues an error when called with a non string argument.
<CODE>dofile</CODE> is simply an interface to <CODE>lua_dofile</CODE>.
<P>
<h3><TT>dostring (string)</TT></h3><A NAME="dostring"></A>
This function executes a given string as a Lua chunk.
If there is any error executing the string, it returns <B>nil</B>.
Otherwise, it returns the values returned by the chunk,
or a non <B>nil</B> value if the chunk returns no values.
<CODE>dostring</CODE> is simply an interface to <CODE>lua_dostring</CODE>.
<P>
<h3><TT>next (table, index)</TT></h3><A NAME="next"></A>
This function allows a program to traverse all fields of a table.
Its first argument is a table and its second argument
is an index in this table.
It returns the next index of the table and the
value associated with the index.
When called with <B>nil</B> as its second argument,
the function returns the first index
of the table (and its associated value).
When called with the last index, or with <B>nil</B> in an empty table,
it returns <B>nil</B>.
<P>
In Lua there is no declaration of fields;
semantically, there is no difference between a
field not present in a table or a field with value <B>nil</B>.
Therefore, the function only considers fields with non <B>nil</B> values.
The order in which the indices are enumerated is not specified,
<EM>even for numeric indices</EM>.
If the table is modified in any way during a traversal,
the semantics of <CODE>next</CODE> is undefined.
<P>
This function cannot be written with the standard API.
<P>
<h3><TT>nextvar (name)</TT></h3><A NAME="nextvar"></A>
This function is similar to the function <CODE>next</CODE>,
but iterates over the global variables.
Its single argument is the name of a global variable,
or <B>nil</B> to get a first name.
Similarly to <CODE>next</CODE>, it returns the name of another variable
and its value,
or <B>nil</B> if there are no more variables.
There can be no assignments to global variables during the traversal;
otherwise the semantics of <CODE>nextvar</CODE> is undefined.
<P>
This function cannot be written with the standard API.
<P>
<h3><TT>tostring (e)</TT></h3><A NAME="tostring"></A>
This function receives an argument of any type and
converts it to a string in a reasonable format.
<P>
<h3><TT>print (e1, e2, ...)</TT></h3><A NAME="print"></A>
This function receives any number of arguments,
and prints their values in a reasonable format.
Each value is printed in a new line.
This function is not intended for formatted output,
but as a quick way to show a value,
for instance for error messages or debugging.
See Section&nbsp;<A HREF="#libio">6.4</A> for functions for formatted output.
<P>
<h3><TT>tonumber (e)</TT></h3><A NAME="tonumber"></A>
This function receives one argument,
and tries to convert it to a number.
If the argument is already a number or a string convertible
to a number (see Section&nbsp;<A HREF="#coercion">4.2</A>), then it returns that number;
otherwise, it returns <B>nil</B>.
<P>
<h3><TT>type (v)</TT></h3><A NAME="type"></A>
This function allows Lua to test the type of a value.
It receives one argument, and returns its type, coded as a string.
The possible results of this function are
<CODE>"nil"</CODE> (a string, not the value <B>nil</B>),
<CODE>"number"</CODE>,
<CODE>"string"</CODE>,
<CODE>"table"</CODE>,
<CODE>"function"</CODE> (returned both for C functions and Lua functions),
and <CODE>"userdata"</CODE>.
<P>
Besides this string, the function returns a second result,
which is the <A NAME="tag"><EM>tag</EM></A> of the value.
This tag can be used to distinguish between user
data with different tags,
and between C functions and Lua functions.
<P>
<CODE>type</CODE> is simply an interface to <CODE>lua_type</CODE>.
<P>
<h3><TT>assert (v)</TT></h3><A NAME="assert"></A>
This function issues an <EM>``assertion failed!''</EM> error
when its argument is <B>nil</B>.
<P>
<A NAME="pdf-error"></A>
<h3><TT>error (message)</TT></h3><A NAME="error"></A>
This function issues an error message and terminates
the last called function from the library
(<CODE>lua_dofile</CODE>, <CODE>lua_dostring</CODE>, ...).
It never returns.
<CODE>error</CODE> is simply an interface to <CODE>lua_error</CODE>.
<P>
<h3><TT>setglobal (name, value)</TT></h3><A NAME="setglobal"></A>
This function assigns the given value to a global variable.
The string <CODE>name</CODE> does not need to be a syntactically valid variable name.
Therefore, this function can set global variables with strange names like
<CODE>`m v 1'</CODE> or <CODE>34</CODE>.
It returns the value of its second argument.
<CODE>setglobal</CODE> is simply an interface to <CODE>lua_storeglobal</CODE>.
<P>
<h3><TT>getglobal (name)</TT></h3><A NAME="getglobal"></A>
This function retrieves the value of a global variable.
The string <CODE>name</CODE> does not need to be a syntactically valid variable name.
<P>
<h3><TT>setfallback (fallbackname, newfallback)</TT></h3>
<A NAME="setfallback"></A>
This function sets a new fallback function to the given fallback.
It returns the old fallback function.
<CODE>setfallback</CODE> is simply an interface to <CODE>lua_setfallback</CODE>.
<P>
<A NAME="6.2"></A>
<H2>6.2 - String Manipulation</H2>
This library provides generic functions for string manipulation,
such as finding and extracting substrings and pattern matching.
When indexing a string, the first character is at position 1,
not 0, as in C.
<P>
<h3><TT>strfind (str, pattern [, init [, plain]])</TT></h3>
<A NAME="strfind"></A>
This function looks for the first <EM>match</EM> of
<CODE>pattern</CODE> in <CODE>str</CODE>.
If it finds one, then it returns the indices on <CODE>str</CODE>
where this occurence starts and ends;
otherwise, it returns <B>nil</B>.
If the pattern specifies captures,
the captured strings are returned as extra results.
A third optional numerical argument specifies where to start the search;
its default value is 1.
A value of 1 as a forth optional argument
turns off the pattern matching facilities,
so the function does a plain ``find substring'' operation.
<P>
<h3><TT>strlen (s)</TT></h3><A NAME="strlen"></A>
Receives a string and returns its length.
<P>
<h3><TT>strsub (s, i [, j])</TT></h3><A NAME="strsub"></A>
Returns another string, which is a substring of <CODE>s</CODE>,
starting at <CODE>i</CODE>  and runing until <CODE>j</CODE>.
If <CODE>j</CODE> is absent,
it is assumed to be equal to the length of <CODE>s</CODE>.
In particular, the call <CODE>strsub(s,1,j)</CODE> returns a prefix of <CODE>s</CODE>
with length <CODE>j</CODE>,
whereas the call <CODE>strsub(s,i)</CODE> returns a suffix of <CODE>s</CODE>,
starting at <CODE>i</CODE>.
<P>
<h3><TT>strlower (s)</TT></h3><A NAME="strlower"></A>
Receives a string and returns a copy of that string with all
upper case letters changed to lower case.
All other characters are left unchanged.
<P>
<h3><TT>strupper (s)</TT></h3><A NAME="strupper"></A>
Receives a string and returns a copy of that string with all
lower case letters changed to upper case.
All other characters are left unchanged.
<P>
<h3><TT>strrep (s, n)</TT></h3><A NAME="strrep"></A>
Returns a string which is the concatenation of <CODE>n</CODE> copies of
the string <CODE>s</CODE>.
<P>
<h3><TT>ascii (s [, i])</TT></h3><A NAME="ascii"></A>
Returns the ASCII code of the character <CODE>s[i]</CODE>.
If <CODE>i</CODE> is absent, then it is assumed to be 1.
<P>
<h3><TT>format (formatstring, e1, e2, ...)</TT></h3><A NAME="format"></A>
<A NAME="format"></A>

This function returns a formated version of its variable number of arguments
following the description given in its first argument (which must be a string).
The format string follows the same rules as the <CODE>printf</CODE> family of
standard C functions.
The only differences are that the options/modifiers
<CODE>*</CODE>, <CODE>l</CODE>, <CODE>L</CODE>, <CODE>n</CODE>, <CODE>p</CODE>,
and <CODE>h</CODE> are not supported,
and there is an extra option, <CODE>q</CODE>.
This option formats a string in a form suitable to be safely read
back by the Lua interpreter;
that is,
the string is written between double quotes,
and all double quotes, returns and backslashes in the string
are correctly escaped when written.
For instance, the call
<LISTING>
format('%q', 'a string with "quotes" and \n new line')
</LISTING>
will produce the string:
<LISTING>
"a string with \"quotes\" and \
 new line"
</LISTING>
<P>
The options <CODE>c</CODE>, <CODE>d</CODE>, <CODE>E</CODE>, <CODE>e</CODE>, <CODE>f</CODE>,
<CODE>g</CODE> <CODE>i</CODE>, <CODE>o</CODE>, <CODE>u</CODE>, <CODE>X</CODE>, and <CODE>x</CODE> all
expect a number as argument,
whereas <CODE>q</CODE> and <CODE>s</CODE> expect a string.
Note that the <CODE>*</CODE> modifier can be simulated by building
the appropriate format string.
For example, <CODE>"%*g"</CODE> can be simulated with
<CODE>"%"..width.."g"</CODE>.
<P>
<h3><TT>gsub (s, pat, repl [, n])</TT></h3><A NAME="gsub"></A>
Returns a copy of <CODE>s</CODE>,
where all occurrences of the pattern <CODE>pat</CODE> have been
replaced by a replacement string specified by <CODE>repl</CODE>.
This function also returns, as a second value,
the total number of substitutions made.
<P>
If <CODE>repl</CODE> is a string, then its value is used for replacement.
Any sequence in <CODE>repl</CODE> of the form <CODE>%n</CODE>
with <CODE>n</CODE> between 1 and 9
stands for the value of the n-th captured substring.
<P>
If <CODE>repl</CODE> is a function, then this function is called every time a
match occurs, with all captured substrings as parameters
(see below).
If the value returned by this function is a string,
then it is used as the replacement string;
otherwise, the replacement string is the empty string.
<P>
An optional parameter <CODE>n</CODE> limits
the maximum number of substitutions to occur.
For instance, when <CODE>n</CODE> is 1 only the first occurrence of
<CODE>pat</CODE> is replaced.
<P>
As an example, in the following expression each occurrence of the form
<CODE>$name</CODE> calls the function <CODE>getenv</CODE>,
passing <CODE>name</CODE> as argument
(because only this part of the pattern is captured).
The value returned by <CODE>getenv</CODE> will replace the pattern.
Therefore, the whole expression:
<LISTING>
  gsub("home = $HOME, user = $USER", "$(%w%w*)", getenv)
</LISTING>
returns a string like:
<LISTING>
home = /home/roberto, user = roberto
</LISTING>
<P>
<A NAME="pm"></A>
<h3>Patterns</h3> 
<P>
<H4>Character Class:</H4>
a <A NAME="character class"><EM>character class</EM></A> is used to represent a set of characters.
The following combinations are allowed in describing a character class:
<DL>
<DT><B><EM>x</EM></B><DD> (where <EM>x</EM> is any character not in the list <CODE>()%.[*?</CODE>)
- represents the character <EM>x</EM> itself.
<DT><B><TT>.</TT></B><DD> - represents all characters.
<DT><B><TT>%a</TT></B><DD> - represents all letters.
<DT><B><TT>%A</TT></B><DD> - represents all non letter characters.
<DT><B><TT>%d</TT></B><DD> - represents all digits.
<DT><B><TT>%D</TT></B><DD> - represents all non digits.
<DT><B><TT>%l</TT></B><DD> - represents all lower case letters.
<DT><B><TT>%L</TT></B><DD> - represents all non lower case letter characters.
<DT><B><TT>%s</TT></B><DD> - represents all space characters.
<DT><B><TT>%S</TT></B><DD> - represents all non space characters.
<DT><B><TT>%u</TT></B><DD> - represents all upper case letters.
<DT><B><TT>%U</TT></B><DD> - represents all non upper case letter characters.
<DT><B><TT>%w</TT></B><DD> - represents all alphanumeric characters.
<DT><B><TT>%W</TT></B><DD> - represents all non alphanumeric characters.
<DT><B><TT>%<EM>x</EM></TT></B><DD> (where <EM>x</EM> is any non alphanumeric character)  -
represents the character <EM>x</EM>.
This is the standard way to escape the magic characters <CODE>()%.[*?</CODE>.
<DT><B><TT>[char-set]</TT></B><DD> -
Represents the class which is the union of all
characters in char-set.
To include a <CODE>]</CODE> in char-set, it must be the first character.
A range of characters may be specified by
separating the end characters of the range with a <CODE>-</CODE>;
e.g., <CODE>A-Z</CODE> specifies the upper case characters.
If <CODE>-</CODE> appears as the first or last character of char-set,
then it represents itself.
All classes <CODE>%</CODE><EM>x</EM> described above can also be used as
components in a char-set.
All other characters in char-set represent themselves.
<DT><B><TT>[^char-set]</TT></B><DD> -
represents the complement of char-set,
where char-set is interpreted as above.
</DL>
<P>
<H4>Pattern Item:</H4>
a <A NAME="pattern item"><EM>pattern item</EM></A> may be:
<UL>
<LI>
a single character class,
which matches any single character in the class;
<LI>
a single character class followed by <CODE>*</CODE>,
which matches 0 or more repetitions of characters in the class.
These repetition itens will always match the longest possible sequence.
<LI>
a single character class followed by <CODE>-</CODE>,
which also matches 0 or more repetitions of characters in the class.
Unlike <CODE>*</CODE>,
these repetition itens will always match the shortest possible sequence.
<LI>
a single character class followed by <CODE>?</CODE>,
which matches 0 or 1 occurrence of a character in the class;
<LI>
<TT>%<I>n</TT></I>, for <I>n</I> between 1 and 9;
such item matches a sub-string equal to the n-th captured string
(see below);
<LI>
<TT>%b<I>xy</TT></I>, where <I>x</I> and <I>y</I> are two distinct characters;
such item mathes strings that start with <I>x</I>, end with <I>y</I>,
and where the <I>x</I> and <I>y</I> are <EM>balanced</EM>.
That means that, if one reads the string from left to write,
counting plus 1 for an <I>x</I> and minus 1 for a <I>y</I>,
the ending <I>y</I> is the first where the count reaches 0.
For instance, the item <CODE>%()</CODE> matches expressions with
balanced parentheses.
</UL>
<P>
<H4>Pattern:</H4>
a <A NAME="pattern"><EM>pattern</EM></A> is a sequence of pattern items.
A <CODE>^</CODE> at the beginning of a pattern anchors the match at the
beginning of the subject string.
A <CODE>$</CODE> at the end of a pattern anchors the match at the
end of the subject string.
<P>
<H4>Captures:</H4>
a pattern may contain sub-patterns enclosed in parentheses,
that describe <A NAME="captures"><EM>captures</EM></A>.
When a match succeeds, the sub-strings of the subject string
that match captures are stored (<EM>captured</EM>) for future use.
Captures are numbered according to their left parentheses.
For instance, in the pattern <CODE>"(a*(.)%w(%s*))"</CODE>,
the part of the string matching <CODE>"a*(.)%w(%s*)"</CODE> is
stored as the first capture (and therefore has number 1);
the character matching <CODE>.</CODE> is captured with number 2,
and the part matching <CODE>%s*</CODE> has number 3.
<P>
<A NAME="mathlib"></A>
<A NAME="6.3"></A>
<H2>6.3 - Mathematical Functions</H2> 
<P>
This library is an interface to some functions of the standard C math library.
In addition, it registers a fallback for the binary operator <CODE>^</CODE> that,
returns <I>x^y</I> when applied to numbers <CODE>x^y</CODE>.
<P>
The library provides the following functions:
<A NAME="abs"></A><A NAME="acos"></A><A NAME="asin"></A><A NAME="atan"></A>
<A NAME="atan2"></A><A NAME="ceil"></A><A NAME="cos"></A><A NAME="floor"></A>
<A NAME="log"></A><A NAME="log10"></A><A NAME="max"></A><A NAME="min"></A>
<A NAME="mod"></A><A NAME="sin"></A><A NAME="sqrt"></A><A NAME="tan"></A>
<A NAME="random"></A><A NAME="randomseed"></A>
<LISTING>
abs acos asin atan atan2 ceil cos floor log log10
max min  mod  sin  sqrt  tan  random randomseed
</LISTING>
Most of them
are only interfaces to the homonymous functions in the C library,
except that, for the trigonometric functions,
all angles are expressed in <EM>degrees</EM>, not radians.
<P>
The function <CODE>max</CODE> returns the maximum
value of its numeric arguments.
Similarly, <CODE>min</CODE> computes the minimum.
Both can be used with an unlimited number of arguments.
<P>
The functions <CODE>random</CODE> and <CODE>randomseed</CODE> are interfaces to
the simple random generator functions <CODE>rand</CODE> and <CODE>srand</CODE>,
provided by ANSI C.
The function <CODE>random</CODE> returns pseudo-random numbers in the
range <I>[0,1)</I>.
<P>
<P>
<A NAME="libio"></A>
<A NAME="6.4"></A>
<H2>6.4 - I/O Facilities</H2> 
<P>
All input and outpu operations in Lua are done over two <EM>current</EM> files:
one for reading and one for writing.
Initially, the current input file is <CODE>stdin</CODE>,
and the current output file is <CODE>stdout</CODE>.
<P>
Unless otherwise stated,
all I/O functions return <B>nil</B> on failure and
some value different from <B>nil</B> on success.
<P>
<h3><TT>readfrom (filename)</TT></h3><A NAME="readfrom"></A>
<P>
This function may be called in three ways.
When called with a file name,
it opens the named file,
sets it as the <EM>current</EM> input file,
and returns a <EM>handle</EM> to the file
(this handle is a user data containing the file stream <CODE>FILE*</CODE>).
It does not close the current input file.
When called with a file handle, returned by a previous call,
it restores the file as the current input.
When called without parameters,
it closes the current input file,
and restores <CODE>stdin</CODE> as the current input file.
<P>
If this function fails, it returns <B>nil</B>,
plus a string describing the error.
<P>
<CITE>
<EM>System dependent</EM>: if <CODE>filename</CODE> starts with a <CODE>|</CODE>,
then a <A NAME="piped input">piped input</A> is open, via function <A NAME="popen"><TT>popen</TT></A>.
Not all systems implement pipes.
Moreover,
the number of files that can be open at the same time is usually limited and
depends on the system.
</CITE>
<P>
<h3><TT>writeto (filename)</TT></h3><A NAME="writeto"></A>
<P>
This function may be called in three ways.
When called with a file name,
it opens the named file,
sets it as the <EM>current</EM> output file,
and returns a <EM>handle</EM> to the file
(this handle is a user data containing the file stream <CODE>FILE*</CODE>).
It does not close the current output file.
Notice that, if the file already exists,
it will be <EM>completely erased</EM> with this operation.
When called with a file handle, returned by a previous call,
it restores the file as the current output.
When called without parameters,
this function closes the current output file,
and restores <CODE>stdout</CODE> as the current output file.
<A NAME="closing a file"></A>
<P>
If this function fails, it returns <B>nil</B>,
plus a string describing the error.
<P>
<CITE>
<EM>System dependent</EM>: if <CODE>filename</CODE> starts with a <CODE>|</CODE>,
then a <A NAME="piped output">piped output</A> is open, via function <A NAME="popen"><TT>popen</TT></A>.
Not all systems implement pipes.
Moreover,
the number of files that can be open at the same time is usually limited and
depends on the system.
</CITE>
<P>
<h3><TT>appendto (filename)</TT></h3><A NAME="appendto"></A>
<P>
This function opens a file named <CODE>filename</CODE> and sets it as the
<EM>current</EM> output file.
It returns the file handle,
or <B>nil</B> in case of error.
Unlike the <CODE>writeto</CODE> operation,
this function does not erase any previous content of the file.
If this function fails, it returns <B>nil</B>,
plus a string describing the error.
<P>
Notice that function <CODE>writeto</CODE> is available to close an output file.
<P>
<h3><TT>remove (filename)</TT></h3><A NAME="remove"></A>
<P>
This function deletes the file with the given name.
If this function fails, it returns <B>nil</B>,
plus a string describing the error.
<P>
<h3><TT>rename (name1, name2)</TT></h3><A NAME="rename"></A>
<P>
This function renames file named <CODE>name1</CODE> to <CODE>name2</CODE>.
If this function fails, it returns <B>nil</B>,
plus a string describing the error.
<P>
<h3><TT>tmpname ()</TT></h3><A NAME="tmpname"></A>
<P>
This function returns a string with a file name that can safely
be used for a temporary file.
<P>
<h3><TT>read ([readpattern])</TT></h3><A NAME="read"></A>
<P>
This function reads the current input
according to a read pattern, that specifies how much to read;
characters are read from the current input file until
the read pattern fails or ends.
The function <CODE>read</CODE> returns a string with the characters read,
even if the pattern succeeds only partially,
or <B>nil</B> if the read pattern fails <EM>and</EM>
the result string would be empty.
When called without parameters,
it uses a default pattern that reads the next line
(see below).
<P>
A <A NAME="read pattern"><EM>read pattern</EM></A> is a sequence of read pattern items.
An item may be a single character class
or a character class followed by <CODE>?</CODE> or by <CODE>*</CODE>.
A single character class reads the next character from the input
if it belongs to the class, otherwise it fails.
A character class followed by <CODE>?</CODE> reads the next character
from the input if it belongs to the class;
it never fails.
A character class followed by <CODE>*</CODE> reads until a character that
does not belong to the class, or end of file;
since it can match a sequence of zero characteres, it never fails.
<P>
A pattern item may contain sub-patterns enclosed in curly brackets,
that describe <A NAME="skips"><EM>skips</EM></A>.
Characters matching a skip are read,
but are not included in the resulting string.
<P>
Following are some examples of read patterns and their meanings:
<UL>
<LI><CODE>"."</CODE> returns the next character, or <B>nil</B> on end of file.
<LI><CODE>".*"</CODE> reads the whole file.
<LI><CODE>"[^\n]*{\n}"</CODE> returns the next line
(skipping the end of line), or <B>nil</B> on end of file.
This is the default pattern.
<LI><CODE>"{%s*}%S%S*"</CODE> returns the next word
(maximal sequence of non white-space characters),
or <B>nil</B> on end of file.
<LI><CODE>"{%s*}[+-]?%d%d*"</CODE> returns the next integer
or <B>nil</B> if the next characters do not conform to an integer format.
</UL>
<P>
<h3><TT>write (value1, ...)</TT></h3><A NAME="write"></A>
<P>
This function writes the value of each of its arguments to the
current output file.
The arguments must be strings or numbers.
To write other values,
use <CODE>tostring</CODE> before <CODE>write</CODE>.
If this function fails, it returns <B>nil</B>,
plus a string describing the error.
<P>
<h3><TT>date ([format])</TT></h3><A NAME="date"></A>
<P>
This function returns a string containing date and time
formatted according to the given string <CODE>format</CODE>,
following the same rules of the ANSI C function <CODE>strftime</CODE>.
When called without arguments,
it returns a reasonable date and time representation that depends on
the host system.
<P>
<h3><TT>exit ([code])</TT></h3><A NAME="exit"></A>
<P>
This function calls the C function <CODE>exit</CODE>,
with an optional <CODE>code</CODE>,
to terminate the program.
The default value for <CODE>code</CODE> is 1.
<P>
<h3><TT>getenv (varname)</TT></h3><A NAME="getenv"></A>
<P>
Returns the value of the environment variable <CODE>varname</CODE>,
or <B>nil</B> if the variable is not defined.
<P>
<h3><TT>execute (command)</TT></h3><A NAME="execute"></A>
<P>
This function is equivalent to the C function <CODE>system</CODE>.
It passes <CODE>command</CODE> to be executed by an operating system shell.
It returns an error code, which is system-dependent.
<P>
<P>
<A NAME="debugI"></A>
<!-- ====================================================================== -->
<HR>
<A NAME="7."></A>
<H1>7 - The Debugger Interface</H1> 
<P>
Lua has no built-in debugging facilities.
Instead, it offers a special interface,
by means of functions and <EM>hooks</EM>,
which allows the construction of different
kinds of debuggers, profilers, and other tools
that need ``inside information'' from the interpreter.
This interface is declared in the header file <CODE>luadebug.h</CODE>.
<P>
<A NAME="7.1"></A>
<H2>7.1 - Stack and Function Information</H2>
<P>
The main function to get information about the interpreter stack
is
<LISTING>
lua_Function lua_stackedfunction (int level);
</LISTING>
It returns a handle (<CODE>lua_Function</CODE>) to the <EM>activation record</EM>
of the function executing at a given level.
Level 0 is the current running function,
while level <I>n+1</I> is the function that has called level <I>n</I>.
When called with a level greater than the stack depth,
<CODE>lua_stackedfunction</CODE> returns <CODE>LUA_NOOBJECT</CODE>.
<P>
The type <CODE>lua_Function</CODE> is just another name
to <CODE>lua_Object</CODE>.
Although, in this library,
a <CODE>lua_Function</CODE> can be used wherever a <CODE>lua_Object</CODE> is required,
when a parameter has type <CODE>lua_Function</CODE>
it accepts only a handle returned by
<CODE>lua_stackedfunction</CODE>.
<P>
Three other functions produce extra information about a function:
<LISTING>
void lua_funcinfo (lua_Object func, char **filename, int *linedefined);
int lua_currentline (lua_Function func);
char *lua_getobjname (lua_Object o, char **name);
</LISTING>
<CODE>lua_funcinfo</CODE> gives the file name and the line where the
given function has been defined.
If the ``function'' is in fact the main code of a chunk,
then <CODE>linedefined</CODE> is 0.
If the function is a C function,
then <CODE>linedefined</CODE> is -1, and <CODE>filename</CODE> is <CODE>"(C)"</CODE>.
<P>
The function <CODE>lua_currentline</CODE> gives the current line where
a given function is executing.
It only works if the function has been compiled with debug
information (see Section&nbsp;<A HREF="#pragma">4.8</A>).
When no line information is available, it returns -1.
<P>
Function <CODE>lua_getobjname</CODE> tries to find a reasonable name for
a given function.
Because functions in Lua are first class values,
they do not have a fixed name:
Some functions may be the value of many global variables,
while others may be stored only in a table field.
Function <CODE>lua_getobjname</CODE> first checks whether the given
function is a fallback.
If so, it returns the string <CODE>"fallback"</CODE>,
and <CODE>name</CODE> is set to point to the fallback name.
Otherwise, if the given function is the value of a global variable,
then <CODE>lua_getobjname</CODE> returns the string <CODE>"global"</CODE>,
and <CODE>name</CODE> points to the variable name.
If the given function is neither a fallback nor a global variable,
then <CODE>lua_getobjname</CODE> returns the empty string,
and <CODE>name</CODE> is set to <CODE>NULL</CODE>.
<P>
<A NAME="7.2"></A>
<H2>7.2 - Manipulating Local Variables</H2>
<P>
The following functions allow the manipulation of the
local variables of a given activation record.
They only work if the function has been compiled with debug
information (see Section&nbsp;<A HREF="#pragma">4.8</A>).
<LISTING>
lua_Object lua_getlocal (lua_Function func, int local_number, char **name);
int lua_setlocal (lua_Function func, int local_number);
</LISTING>
<CODE>lua_getlocal</CODE> returns the value of a local variable,
and sets <CODE>name</CODE> to point to the variable name.
<CODE>local_number</CODE> is an index for local variables.
The first parameter has index 1, and so on, until the
last active local variable.
When called with a <CODE>local_number</CODE> greater than the
number of active local variables,
or if the activation record has no debug information,
<CODE>lua_getlocal</CODE> returns <CODE>LUA_NOOBJECT</CODE>.
Formal parameters are the first local variables.
<P>
The function <CODE>lua_setlocal</CODE> sets the local variable
<CODE>local_number</CODE> to the value previously pushed on the stack
(see Section&nbsp;<A HREF="#valuesCLua">5.1</A>).
If the function succeeds, then it returns 1.
If <CODE>local_number</CODE> is greater than the number
of active local variables,
or if the activation record has no debug information,
then this function fails and returns 0.
<P>
<A NAME="7.3"></A>
<H2>7.3 - Hooks</H2>
<P>
The Lua interpreter offers two hooks for debugging purposes:
<LISTING>
typedef void (*lua_CHFunction) (lua_Function func, char *file, int line);
extern lua_CHFunction lua_callhook;
<P>
typedef void (*lua_LHFunction) (int line);
extern lua_LHFunction lua_linehook;
</LISTING>
The first one is called whenever the interpreter enters or leaves a
function.
When entering a function,
its parameters are a handle to the function activation record,
plus the file and the line where the function is defined (the same
information which is provided by <CODE>lua_funcinfo</CODE>);
when leaving a function, <CODE>func</CODE> is <CODE>LUA_NOOBJECT</CODE>,
<CODE>file</CODE> is <CODE>"(return)"</CODE>, and <CODE>line</CODE> is 0.
<P>
The other hook is called every time the interpreter changes
the line of code it is executing.
Its only parameter is the line number
(the same information which is provided by the call
<CODE>lua_currentline(lua_stackedfunction(0))</CODE>).
This second hook is only called if the active function
has been compiled with debug information (see Section&nbsp;<A HREF="#pragma">4.8</A>).
<P>
A hook is disabled when its value is <CODE>NULL</CODE>,
which is the initial value of both hooks.
<P>
<P>
<P>
<A NAME="lua-sa"></A>
<!-- ====================================================================== -->
<HR>
<A NAME="8."></A>
<H1>8 - Lua Stand-alone</H1> 
<P>
Although Lua has been designed as an extension language,
the language can also be used as a stand-alone interpreter.
An implementation of such an interpreter,
called simply <CODE>lua</CODE>,
is provided with the standard distribution.
This program can be called with any sequence of the following arguments:
<DL>
<DT><B><TT>-v</TT></B><DD> prints version information.
<DT><B><TT>-</TT></B><DD> runs interactively, accepting commands from standard input
until an <CODE>EOF</CODE>.
<DT><B><TT>-e stat</TT></B><DD> executes <CODE>stat</CODE> as a Lua chunk.
<DT><B><TT>var=exp</TT></B><DD> executes <CODE>var=exp</CODE> as a Lua chunk.
<DT><B><TT>filename</TT></B><DD> executes file <CODE>filename</CODE> as a Lua chunk.
</DL>
All arguments are handled in order.
For instance, an invocation like
<LISTING>
$ lua - a=1 prog.lua
</LISTING>
will first interact with the user until an <CODE>EOF</CODE>,
then will set <CODE>a</CODE> to 1,
and finally will run file <CODE>prog.lua</CODE>.
<P>
Please notice that the interaction with the shell may lead to
unintended results.
For instance, a call like
<LISTING>
$ lua a="name" prog.lua
</LISTING>
will <EM>not</EM> set <CODE>a</CODE> to the string <CODE>"name"</CODE>.
Instead, the quotes will be handled by the shell,
lua will get only <CODE>a=name</CODE> to run,
and <CODE>a</CODE> will finish with <B>nil</B>,
because the global variable <CODE>name</CODE> has not been initialized.
Instead, one should write
<LISTING>
$ lua 'a="name"' prog.lua
</LISTING>
<P>
<HR>
<A NAME="Acknowledgments"></A>
<h1>Acknowledgments</h1>
<P>
The authors would like to thank CENPES/PETROBRAS which,
jointly with TeCGraf, used extensively early versions of
this system and gave valuable comments.
The authors would also like to thank Carlos Henrique Levy,
who found the name of the game.
Lua means <EM>moon</EM> in Portuguese.
<P>
<P>
<P>
<P>
<HR>
<A NAME="Incompatibilities"></A>
<h1>Incompatibilities with Previous Versions</h1>
<P>
Although great care has been taken to avoid incompatibilities with
the previous public versions of Lua,
some differences had to be introduced.
Here is a list of all these incompatibilities.
<P>
<h2>Incompatibilities with <A NAME="version 2.4</h2>">version 2.4</h2></A>
The whole I/O facilities have been rewritten.
We strongly encourage programmers to adapt their code
to this new version.
However, we are keeping the old version of the libraries
in the distribution,
to allow a smooth transition.
The incompatibilities between the new and the old libraries are:
<UL>
<LI>The format facility of function <CODE>write</CODE> has been supersed by
function <CODE>format</CODE>;
therefore this facility has been dropped.
<LI>Function <CODE>read</CODE> now uses <EM>read patterns</EM> to specify
what to read;
this is incompatible with the old format options.
<LI>Function <CODE>strfind</CODE> now accepts patterns,
so it may have a different behavior when the pattern includes
special characters.
</UL>
<P>
<h2>Incompatibilities with <A NAME="version 2.2</h2>">version 2.2</h2></A>
<UL>
<LI>
Functions <CODE>date</CODE> and <CODE>time</CODE> (from <CODE>iolib</CODE>)
have been superseded by the new, more powerful version of function <CODE>date</CODE>.
<LI>
Function <CODE>append</CODE> (from <CODE>iolib</CODE>) now returns 1 whenever it succeeds,
whether the file is new or not.
<LI>
Function <CODE>int2str</CODE> (from <CODE>strlib</CODE>) has been superseded by new
function <CODE>format</CODE>, with parameter <CODE>"%c"</CODE>.
<LI>
The API lock mechanism has been superseded by the reference mechanism.
However, <CODE>lua.h</CODE> provides compatibility macros,
so there is no need to change programs.
<LI>
The API function <CODE>lua_pushliteral</CODE> now is just a macro to
<CODE>lua_pushstring</CODE>.
</UL>
<P>
<h2>Incompatibilities with <A NAME="version 2.1</h2>">version 2.1</h2></A>
<UL>
<LI>
The function <CODE>type</CODE> now returns the string <CODE>"function"</CODE>
both for C and Lua functions.
Because Lua functions and C functions are compatible,
this behavior is usually more useful.
When needed, the second result of function <TT>type</TT> may be used
to distinguish between Lua and C functions.
<LI>
A function definition only assigns the function value to the
given variable at execution time.
</UL>
<P>
<h2>Incompatibilities with <A NAME="version 1.1</h2>">version 1.1</h2></A>
<UL>
<LI>
The equality test operator now is denoted by <CODE>==</CODE>,
instead of <CODE>=</CODE>.
<LI>
The syntax for table construction has been greatly simplified.
The old <CODE>@(size)</CODE> has been substituted by <CODE>{}</CODE>.
The list constructor (formerly <CODE>@[...]</CODE>) and the record
constructor (formerly <CODE>@{...}</CODE>) now are both coded like
<CODE>{...}</CODE>.
When the construction involves a function call,
like in <CODE>@func{...}</CODE>,
the new syntax does not use the <CODE>@</CODE>.
More important, {\em a construction function must now
explicitly return the constructed table}.
<LI>
The function <CODE>lua_call</CODE> no longer has the parameter <CODE>nparam</CODE>.
<LI>
The function <CODE>lua_pop</CODE> is no longer available,
since it could lead to strange behavior.
In particular,
to access results returned from a Lua function,
the new macro <CODE>lua_getresult</CODE> should be used.
<LI>
The old functions <CODE>lua_storefield</CODE> and <CODE>lua_storeindexed</CODE>
have been replaced by
<LISTING>
int lua_storesubscript (void);
</LISTING>
with the parameters explicitly pushed on the stack.
<LI>
The functionality of the function <CODE>lua_errorfunction</CODE> has been
replaced by the <EM>fallback</EM> mechanism (see Section&nbsp;<A HREF="#error">4.8</A>).
<LI>
When calling a function from the Lua library,
parameters passed through the stack
must be pushed just before the corresponding call,
with no intermediate calls to Lua.
Special care should be taken with macros like
<CODE>lua_getindexed</CODE> and <CODE>lua_getfield</CODE>.
</UL>
<P>
<P>

<HR>
Last update:
Thu Jun 26 08:13:15 EST 1997
by <A HREF="http://www.tecgraf.puc-rio.br/~lhf/">lhf</A>.
</BODY>
</HTML>
