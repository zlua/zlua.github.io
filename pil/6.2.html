<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Programming in Lua : 6.2</title>
<link rel="stylesheet" type="text/css" href="pil.css">
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
</head>
<body>
<p class="warning">
<A HREF="contents.html"><IMG TITLE="Programming in Lua (first edition)" SRC="capa.jpg" ALT="" ALIGN="left"></A>This first edition was written for Lua 5.0. While still largely relevant for later versions, there are some differences.<BR>The third edition targets Lua 5.2 and is available at <A HREF="http://www.amazon.com/exec/obidos/ASIN/859037985X/theprogrammil3-20">Amazon</A> and other bookstores.<BR>By buying the book, you also help to <A HREF="../donations.html">support the Lua project</A>.
</p>
<table width="100%" class="nav">
<tr>
<td width="10%" align="left"><a href="6.1.html"><img src="left.png" alt="Previous"></a></td>
<td width="80%" align="center"><a href="contents.html">
<font color="gray">Programming in </font><font color="blue"> Lua</font>
</a></td>
<td width="10%" align="right"><a href="6.3.html"><img src="right.png" alt="Next"></a></td>
</tr>
<tr>
<td width="10%" align="left"></td>
<td width="80%" align="center"><a href="contents.html#P1">Part I. The Language</a>
<span class="spacer"></span>
<a href="contents.html#6">Chapter 6. More about Functions</a></td>
<td width="10%" align="right"></td></tr>
</table>
<hr>
<h2>6.2 &ndash; Non-Global Functions</h2>

<p>An obvious consequence of first-class functions is that
we can store functions not only in global variables,
but also in table fields and in local variables.

<p>We have already seen several examples of functions in table fields:
Most Lua libraries use this mechanism
(e.g., <code>io.read</code>, <code>math.sin</code>).
To create such functions in Lua,
we only have to put together the regular syntax for functions and
for tables:
<pre>
    Lib = {}
    Lib.foo = function (x,y) return x + y end
    Lib.goo = function (x,y) return x - y end
</pre>
Of course, we can also use constructors:
<pre>
    Lib = {
      foo = function (x,y) return x + y end,
      goo = function (x,y) return x - y end
    }
</pre>
Moreover, Lua offers yet another syntax to define such functions:
<pre>
    Lib = {}
    function Lib.foo (x,y)
      return x + y
    end
    function Lib.goo (x,y)
      return x - y
    end
</pre>
This last fragment is exactly equivalent to the first example.

<p>When we store a function into a local variable
we get a <em>local function</em>,
that is, a function that is restricted to a given scope.
Such definitions are particularly useful for packages:
Because Lua handles each chunk as a function,
a chunk may declare local functions,
which are visible only inside the chunk.
Lexical scoping ensures that other functions in the package
can use these local functions:
<pre>
    local f = function (...)
      ...
    end
    
    local g = function (...)
      ...
      f()   -- external local `f' is visible here
      ...
    end
</pre>
Lua supports such uses of local functions with a syntactic sugar
for them:
<pre>
    local function f (...)
      ...
    end
</pre>

<p>A subtle point arises in the definition of recursive local functions.
The naive approach does not work here:
<pre>
    local fact = function (n)
      if n == 0 then return 1
      else return n*fact(n-1)   -- buggy
      end
    end
</pre>
When Lua compiles the call <code>fact(n-1)</code>,
in the function body,
the local <code>fact</code> is not yet defined.
Therefore, that expression calls a global <code>fact</code>,
not the local one.
To solve that problem,
we must first define the local variable
and then define the function:
<pre>
    local fact
    fact = function (n)
      if n == 0 then return 1
      else return n*fact(n-1)
      end
    end
</pre>
Now the <code>fact</code> inside the function refers to the local variable.
Its value when the function is defined does not matter;
by the time the function executes,
<code>fact</code> already has the right value.
That is the way Lua expands its syntactic sugar for local functions,
so you can use it for recursive functions without worrying:
<pre>
    local function fact (n)
      if n == 0 then return 1
      else return n*fact(n-1)
      end
    end
</pre>
Of course, this trick does not work if you have indirect
recursive functions.
In such cases, you must use the equivalent of
an explicit forward declaration:
<pre>
    local f, g    -- `forward' declarations
    
    function g ()
      ...  f() ...
    end
    
    function f ()
      ...  g() ...
    end
</pre>

<hr>
<table width="100%" class="nav">
<tr>
<td width="90%" align="left">
<small>
  Copyright &copy; 2003&ndash;2004 Roberto Ierusalimschy.  All rights reserved.
</small>
</td>
<td width="10%" align="right"><a href="6.3.html"><img src="right.png" alt="Next"></a></td>
</tr>
</table>


</body></html>

